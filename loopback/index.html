<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audio Loopback with getUserMedia</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #f6f8fa;
            margin: 0;
            padding: 0;
            color: #222;
        }
        h1 {
            text-align: center;
            margin-top: 2rem;
            font-size: 2rem;
            font-weight: 600;
        }
        .status {
            display: block;
            margin: 1rem auto;
            padding: 0.5rem 1.5rem;
            width: fit-content;
            border-radius: 1rem;
            background: #e0e0e0;
            color: #555;
            font-weight: 500;
            font-size: 1.1rem;
            transition: background 0.2s, color 0.2s;
        }
        .status.running {
            background: #4caf50;
            color: #fff;
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 1.5rem 0;
        }
        button {
            padding: 0.7rem 2rem;
            font-size: 1rem;
            border: none;
            border-radius: 0.5rem;
            background: #1976d2;
            color: #fff;
            cursor: pointer;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(25, 118, 210, 0.08);
            transition: background 0.2s;
        }
        button:hover {
            background: #1565c0;
        }
        .controls {
            max-width: 400px;
            margin: 2rem auto;
            background: #fff;
            border-radius: 1rem;
            box-shadow: 0 2px 12px rgba(0,0,0,0.06);
            padding: 2rem;
        }
        .controls h2 {
            margin-top: 0;
            font-size: 1.2rem;
            font-weight: 600;
            color: #1976d2;
            margin-bottom: 1rem;
        }
        .controls label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            font-size: 1rem;
            cursor: pointer;
        }
        .controls input[type="checkbox"] {
            accent-color: #1976d2;
            width: 1.2em;
            height: 1.2em;
        }
    </style>
</head>
<body>
    <h1>Audio Loopback Tool</h1>
    <div id="status" class="status">Stopped</div>
    <div class="button-group">
        <button id="startBtn">Start Loopback</button>
        <button id="stopBtn">Stop Loopback</button>
    </div>
    <div class="controls">
        <h2>Audio Constraints</h2>
        <label>
            <input type="checkbox" id="gainControl">
            <span>Auto Gain Control</span>
        </label>
        <label>
            <input type="checkbox" id="noiseSuppression">
            <span>Noise Suppression</span>
        </label>
        <label>
            <input type="checkbox" id="echoCancellation">
            <span>Echo Cancellation</span>
        </label>
    </div>
        <label>
            <input type="checkbox" id="feedMonoToLeftOnly">
            <span>Feed Mono to Left Only</span>
        </label>
    <style>
        .vu-container {
            max-width: 400px;
            margin: 1rem auto 2rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
            align-items: center;
        }
        .vu-channel {
            flex: 1;
            background: #fff;
            border-radius: 0.5rem;
            padding: 0.75rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            text-align: center;
        }
        .vu-label {
            font-size: 0.95rem;
            color: #1976d2;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        .vu-bar {
            height: 10px;
            background: linear-gradient(90deg,#4caf50,#ff9800,#f44336);
            width: 0%;
            border-radius: 6px;
            transition: width 0.06s linear;
        }
        .vu-track {
            background: #e9edf2;
            border-radius: 6px;
            height: 10px;
            overflow: hidden;
        }
        .vu-db {
            font-size: 0.85rem;
            color: #555;
            margin-top: 0.5rem;
        }
    </style>

    <div class="vu-container" id="vuMeters" aria-hidden="false">
        <div class="vu-channel" id="vuLeft">
            <div class="vu-label">Left</div>
            <div class="vu-track"><div class="vu-bar" id="vuLeftBar"></div></div>
            <div class="vu-db" id="vuLeftDb">-- dB</div>
        </div>
        <div class="vu-channel" id="vuRight">
            <div class="vu-label">Right</div>
            <div class="vu-track"><div class="vu-bar" id="vuRightBar"></div></div>
            <div class="vu-db" id="vuRightDb">-- dB</div>
        </div>
    </div>

    <script>
    (function(){
        let meterCtx = null;
        let splitter = null;
        let sourceNode = null;
        let analyserL = null;
        let analyserR = null;
        let rafId = null;
        let previousStream = null;

        const leftBar = document.getElementById('vuLeftBar');
        const rightBar = document.getElementById('vuRightBar');
        const leftDb = document.getElementById('vuLeftDb');
        const rightDb = document.getElementById('vuRightDb');

        function ensureAudioContext() {
            if (!meterCtx || meterCtx.state === 'closed') {
                meterCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function createAnalyser(size = 2048) {
            const a = meterCtx.createAnalyser();
            a.fftSize = size;
            a.smoothingTimeConstant = 0.2;
            return a;
        }

        function startMeteringForStream(stream) {
            stopMetering();

            if (!stream) return;
            try {
                ensureAudioContext();
                sourceNode = meterCtx.createMediaStreamSource(stream);
                splitter = meterCtx.createChannelSplitter(2);

                analyserL = createAnalyser(1024);
                analyserR = createAnalyser(1024);

                sourceNode.connect(splitter);
                splitter.connect(analyserL, 0);
                splitter.connect(analyserR, 1);

                const bufL = new Float32Array(analyserL.fftSize);
                const bufR = new Float32Array(analyserR.fftSize);

                function update() {
                    analyserL.getFloatTimeDomainData(bufL);
                    analyserR.getFloatTimeDomainData(bufR);

                    const rms = arr => {
                        let sum = 0;
                        for (let i = 0; i < arr.length; i++) sum += arr[i] * arr[i];
                        return Math.sqrt(sum / arr.length) || 0;
                    };

                    const rL = rms(bufL);
                    const rR = rms(bufR);

                    // convert rms to dBFS roughly
                    const toDb = x => {
                        const db = 20 * Math.log10(x);
                        return Number.isFinite(db) ? Math.round(db) : -Infinity;
                    };

                    const dbL = toDb(rL);
                    const dbR = toDb(rR);

                    // map dB (-90..0) to 0..100%
                    const pct = db => {
                        if (!Number.isFinite(db)) return 0;
                        const clamped = Math.max(-90, Math.min(0, db));
                        return Math.round(((clamped + 90) / 90) * 100);
                    };

                    leftBar.style.width = pct(dbL) + '%';
                    rightBar.style.width = pct(dbR) + '%';
                    leftDb.textContent = (dbL === -Infinity ? '-∞' : dbL) + ' dB';
                    rightDb.textContent = (dbR === -Infinity ? '-∞' : dbR) + ' dB';

                    rafId = requestAnimationFrame(update);
                }
                update();
            } catch (e) {
                console.warn('Metering start error', e);
            }
        }

        function stopMetering() {
            if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
            try {
                if (splitter) { splitter.disconnect(); splitter = null; }
                if (analyserL) { analyserL.disconnect(); analyserL = null; }
                if (analyserR) { analyserR.disconnect(); analyserR = null; }
                if (sourceNode) { sourceNode.disconnect(); sourceNode = null; }
            } catch (_) {}
            leftBar.style.width = '0%';
            rightBar.style.width = '0%';
            leftDb.textContent = '-- dB';
            rightDb.textContent = '-- dB';
            previousStream = null;
        }

        // monitor the loopback audio element's srcObject for changes
        function monitorLoopAudio() {
            const getLoopAudio = () => document.getElementById('loopbackAudio');
            let last = null;

            function check() {
                const el = getLoopAudio();
                const stream = el ? el.srcObject : null;
                if (stream !== last) {
                    last = stream;
                    if (stream) {
                        previousStream = stream;
                        startMeteringForStream(stream);
                    } else {
                        stopMetering();
                    }
                }
            }

            // Polling is simple and robust across browsers
            setInterval(check, 250);
        }

        // start monitoring as soon as possible
        monitorLoopAudio();

        // expose for debug/explicit control if needed
        window.__vuMeter = {
            start: startMeteringForStream,
            stop: stopMetering
        };
    })();
    </script>
    <script>
        let audioCtx = null;
        let source = null;
        let stream = null;
    
       
        function setStatus(running) {
            const statusEl = document.getElementById('status');
            if (running) {
                statusEl.textContent = 'Running';
                statusEl.classList.add('running');
            } else {
                statusEl.textContent = 'Stopped';
                statusEl.classList.remove('running');
            }
        }



        async function startLoopback() {
            const autoGainControl = document.getElementById('gainControl').checked;
            const noiseSuppression = document.getElementById('noiseSuppression').checked;
            const echoCancellation = document.getElementById('echoCancellation').checked;
            const feedMonoToLeftOnly = document.getElementById('feedMonoToLeftOnly').checked;

            stopLoopback();

            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        autoGainControl,
                        noiseSuppression,
                        echoCancellation,
                        channelCount: 2,
                    }
                });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                source = audioCtx.createMediaStreamSource(stream);
                audioCtx.destination.channelCount = 2;

                if (!feedMonoToLeftOnly) {
                    source.connect(audioCtx.destination);
                    setStatus(true);
                    return;
                }
            
                // route audio only to the left channel
                const origSource = source;
                const splitter = audioCtx.createChannelSplitter(2);
                const leftGain = audioCtx.createGain();
                const rightGain = audioCtx.createGain();
                const merger = audioCtx.createChannelMerger(2);

                leftGain.gain.value = 1;
                rightGain.gain.value = 0;

                origSource.connect(splitter);
                splitter.connect(leftGain, 0);
                splitter.connect(rightGain, 1);

                leftGain.connect(merger, 0, 0); // left output
                rightGain.connect(merger, 0, 1); // right output (silent)

                const outNode = audioCtx.createGain();
                merger.connect(outNode);

                // ensure the subsequent `source.connect(audioCtx.destination)` connects our processed output
                source = outNode;
                source.connect(audioCtx.destination);
                setStatus(true);
            } catch (err) {
                alert('Error accessing microphone: ' + err.message);
                setStatus(false);
            }
        }

        // add input/output device selectors and override start/stop to use them
            const controls = document.querySelector('.controls');
            const deviceContainer = document.createElement('div');
            deviceContainer.style.marginBottom = '1rem';
            deviceContainer.style.display = 'flex';
            deviceContainer.style.flexDirection = 'column';
            deviceContainer.style.gap = '0.5rem';

            const makeSelectRow = (labelText, id) => {
                const wrapper = document.createElement('label');
                wrapper.style.display = 'flex';
                wrapper.style.flexDirection = 'column';
                wrapper.style.fontSize = '1rem';
                wrapper.style.gap = '0.25rem';
                const label = document.createElement('span');
                label.textContent = labelText;
                const select = document.createElement('select');
                select.id = id;
                select.style.padding = '0.35rem';
                wrapper.appendChild(label);
                wrapper.appendChild(select);
                return { wrapper, select };
            };

            const { wrapper: inWrap, select: inputSelect } = makeSelectRow('Input Device', 'inputSelect');
            const { wrapper: outWrap, select: outputSelect } = makeSelectRow('Output Device', 'outputSelect');
            deviceContainer.appendChild(inWrap);
            deviceContainer.appendChild(outWrap);
            controls.insertBefore(deviceContainer, controls.firstChild);

            // hidden audio element used to set sinkId for output selection
            let loopAudio = document.getElementById('loopbackAudio');
            if (!loopAudio) {
                loopAudio = document.createElement('audio');
                loopAudio.id = 'loopbackAudio';
                loopAudio.autoplay = true;
                loopAudio.style.display = 'none';
                document.body.appendChild(loopAudio);
            }

            let currentStream = null;

            async function populateDeviceLists() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const inputs = devices.filter(d => d.kind === 'audioinput');
                    const outputs = devices.filter(d => d.kind === 'audiooutput');

                    const fill = (select, list, placeholder) => {
                        const prev = select.value;
                        select.innerHTML = '';
                        if (list.length === 0) {
                            const opt = document.createElement('option');
                            opt.value = '';
                            opt.textContent = `No ${placeholder} found`;
                            select.appendChild(opt);
                            return;
                        }
                        list.forEach((d, i) => {
                            const opt = document.createElement('option');
                            opt.value = d.deviceId;
                            opt.textContent = d.label || `${placeholder} ${i + 1} `;
                            opt.textContent += function(){ navigator.mediaDevices.getUserMedia({ audio: { deviceId: { exact: d.deviceId }, channelCount: 2 } }).then(s => { const t = s.getAudioTracks()[0]; let ch = '?'; try { const settings = t && t.getSettings ? t.getSettings() : {}; if (settings && settings.channelCount) ch = settings.channelCount; else if (t && t.getCapabilities) { const caps = t.getCapabilities(); if (caps && caps.channelCount) ch = Array.isArray(caps.channelCount) ? caps.channelCount[caps.channelCount.length-1] : caps.channelCount; } } catch(_) {} opt.textContent = (d.label || (placeholder + ' ' + (i + 1))) + ' — ' + ch + 'ch'; s.getTracks().forEach(track => track.stop()); }).catch(()=>{}); return '' }();
                                                        select.appendChild(opt);
                        });
                        if (prev && Array.from(select.options).some(o => o.value === prev)) {
                            select.value = prev;
                        }
                    };

                    fill(inputSelect, inputs, 'Microphone');
                    fill(outputSelect, outputs, 'Speaker');
                } catch (e) {
                    console.warn('Could not list media devices:', e);
                }
            }

            async function applyOutputSink(stream) {
                loopAudio.srcObject = stream;
                // setSinkId supported in many Chromium browsers
                if (typeof loopAudio.setSinkId === 'function') {
                    const sink = outputSelect.value;
                    if (sink) {
                        try {
                            await loopAudio.setSinkId(sink);
                        } catch (e) {
                            console.warn('setSinkId failed:', e);
                        }
                    }
                }
            }

            // override startLoopback and stopLoopback to support device selection
            async function startLoopback() {
                // stop any existing stream
                stopLoopback();

                const autoGainControl = document.getElementById('gainControl').checked;
                const noiseSuppression = document.getElementById('noiseSuppression').checked;
                const echoCancellation = document.getElementById('echoCancellation').checked;

                const deviceId = inputSelect.value || undefined;

                try {
                    currentStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            deviceId: deviceId ? { exact: deviceId } : undefined,
                            autoGainControl,
                            noiseSuppression,
                            echoCancellation
                        }
                    });

                    await applyOutputSink(currentStream);
                    setStatus(true);
                } catch (err) {
                    alert('Error accessing microphone or device: ' + err.message);
                    setStatus(false);
                }
            }

            function stopLoopback() {
                if (currentStream) {
                    currentStream.getTracks().forEach(t => t.stop());
                    currentStream = null;
                }
                if (loopAudio) {
                    loopAudio.srcObject = null;
                }
                setStatus(false);
            }

            // wire controls (override previous handlers)
            document.getElementById('startBtn').onclick = startLoopback;
            document.getElementById('stopBtn').onclick = stopLoopback;

            inputSelect.addEventListener('change', () => {
                if (document.getElementById('status').textContent === 'Running') startLoopback();
            });
            outputSelect.addEventListener('change', () => {
                if (currentStream) applyOutputSink(currentStream);
            });

            // refresh device lists on change and on load
            navigator.mediaDevices.addEventListener('devicechange', populateDeviceLists);
            populateDeviceLists();
            

        document.getElementById('startBtn').onclick = startLoopback;
        document.getElementById('stopBtn').onclick = stopLoopback;

        ['gainControl', 'noiseSuppression', 'echoCancellation'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if (audioCtx) {
                    startLoopback();
                }
            });
        });

         navigator.mediaDevices.getUserMedia({ audio: true})
            .then(() => {
                populateDeviceLists();
            })
            .catch((err) => {
                alert('Microphone access is required for this tool to function.');
            });


        setStatus(false);
    </script>
</body>
</html>