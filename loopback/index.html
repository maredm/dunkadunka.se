<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audio Loopback with getUserMedia</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #f6f8fa;
            margin: 0;
            padding: 0;
            color: #222;
        }
        h1 {
            text-align: center;
            margin-top: 2rem;
            font-size: 2rem;
            font-weight: 600;
        }
        .status {
            display: block;
            margin: 1rem auto;
            padding: 0.5rem 1.5rem;
            width: fit-content;
            border-radius: 1rem;
            background: #e0e0e0;
            color: #555;
            font-weight: 500;
            font-size: 1.1rem;
            transition: background 0.2s, color 0.2s;
        }
        .status.running {
            background: #4caf50;
            color: #fff;
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 1.5rem 0;
        }
        button {
            padding: 0.7rem 2rem;
            font-size: 1rem;
            border: none;
            border-radius: 0.5rem;
            background: #1976d2;
            color: #fff;
            cursor: pointer;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(25, 118, 210, 0.08);
            transition: background 0.2s;
        }
        button:hover {
            background: #1565c0;
        }
        .controls {
            max-width: 400px;
            margin: 2rem auto;
            background: #fff;
            border-radius: 1rem;
            box-shadow: 0 2px 12px rgba(0,0,0,0.06);
            padding: 2rem;
        }
        .controls h2 {
            margin-top: 0;
            font-size: 1.2rem;
            font-weight: 600;
            color: #1976d2;
            margin-bottom: 1rem;
        }
        .controls label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            font-size: 1rem;
            cursor: pointer;
        }
        .controls input[type="checkbox"] {
            accent-color: #1976d2;
            width: 1.2em;
            height: 1.2em;
        }
    </style>
</head>
<body>
    <h1>Audio Loopback Tool</h1>
    <div id="status" class="status">Stopped</div>
    <div class="button-group">
        <button id="startBtn">Start Loopback</button>
        <button id="stopBtn">Stop Loopback</button>
    </div>
    <div class="controls">
        <h2>Audio Constraints</h2>
        <label>
            <input type="checkbox" id="gainControl">
            <span>Auto Gain Control</span>
        </label>
        <label>
            <input type="checkbox" id="noiseSuppression">
            <span>Noise Suppression</span>
        </label>
        <label>
            <input type="checkbox" id="echoCancellation">
            <span>Echo Cancellation</span>
        </label>
    </div>
    <script>
        let audioCtx = null;
        let source = null;
        let stream = null;
    
        navigator.mediaDevices.getUserMedia({ audio: true})
            .then(() => {
                // Permission granted
            })
            .catch((err) => {
                alert('Microphone access is required for this tool to function.');
            });

        function setStatus(running) {
            const statusEl = document.getElementById('status');
            if (running) {
                statusEl.textContent = 'Running';
                statusEl.classList.add('running');
            } else {
                statusEl.textContent = 'Stopped';
                statusEl.classList.remove('running');
            }
        }

        async function startLoopback() {
            const autoGainControl = document.getElementById('gainControl').checked;
            const noiseSuppression = document.getElementById('noiseSuppression').checked;
            const echoCancellation = document.getElementById('echoCancellation').checked;

            stopLoopback();

            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        autoGainControl,
                        noiseSuppression,
                        echoCancellation
                    }
                });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                source = audioCtx.createMediaStreamSource(stream);
                source.connect(audioCtx.destination);
                setStatus(true);
            } catch (err) {
                alert('Error accessing microphone: ' + err.message);
                setStatus(false);
            }
        }

        // add input/output device selectors and override start/stop to use them
            const controls = document.querySelector('.controls');
            const deviceContainer = document.createElement('div');
            deviceContainer.style.marginBottom = '1rem';
            deviceContainer.style.display = 'flex';
            deviceContainer.style.flexDirection = 'column';
            deviceContainer.style.gap = '0.5rem';

            const makeSelectRow = (labelText, id) => {
                const wrapper = document.createElement('label');
                wrapper.style.display = 'flex';
                wrapper.style.flexDirection = 'column';
                wrapper.style.fontSize = '1rem';
                wrapper.style.gap = '0.25rem';
                const label = document.createElement('span');
                label.textContent = labelText;
                const select = document.createElement('select');
                select.id = id;
                select.style.padding = '0.35rem';
                wrapper.appendChild(label);
                wrapper.appendChild(select);
                return { wrapper, select };
            };

            const { wrapper: inWrap, select: inputSelect } = makeSelectRow('Input Device', 'inputSelect');
            const { wrapper: outWrap, select: outputSelect } = makeSelectRow('Output Device', 'outputSelect');
            deviceContainer.appendChild(inWrap);
            deviceContainer.appendChild(outWrap);
            controls.insertBefore(deviceContainer, controls.firstChild);

            // hidden audio element used to set sinkId for output selection
            let loopAudio = document.getElementById('loopbackAudio');
            if (!loopAudio) {
                loopAudio = document.createElement('audio');
                loopAudio.id = 'loopbackAudio';
                loopAudio.autoplay = true;
                loopAudio.style.display = 'none';
                document.body.appendChild(loopAudio);
            }

            let currentStream = null;

            async function populateDeviceLists() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const inputs = devices.filter(d => d.kind === 'audioinput');
                    const outputs = devices.filter(d => d.kind === 'audiooutput');

                    const fill = (select, list, placeholder) => {
                        const prev = select.value;
                        select.innerHTML = '';
                        if (list.length === 0) {
                            const opt = document.createElement('option');
                            opt.value = '';
                            opt.textContent = `No ${placeholder} found`;
                            select.appendChild(opt);
                            return;
                        }
                        list.forEach((d, i) => {
                            const opt = document.createElement('option');
                            opt.value = d.deviceId;
                            opt.textContent = d.label || `${placeholder} ${i + 1}`;
                            select.appendChild(opt);
                        });
                        if (prev && Array.from(select.options).some(o => o.value === prev)) {
                            select.value = prev;
                        }
                    };

                    fill(inputSelect, inputs, 'Microphone');
                    fill(outputSelect, outputs, 'Speaker');
                } catch (e) {
                    console.warn('Could not list media devices:', e);
                }
            }

            async function applyOutputSink(stream) {
                loopAudio.srcObject = stream;
                // setSinkId supported in many Chromium browsers
                if (typeof loopAudio.setSinkId === 'function') {
                    const sink = outputSelect.value;
                    if (sink) {
                        try {
                            await loopAudio.setSinkId(sink);
                        } catch (e) {
                            console.warn('setSinkId failed:', e);
                        }
                    }
                }
            }

            // override startLoopback and stopLoopback to support device selection
            async function startLoopback() {
                // stop any existing stream
                stopLoopback();

                const autoGainControl = document.getElementById('gainControl').checked;
                const noiseSuppression = document.getElementById('noiseSuppression').checked;
                const echoCancellation = document.getElementById('echoCancellation').checked;

                const deviceId = inputSelect.value || undefined;

                try {
                    currentStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            deviceId: deviceId ? { exact: deviceId } : undefined,
                            autoGainControl,
                            noiseSuppression,
                            echoCancellation
                        }
                    });

                    await applyOutputSink(currentStream);
                    setStatus(true);
                } catch (err) {
                    alert('Error accessing microphone or device: ' + err.message);
                    setStatus(false);
                }
            }

            function stopLoopback() {
                if (currentStream) {
                    currentStream.getTracks().forEach(t => t.stop());
                    currentStream = null;
                }
                if (loopAudio) {
                    loopAudio.srcObject = null;
                }
                setStatus(false);
            }

            // wire controls (override previous handlers)
            document.getElementById('startBtn').onclick = startLoopback;
            document.getElementById('stopBtn').onclick = stopLoopback;

            inputSelect.addEventListener('change', () => {
                if (document.getElementById('status').textContent === 'Running') startLoopback();
            });
            outputSelect.addEventListener('change', () => {
                if (currentStream) applyOutputSink(currentStream);
            });

            // refresh device lists on change and on load
            navigator.mediaDevices.addEventListener('devicechange', populateDeviceLists);
            populateDeviceLists();
            

        document.getElementById('startBtn').onclick = startLoopback;
        document.getElementById('stopBtn').onclick = stopLoopback;

        ['gainControl', 'noiseSuppression', 'echoCancellation'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if (audioCtx) {
                    startLoopback();
                }
            });
        });

        setStatus(false);
    </script>
</body>
</html>