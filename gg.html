<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Realtime FIR (WAV) Filter — Microphone</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; padding: 20px; max-width: 900px; margin: auto; }
    h1 { margin-top: 0; font-size: 1.2rem; }
    .row { display:flex; gap:10px; align-items:center; margin:10px 0; flex-wrap:wrap; }
    label { font-weight:600; }
    .status { font-size:0.9rem; color:#444; }
    input[type="file"] { padding:6px; }
    button { padding:8px 12px; }
    .meter { height: 10px; background:#eee; width:100%; border-radius:6px; overflow:hidden; }
    .meter > i { display:block; height:100%; background:linear-gradient(90deg,#4caf50,#ff9800); width:0%; transition: width 0.06s linear; }
    select { padding:6px; min-width:200px; }
    footer { margin-top:18px; font-size:0.85rem; color:#666; }
  </style>
</head>
<body>
  <h1>Realtime FIR Filter (WAV) — Microphone</h1>

  <div class="row">
    <label for="irFile">Load FIR (WAV):</label>
    <input id="irFile" type="file" accept="audio/fir" />
    <span id="irName" class="status">No IR loaded</span>
  </div>

  <div class="row">
    <label for="inputSelect">Input device:</label>
    <select id="inputSelect"></select>
    <label for="outputSelect">Output device:</label>
    <select id="outputSelect"></select>
  </div>

  <div class="row">
    <button id="startBtn">Start Microphone</button>
    <button id="stopBtn" disabled>Stop</button>
    <label style="margin-left:8px"><input id="bypass" type="checkbox" /> Bypass</label>
  </div>

  <div class="row">
    <label for="wet">Wet / Dry:</label>
    <input id="wet" type="range" min="0" max="1" step="0.01" value="1" />
    <span id="wetVal">1.00</span>
  </div>

  <div class="row">
    <label>Input Level:</label>
    <div style="flex:1">
      <div class="meter"><i id="inMeter"></i></div>
    </div>
  </div>

  <div class="row">
    <label>Output Level:</label>
    <div style="flex:1">
      <div class="meter"><i id="outMeter"></i></div>
    </div>
  </div>

  <p class="status" id="message">Status: idle</p>

  <footer>Space toggles start/stop. Use a WAV impulse response for FIR behavior.</footer>

  <!-- Hidden audio element used to route WebAudio output to a chosen device via setSinkId -->
  <audio id="outputAudio" autoplay playsinline style="display:none"></audio>

<script>
(async function () {
  const irFile = document.getElementById('irFile');
  const irName = document.getElementById('irName');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const bypass = document.getElementById('bypass');
  const wet = document.getElementById('wet');
  const wetVal = document.getElementById('wetVal');
  const message = document.getElementById('message');
  const inMeter = document.getElementById('inMeter');
  const outMeter = document.getElementById('outMeter');
  const inputSelect = document.getElementById('inputSelect');
  const outputSelect = document.getElementById('outputSelect');
  const outputAudio = document.getElementById('outputAudio');

  let audioCtx = null;
  let micStream = null;
  let micSource = null;
  let convolver = null;
  let dryGain = null;
  let wetGain = null;
  let analyserIn = null;
  let analyserOut = null;
  let meterAnim = null;
  let irBuffer = null;
  let outputDestination = null;
  let usingSetSink = typeof HTMLMediaElement.prototype.setSinkId === 'function';

  function setMessage(s) { message.textContent = 'Status: ' + s; }

  async function decodeAudioBuffer(ctx, ab) {
    if (ctx.decodeAudioData.length === 1) return await ctx.decodeAudioData(ab);
    return await new Promise((res, rej) => ctx.decodeAudioData(ab, res, rej));
  }

  // populate device lists
  async function refreshDeviceList() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const inputs = devices.filter(d => d.kind === 'audioinput');
      const outputs = devices.filter(d => d.kind === 'audiooutput');

      const prevInput = inputSelect.value;
      const prevOutput = outputSelect.value;

      inputSelect.innerHTML = '';
      outputSelect.innerHTML = '';

      inputs.forEach(d => {
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Input ${inputSelect.length + 1}`;
        inputSelect.appendChild(opt);
      });
      outputs.forEach(d => {
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Output ${outputSelect.length + 1}`;
        outputSelect.appendChild(opt);
      });

      if (prevInput) inputSelect.value = Array.from(inputSelect.options).some(o => o.value === prevInput) ? prevInput : inputSelect.value;
      if (prevOutput) outputSelect.value = Array.from(outputSelect.options).some(o => o.value === prevOutput) ? prevOutput : outputSelect.value;
    } catch (err) {
      console.warn('Could not list devices', err);
    }
  }

  navigator.mediaDevices.addEventListener?.('devicechange', refreshDeviceList);
  await refreshDeviceList();

  // load the uploaded WAV and decode to AudioBuffer
  irFile.addEventListener('change', async (evt) => {
    const f = evt.target.files && evt.target.files[0];
    if (!f) return;
    irName.textContent = f.name;
    setMessage('Loading IR...');
    try {
      const ab = await f.arrayBuffer();
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        irBuffer = await decodeAudioBuffer(audioCtx, ab.slice ? ab.slice(0) : ab);
        setMessage('IR loaded: ' + f.name + ' (' + irBuffer.length + ' samples, ' + irBuffer.sampleRate + ' Hz)');
        // Apply gain to IR buffer
        const gain = 1; // Adjust this value (0-1) to control IR level
        for (let ch = 0; ch < irBuffer.numberOfChannels; ch++) {
          const data = irBuffer.getChannelData(ch);
          for (let i = 0; i < data.length; i++) {
            data[i] *= gain;
          }
        }
        
      if (convolver) convolver.buffer = irBuffer;
      console.log('Loaded IR buffer', irBuffer.getChannelData(0).slice(0, 100));
    } catch (err) {
      console.error(err);
      setMessage('Failed to load IR: ' + (err && err.message ? err.message : err));
      irName.textContent = 'No IR loaded';
      irBuffer = null;
    }
  });

  async function startMic() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch(e){}
    }
    setMessage('Requesting microphone...');
    const constraints = { audio: { echoCancellation: false, autoGainControl: false, noiseSuppression: false, deviceId: inputSelect.value ? { exact: inputSelect.value } : undefined, channelCount: 1 }, video: false };
    try {
      micStream = await navigator.mediaDevices.getUserMedia(constraints);
    } catch (err) {
      setMessage('Microphone access denied');
      console.error(err);
      return;
    }
    setMessage('Creating audio graph...');
    micSource = audioCtx.createMediaStreamSource(micStream);

    convolver = audioCtx.createConvolver();
    convolver.normalize = false;
    if (irBuffer) convolver.buffer = irBuffer;

    dryGain = audioCtx.createGain();
    wetGain = audioCtx.createGain();
    wetGain.gain.value = parseFloat(wet.value);
    dryGain.gain.value = 1 - parseFloat(wet.value);

    analyserIn = audioCtx.createAnalyser();
    analyserIn.fftSize = 256;
    analyserOut = audioCtx.createAnalyser();
    analyserOut.fftSize = 256;

    // routing
    const splitter = audioCtx.createChannelSplitter(1);
    micSource.connect(splitter);
    splitter.connect(dryGain, 0);
    splitter.connect(convolver, 0);
    convolver.connect(analyserOut);

    // Decide output routing based on setSinkId support
    if (usingSetSink) {
      // route to MediaStreamDestination and attach to hidden audio element
      outputDestination = audioCtx.createMediaStreamDestination();
      analyserOut.connect(wetGain);
      wetGain.connect(outputDestination);
      dryGain.connect(outputDestination);
      // set srcObject and apply sink id if available
      outputAudio.srcObject = outputDestination.stream;
      try {
        await outputAudio.play().catch(()=>{});
      } catch(e){}
      // attempt to set desired device
      const selectedOut = outputSelect.value;
      if (selectedOut && typeof outputAudio.setSinkId === 'function') {
        try { await outputAudio.setSinkId(selectedOut); } catch (err) { console.warn('setSinkId failed', err); }
      }
    } else {
      // fallback: directly connect to audioCtx.destination (default device)
      analyserOut.connect(wetGain);
      wetGain.connect(audioCtx.destination);
      dryGain.connect(audioCtx.destination);
    }

    // connect analyserIn for meter
    micSource.connect(analyserIn);

    startMeter();
    setMessage('Running');
    startBtn.disabled = true;
    stopBtn.disabled = false;
  }

  function stopMic() {
    if (micStream) micStream.getTracks().forEach(t => t.stop());
    try { micSource && micSource.disconnect(); } catch(e){}
    try { convolver && convolver.disconnect(); } catch(e){}
    try { dryGain && dryGain.disconnect(); } catch(e){}
    try { wetGain && wetGain.disconnect(); } catch(e){}
    try { analyserIn && analyserIn.disconnect(); } catch(e){}
    try { analyserOut && analyserOut.disconnect(); } catch(e){}
    try { if (outputAudio) { outputAudio.pause(); outputAudio.srcObject = null; } } catch(e){}
    micStream = null;
    micSource = null;
    outputDestination = null;
    stopMeter();
    setMessage('Stopped');
    startBtn.disabled = false;
    stopBtn.disabled = true;
  }

  startBtn.addEventListener('click', async () => {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') await audioCtx.resume();
    await startMic();
  });
  stopBtn.addEventListener('click', () => stopMic());

  // output device change while running
  outputSelect.addEventListener('change', async () => {
    if (!usingSetSink) {
      setMessage('Output device selection not supported in this browser; using default output.');
      return;
    }
    const id = outputSelect.value;
    if (!outputAudio) return;
    try {
      await outputAudio.setSinkId(id);
      setMessage('Output device switched');
    } catch (err) {
      console.warn('setSinkId error', err);
      setMessage('Could not switch output device');
    }
  });

  bypass.addEventListener('change', () => {
    if (!dryGain || !wetGain) return;
    if (bypass.checked) {
      dryGain.gain.value = 1;
      wetGain.gain.value = 0;
    } else {
      const v = parseFloat(wet.value);
      wetGain.gain.value = v;
      dryGain.gain.value = 1 - v;
    }
  });

  wet.addEventListener('input', () => {
    const v = parseFloat(wet.value);
    wetVal.textContent = v.toFixed(2);
    if (bypass.checked) return;
    if (wetGain && dryGain) {
      wetGain.gain.value = v;
      dryGain.gain.value = 1 - v;
    }
  });

  function startMeter() {
    if (!analyserIn || !analyserOut) return;
    const bufIn = new Uint8Array(analyserIn.frequencyBinCount);
    const bufOut = new Uint8Array(analyserOut.frequencyBinCount);

    function frame() {
      analyserIn.getByteTimeDomainData(bufIn);
      analyserOut.getByteTimeDomainData(bufOut);
      let sumIn = 0, sumOut = 0;
      for (let i=0;i<bufIn.length;i++){
        const x = (bufIn[i]-128)/128;
        sumIn += x*x;
      }
      for (let i=0;i<bufOut.length;i++){
        const x = (bufOut[i]-128)/128;
        sumOut += x*x;
      }
      const rmsIn = Math.sqrt(sumIn / bufIn.length);
      const rmsOut = Math.sqrt(sumOut / bufOut.length);
      inMeter.style.width = Math.min(100, Math.max(0, rmsIn*200)) + '%';
      outMeter.style.width = Math.min(100, Math.max(0, rmsOut*200)) + '%';
      meterAnim = requestAnimationFrame(frame);
    }
    meterAnim = requestAnimationFrame(frame);
  }

  function stopMeter() {
    if (meterAnim) cancelAnimationFrame(meterAnim);
    inMeter.style.width = '0%';
    outMeter.style.width = '0%';
  }

  // Refresh device list on page load and when devices change
  await refreshDeviceList();
  navigator.mediaDevices.addEventListener?.('devicechange', refreshDeviceList);

  window.addEventListener('pagehide', stopMic);
  window.addEventListener('unload', stopMic);

  window.addEventListener('keydown', (e) => {
    if (e.key === ' ' && !e.metaKey && !e.ctrlKey) {
      e.preventDefault();
      if (stopBtn.disabled) startBtn.click(); else stopBtn.click();
    }
  });
})();
</script>
</body>
</html>