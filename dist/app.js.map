{"version":3,"sources":["/workspaces/dunkadunka.se/dist/app.js","../src/math.ts","../src/fft.ts","../src/fractional_octave_smoothing.ts","../src/audio.ts","../src/windows.ts","../src/farina.ts","../src/storage.ts","../src/device-settings.ts","../src/app.ts"],"names":["console","debug","logspace","start","end","num","logStart","Math","log10","logEnd","logStep","Float32Array","from","length","_","i","pow","linspace","step","closest","arr","curr","diff","abs","index","val","newDiff","average","array","reduce","a","b","re","im","sqrt","mod","n","m","nextPow2","v","p","max","maxVal","Infinity","FFT","size","Error","_csize","table","Array","angle","PI","cos","sin","power","t","_width","_bitrev","j","shift","revShift","_out","_data","_inv","fromComplexArray","complex","storage","res","createComplexArray","toComplexArray","input","completeSpectrum","spectrum","half","transform","out","data","_transform4","realTransform","_realTransform4","inverseTransform","width","len","outOff","bitrev","off","_singleTransform2","_singleTransform4","inv","quarterLen","limit","k","A","B","C","D","Ar","Ai","Br","Bi","Cr","Ci","Dr","Di","MAr","MAi","tableBr","tableBi","MBr","MBi","tableCr","tableCi","MCr","MCi","tableDr","tableDi","MDr","MDi","T0r","T0i","T1r","T1i","T2r","T2i","T3r","T3i","FAr","FAi","FCr","FCi","FBr","FBi","FDr","FDi","evenR","evenI","oddR","oddI","leftR","leftI","rightR","rightI","step2","step3","_singleRealTransform2","_singleRealTransform4","halfLen","hquarterLen","ST0r","ST0i","ST1r","ST1i","ST2r","ST2i","ST3r","ST3i","SFAr","SFAi","SFBr","SFBi","SA","SB","getFractionalOctaveFrequencies","fraction","f_low","f_high","fftSize","num_points","round","frequencies","frequency_resolution","Set","fractionalOctaveSmoothing","frequencyData","frequenciesAll","smoothedData","factor","sum","as","slice","min","window","buffer","rms","db","value","map","dbToLinear","loadAudioFile","file","headerBuffer","ext","mime","metadata","wavInfo","mp3Info","arrayBuffer","audioContext","audioBuffer","getExt","name","split","pop","toLowerCase","parseWav","buf","dv","DataView","readStr","s","String","fromCharCode","getUint8","offset","info","byteLength","id","getUint32","audioFormat","getUint16","numChannels","sampleRate","byteRate","blockAlign","bitsPerSample","dataChunkSize","duration","parseMp3","sampleRates","bytes","Uint8Array","headerIndex","b1","b2","b3","versionBits","layerBits","bitrateBits","sampleRateBits","channelMode","versions","layers","versionKey","layerKey","bitrateTable","versionStr","layerStr","bitrateKbps","tbKey","channels","version","layer","type","format","Object","assign","log","AudioContext","webkitAudioContext","decodeAudioData","Audio","fromAudioBuffer","_Audio","applyGain","gain","numberOfChannels","ch","getChannelData","copyToChannel","getChannel","channel","channelData","newBuffer","AudioBuffer","audio","fromSamples","samples","chirp","f_start","f_stop","rate","fade","fs","c","L","samples_count","fade_in","floor","fade_out","pre","post","phi","baseIdx","exp","last","sweep","envMain","startZeros","endZeros","envelope","w","sweepWindowed","smoothFFT","fftData","resolution","frequency","magnitude","phase","smoothedMagnitude","fractionalFrequencies","smoothed","smoothedPhase","computeFFT","ceil","log2","fft","frame","SQRT2","atan2","frequencyResolution","fftCorrelation","x","y","lenX","lenY","fullLen","xP","yP","set","ar","ai","br","bi","corr","Float64Array","sumX2","sumY2","denom","normalized","lags","Int32Array","peakIdx","peakVal","estimatedLag","estimatedLagSamples","estimatedLagIndex","peakCorrelation","raw","nfft","fftConvolve","mode","result","twoChannelImpulseResponse","N","epsilon","ir","peakAt","ir_complex","mean","twoChannelFFT","dataArray","reference","dataPadded","referencePadded","refLen","dataLen","reference_","signal_","signalMags","referenceMags","h","i_50","phase_signal","phase_reference","sphase","unwrapPhase","correction","phases","theta","delta","computeFFTFromIR","f_phase_wrap","i_norm","unwraped_phase","corrected_unwraped_phase","groupDelays","normalizeAt","groupDelay","dPhase","dFreq","normIdx","delayAtNorm","A_WEIGHTING_COEFFICIENTS","K_WEIGHTING_COEFFICIENTS_PRE","K_WEIGHTING_COEFFICIENTS_RLB","applyAWeightingToBuffer","zi","output","gateBuffer","thresholdDb","blockMs","overlap","blockSize","hopSize","threshold","gated","block","blockRms","hanningWindow","hammingWindow","blackmanWindow","rectangularWindow","fill","getSelectedWindow","windowType","wcf","Farina","stimulus","deconvolved","lag_of_harmonic","ell","margin_of_harmonic","max_safe_harmonic","window_size","push","instant","signal","at","sig","deconvolution","si","customLength","inv_stimulus","reverse","norm","FarinaImpulseResponse","farina","measurementResponse","openIDB","Promise","resolve","reject","req","indexedDB","open","onupgradeneeded","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","onerror","error","setItem","key","tx","store","e","transaction","objectStore","put","oncomplete","onabort","getItem","get","removeItem","delete","clearStorage","clear","sessionStorage","dumpStorage","openCursor","event","cursor","target","continue","INPUT_KEY","OUTPUT_KEY","openDeviceSettings","modal","document","getElementById","style","display","initDeviceSettings","closeDeviceSettings","ensureDeviceAccess","navigator","mediaDevices","getUserMedia","video","refreshAudioDeviceList","devices","inputSel","outputSel","inputId","outputId","note","sinkSupported","enumerateDevices","warn","innerHTML","localStorage","forEach","d","kind","opt","createElement","deviceId","textContent","label","selected","appendChild","HTMLMediaElement","prototype","applyOutputDevice","router","setSinkId","saveDeviceSelections","onchange","addEventListener","outId","root","documentElement","uiColor","setProperty","tabCounter","tabsContainer","tabsInnerContainer","tabContents","responseFileInput","referenceFileInput","analyzeBtn","disabled","files","acquisitionState","mediaRecorder","recordedChunks","oscillatorNode","playbackSource","isRecording","startBtn","stopBtn","playBtn","stopPlayBtn","sweepStartFreqInput","sweepEndFreqInput","sweepDurationInput","recordingStatusEl","recordingMeterEl","recordingVisualizationEl","recordedAudioContainer","recordedAudioEl","analyzeRecordingBtn","viewWaveformBtn","channelSelectionContainer","channelSelect","initializeAudioContext","state","resume","detectAndSetupChannels","source","stream","analyser","channelCount","option","channelNames","echoCancellation","noiseSuppression","autoGainControl","createAnalyser","createMediaStreamSource","connect","mediaStream","getAudioTracks","getSettings","getTracks","track","stop","toString","classList","dataset","tab","startRecordingAndPlayback","startFreq","endFreq","preRecordTime","postRecordTime","totalRecordTime","sweepSignal","sourceGain","MediaRecorder","ondataavailable","onstop","recordedBlob","url","Blob","URL","createObjectURL","src","parseFloat","createBuffer","createGain","toFixed","setTimeout","createBufferSource","destination","stopRecording","message","color","playbackOnly","stopPlayback","response","selectedChannel","recordedAudio","referenceAudio","now","dateTime","recordingName","fetch","parseInt","Date","toLocaleString","year","month","day","hour","minute","second","hour12","replace","createAnalysisTab","alert","saveState","err","parentElement","tabId","remove","querySelector","catch","switchTab","stopPropagation","querySelectorAll","add","responseFile","referenceFile","responseData","referenceData","filename","referenceFilename","shortName","substring","shortReferenceName","className","content","responseSamples","responseFFT","smoothedResponseFFT","tracesMagnitude","line","tracesPhase","tracesPhaseSecondary","tracesIR","irPeakAt","referenceSamples","referenceFFT","farina_ir","transferFunction","transferFunctionFarina","smoothedFreqResponse","smoothedFreqResponseFarina","rmsValue","gd","dash","yaxis","plotSettings","plotGlPixelRatio","legend","plot_bgcolor","paper_bgcolor","staticPlot","dragmode","showAxisDragHandles","showAxisRangeEntryBoxes","axisDragOnHover","tightenLats","font","family","margin","r","l","layoutPhase","title","xaxis","gridcolor","range","tickformat","automargin","yaxis2","anchor","overlaying","side","Plotly","newPlot","responsive","layoutMagnitude","rangemode","layoutIR","JSON","stringify","initResize","preventDefault","resize","stopResize","body","container","handle","rect","getBoundingClientRect","newWidth","clientX","left","removeEventListener","dispatchEvent","Event","box","setAttribute","checked","tabs","trim","loadState","savedTabs","analysisData","parse"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// src/math.ts\nconsole.debug(\"Math module loaded\");\nfunction logspace(start, end, num) {\n  const logStart = Math.log10(start);\n  const logEnd = Math.log10(end);\n  const logStep = (logEnd - logStart) / (num - 1);\n  return Float32Array.from({ length: num }, (_, i) => Math.pow(10, logStart + i * logStep));\n}\nfunction linspace(start, end, num) {\n  if (num === 1) return Float32Array.from([start]);\n  const step = (end - start) / (num - 1);\n  return Float32Array.from({ length: num }, (_, i) => start + i * step);\n}\nfunction closest(num, arr) {\n  let curr = arr[0];\n  let diff = Math.abs(num - curr);\n  let index = 0;\n  for (let val = 0; val < arr.length; val++) {\n    const newDiff = Math.abs(num - arr[val]);\n    if (newDiff < diff) {\n      diff = newDiff;\n      curr = arr[val];\n      index = val;\n    }\n  }\n  return index;\n}\nvar average = (array) => array.reduce((a, b) => a + b) / array.length;\nvar abs = (re, im = 0) => Math.sqrt(re * re + im * im);\nvar mod = (n, m) => (n % m + m) % m;\nvar nextPow2 = (v) => {\n  let p = 1;\n  while (p < v) p <<= 1;\n  return p;\n};\nfunction max(arr) {\n  let maxVal = -Infinity;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > maxVal) maxVal = Math.abs(arr[i]);\n  }\n  return maxVal;\n}\n\n// src/fft.ts\nconsole.debug(\"FFT module loaded\");\nvar FFT = class {\n  constructor(size) {\n    this.size = size | 0;\n    if (this.size <= 1 || (this.size & this.size - 1) !== 0)\n      throw new Error(\"FFT size must be a power of two and bigger than 1\");\n    this._csize = size << 1;\n    const table = new Array(this.size * 2);\n    for (let i = 0; i < table.length; i += 2) {\n      const angle = Math.PI * i / this.size;\n      table[i] = Math.cos(angle);\n      table[i + 1] = -Math.sin(angle);\n    }\n    this.table = table;\n    let power = 0;\n    for (let t = 1; this.size > t; t <<= 1)\n      power++;\n    this._width = power % 2 === 0 ? power - 1 : power;\n    this._bitrev = new Array(1 << this._width);\n    for (let j = 0; j < this._bitrev.length; j++) {\n      this._bitrev[j] = 0;\n      for (let shift = 0; shift < this._width; shift += 2) {\n        const revShift = this._width - shift - 2;\n        this._bitrev[j] |= (j >>> shift & 3) << revShift;\n      }\n    }\n    this._out = null;\n    this._data = null;\n    this._inv = 0;\n  }\n  fromComplexArray(complex, storage2) {\n    const res = storage2 || new Array(complex.length >>> 1);\n    for (let i = 0; i < complex.length; i += 2)\n      res[i >>> 1] = complex[i];\n    return res;\n  }\n  createComplexArray() {\n    const res = new Array(this._csize);\n    for (let i = 0; i < res.length; i++)\n      res[i] = 0;\n    return res;\n  }\n  toComplexArray(input, storage2) {\n    const res = storage2 || this.createComplexArray();\n    for (let i = 0; i < res.length; i += 2) {\n      res[i] = input[i >>> 1];\n      res[i + 1] = 0;\n    }\n    return res;\n  }\n  completeSpectrum(spectrum) {\n    const size = this._csize;\n    const half = size >>> 1;\n    for (let i = 2; i < half; i += 2) {\n      spectrum[size - i] = spectrum[i];\n      spectrum[size - i + 1] = -spectrum[i + 1];\n    }\n  }\n  transform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 0;\n    this._transform4();\n    this._out = null;\n    this._data = null;\n  }\n  realTransform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 0;\n    this._realTransform4();\n    this._out = null;\n    this._data = null;\n  }\n  inverseTransform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 1;\n    this._transform4();\n    for (let i = 0; i < out.length; i++)\n      out[i] /= this.size;\n    this._out = null;\n    this._data = null;\n  }\n  // radix-4 implementation\n  //\n  // NOTE: Uses of `var` are intentional for older V8 version that do not\n  // support both `let compound assignments` and `const phi`\n  _transform4() {\n    const out = this._out;\n    const size = this._csize;\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    let outOff;\n    let t;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform2(outOff, off, step);\n      }\n    } else {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform4(outOff, off, step);\n      }\n    }\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      const quarterLen = len >>> 2;\n      for (outOff = 0; outOff < size; outOff += len) {\n        const limit = outOff + quarterLen;\n        for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n          const A = i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n          const MAr = Ar;\n          const MAi = Ai;\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n          const FCr = T0r - T2r;\n          const FCi = T0i - T2i;\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n          const FDr = T1r - T3i;\n          const FDi = T1i + T3r;\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          out[D] = FDr;\n          out[D + 1] = FDi;\n        }\n      }\n    }\n  }\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  _singleTransform2(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const evenR = data[off];\n    const evenI = data[off + 1];\n    const oddR = data[off + step];\n    const oddI = data[off + step + 1];\n    const leftR = evenR + oddR;\n    const leftI = evenI + oddI;\n    const rightR = evenR - oddR;\n    const rightI = evenI - oddI;\n    out[outOff] = leftR;\n    out[outOff + 1] = leftI;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = rightI;\n  }\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  _singleTransform4(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n    const Ar = data[off];\n    const Ai = data[off + 1];\n    const Br = data[off + step];\n    const Bi = data[off + step + 1];\n    const Cr = data[off + step2];\n    const Ci = data[off + step2 + 1];\n    const Dr = data[off + step3];\n    const Di = data[off + step3 + 1];\n    const T0r = Ar + Cr;\n    const T0i = Ai + Ci;\n    const T1r = Ar - Cr;\n    const T1i = Ai - Ci;\n    const T2r = Br + Dr;\n    const T2i = Bi + Di;\n    const T3r = inv * (Br - Dr);\n    const T3i = inv * (Bi - Di);\n    const FAr = T0r + T2r;\n    const FAi = T0i + T2i;\n    const FBr = T1r + T3i;\n    const FBi = T1i - T3r;\n    const FCr = T0r - T2r;\n    const FCi = T0i - T2i;\n    const FDr = T1r - T3i;\n    const FDi = T1i + T3r;\n    out[outOff] = FAr;\n    out[outOff + 1] = FAi;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = FCi;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n  // Real input radix-4 implementation\n  _realTransform4() {\n    const out = this._out;\n    const size = this._csize;\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    let outOff;\n    let t;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n      }\n    } else {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n      }\n    }\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      const halfLen = len >>> 1;\n      const quarterLen = halfLen >>> 1;\n      const hquarterLen = quarterLen >>> 1;\n      for (outOff = 0; outOff < size; outOff += len) {\n        for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n          const A = outOff + i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n          const MAr = Ar;\n          const MAi = Ai;\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          if (i === 0) {\n            const FCr = T0r - T2r;\n            const FCi = T0i - T2i;\n            out[C] = FCr;\n            out[C + 1] = FCi;\n            continue;\n          }\n          if (i === hquarterLen)\n            continue;\n          const ST0r = T1r;\n          const ST0i = -T1i;\n          const ST1r = T0r;\n          const ST1i = -T0i;\n          const ST2r = -inv * T3i;\n          const ST2i = -inv * T3r;\n          const ST3r = -inv * T2i;\n          const ST3i = -inv * T2r;\n          const SFAr = ST0r + ST2r;\n          const SFAi = ST0i + ST2i;\n          const SFBr = ST1r + ST3i;\n          const SFBi = ST1i - ST3r;\n          const SA = outOff + quarterLen - i;\n          const SB = outOff + halfLen - i;\n          out[SA] = SFAr;\n          out[SA + 1] = SFAi;\n          out[SB] = SFBr;\n          out[SB + 1] = SFBi;\n        }\n      }\n    }\n  }\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  _singleRealTransform2(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const evenR = data[off];\n    const oddR = data[off + step];\n    const leftR = evenR + oddR;\n    const rightR = evenR - oddR;\n    out[outOff] = leftR;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = 0;\n  }\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  _singleRealTransform4(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n    const Ar = data[off];\n    const Br = data[off + step];\n    const Cr = data[off + step2];\n    const Dr = data[off + step3];\n    const T0r = Ar + Cr;\n    const T1r = Ar - Cr;\n    const T2r = Br + Dr;\n    const T3r = inv * (Br - Dr);\n    const FAr = T0r + T2r;\n    const FBr = T1r;\n    const FBi = -T3r;\n    const FCr = T0r - T2r;\n    const FDr = T1r;\n    const FDi = T3r;\n    out[outOff] = FAr;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = 0;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n};\n\n// src/fractional_octave_smoothing.ts\nconsole.debug(\"Fractional Octave Smoothing module loaded\");\nfunction getFractionalOctaveFrequencies(fraction, f_low = 20, f_high = 24e3, fftSize) {\n  if (fraction <= 0) {\n    throw new Error(\"Fraction must be greater than 0\");\n  }\n  if (f_low <= 0 || f_high <= 0) {\n    throw new Error(\"Frequencies must be greater than 0\");\n  }\n  if (f_low >= f_high) {\n    throw new Error(\"f_low must be less than f_high\");\n  }\n  const num_points = Math.round((Math.log10(f_high) - Math.log10(f_low)) / fraction) + 1;\n  let frequencies = logspace(f_low, f_high, num_points);\n  const frequency_resolution = 48e3 / fftSize;\n  for (let i = 0; i < frequencies.length; i++) {\n    frequencies[i] = Math.round(frequencies[i] / frequency_resolution) * frequency_resolution;\n  }\n  frequencies = Float32Array.from(new Set(frequencies));\n  return frequencies;\n}\nfunction fractionalOctaveSmoothing(frequencyData, fraction, frequencies) {\n  const frequenciesAll = linspace(0, 48e3 / 2, frequencyData.length);\n  const frequency_resolution = 48e3 / frequencyData.length;\n  const smoothedData = new Float32Array(frequencies.length);\n  const n = frequencyData.length;\n  const factor = Math.pow(2, 0.5 * fraction) - Math.pow(0.5, 0.5 * fraction);\n  for (let p = 0; p < frequencies.length; p++) {\n    const i = closest(frequencies[p], frequenciesAll);\n    let sum2 = 0;\n    const width = Math.round(0.5 * factor * (n * 0.5 - Math.abs(n * 0.5 - i)));\n    if (width === 0) {\n      sum2 = frequencyData[i];\n    } else {\n      const as = frequencyData.slice(Math.round(i - width + 1), Math.min(Math.round(i + width), n - 1));\n      sum2 = average(as);\n    }\n    smoothedData[p] = sum2;\n  }\n  return smoothedData;\n}\n\n// src/audio.ts\nconsole.debug(\"Audio module loaded\");\nwindow.FFT = FFT;\nfunction sum(buffer) {\n  let sum2 = 0;\n  for (let i = 0; i < buffer.length; i++) {\n    sum2 += buffer[i] * buffer[i];\n  }\n  return sum2;\n}\nfunction rms(buffer) {\n  return Math.sqrt(sum(buffer) / buffer.length);\n}\nfunction db(value) {\n  if (value instanceof Float32Array) {\n    return value.map((v) => 20 * Math.log10(v + 1e-50));\n  } else {\n    return 20 * Math.log10(value + 1e-50);\n  }\n}\nfunction dbToLinear(db2) {\n  return Math.pow(10, db2 / 20);\n}\nasync function loadAudioFile(file) {\n  const headerBuffer = await file.slice(0, 256 * 1024).arrayBuffer();\n  function getExt(name) {\n    return (name.split(\".\").pop() || \"\").toLowerCase();\n  }\n  function parseWav(buf) {\n    const dv = new DataView(buf);\n    function readStr(off, len) {\n      let s = \"\";\n      for (let i = 0; i < len; i++) s += String.fromCharCode(dv.getUint8(off + i));\n      return s;\n    }\n    if (readStr(0, 4) !== \"RIFF\" || readStr(8, 4) !== \"WAVE\") return null;\n    let offset = 12;\n    const info = {};\n    while (offset + 8 <= dv.byteLength) {\n      const id = readStr(offset, 4);\n      const size = dv.getUint32(offset + 4, true);\n      if (id === \"fmt \") {\n        info.audioFormat = dv.getUint16(offset + 8, true);\n        info.numChannels = dv.getUint16(offset + 10, true);\n        info.sampleRate = dv.getUint32(offset + 12, true);\n        info.byteRate = dv.getUint32(offset + 16, true);\n        info.blockAlign = dv.getUint16(offset + 20, true);\n        info.bitsPerSample = dv.getUint16(offset + 22, true);\n      } else if (id === \"data\") {\n        info.dataChunkSize = size;\n      }\n      offset += 8 + size + size % 2;\n    }\n    if (info.sampleRate && info.byteRate && info.dataChunkSize) {\n      info.duration = info.dataChunkSize / info.byteRate;\n    }\n    return info;\n  }\n  function parseMp3(buf) {\n    const bytes = new Uint8Array(buf);\n    let offset = 0;\n    if (bytes[0] === 73 && bytes[1] === 68 && bytes[2] === 51) {\n      const size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n      offset = 10 + size;\n    }\n    let headerIndex = -1;\n    for (let i = offset; i < bytes.length - 4; i++) {\n      if (bytes[i] === 255 && (bytes[i + 1] & 224) === 224) {\n        headerIndex = i;\n        break;\n      }\n    }\n    if (headerIndex < 0) return null;\n    const b1 = bytes[headerIndex + 1];\n    const b2 = bytes[headerIndex + 2];\n    const b3 = bytes[headerIndex + 3];\n    const versionBits = b1 >> 3 & 3;\n    const layerBits = b1 >> 1 & 3;\n    const bitrateBits = b2 >> 4 & 15;\n    const sampleRateBits = b2 >> 2 & 3;\n    const channelMode = b3 >> 6 & 3;\n    const versions = {\n      0: \"MPEG Version 2.5\",\n      1: \"reserved\",\n      2: \"MPEG Version 2 (ISO/IEC 13818-3)\",\n      3: \"MPEG Version 1 (ISO/IEC 11172-3)\"\n    };\n    const layers = {\n      0: \"reserved\",\n      1: \"Layer III\",\n      2: \"Layer II\",\n      3: \"Layer I\"\n    };\n    const sampleRates = {\n      3: [44100, 48e3, 32e3],\n      2: [22050, 24e3, 16e3],\n      0: [11025, 12e3, 8e3]\n    };\n    const versionKey = versionBits;\n    const layerKey = layerBits;\n    const bitrateTable = {\n      // MPEG1 Layer III\n      \"3_1\": [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 0],\n      // MPEG2/2.5 Layer III\n      \"0_1\": [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0],\n      \"2_1\": [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0],\n      // fallback generic table for other layers/versions (best-effort)\n      \"3_2\": [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 0],\n      \"3_3\": [0, 32, 64, 96, 128, 160, 192, 224, 256, 320, 384, 448, 512, 576, 640, 0]\n    };\n    const versionStr = versions[versionKey] || \"unknown\";\n    const layerStr = layers[layerKey] || \"unknown\";\n    let sampleRate = sampleRates[versionKey]?.[sampleRateBits] || null;\n    let bitrateKbps = 0;\n    const tbKey = `${versionKey}_${layerKey}`;\n    if (bitrateTable[tbKey]) {\n      bitrateKbps = bitrateTable[tbKey][bitrateBits] || 0;\n    } else if (bitrateTable[\"3_1\"] && versionKey === 3 && layerKey === 1) {\n      bitrateKbps = bitrateTable[\"3_1\"][bitrateBits] || 0;\n    }\n    const channels = channelMode === 3 ? 1 : 2;\n    let duration = null;\n    if (bitrateKbps > 0) {\n      duration = bytes.length * 8 / (bitrateKbps * 1e3);\n    }\n    return {\n      version: versionStr,\n      layer: layerStr,\n      bitrateKbps: bitrateKbps || null,\n      sampleRate,\n      channels,\n      duration\n    };\n  }\n  const ext = getExt(file.name);\n  const mime = file.type || \"unknown\";\n  let metadata = {};\n  const wavInfo = parseWav(headerBuffer);\n  if (wavInfo) {\n    metadata.format = \"wav\";\n    metadata = Object.assign(metadata, wavInfo || {});\n  } else if (mime === \"audio/mpeg\" || ext === \"mp3\") {\n    const mp3Info = parseMp3(headerBuffer);\n    metadata.format = \"mp3\";\n    metadata = Object.assign(metadata, mp3Info || {});\n  } else {\n    metadata.format = mime || ext || \"unknown\";\n  }\n  console.log(\"Extracted file metadata:\", metadata);\n  const arrayBuffer = await file.arrayBuffer();\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n  return Audio.fromAudioBuffer(audioBuffer, metadata);\n}\nvar Audio = class _Audio extends AudioBuffer {\n  static fromAudioBuffer(buffer, metadata) {\n    const audio2 = new _Audio({\n      length: buffer.length,\n      numberOfChannels: buffer.numberOfChannels,\n      sampleRate: buffer.sampleRate\n    });\n    for (let ch = 0; ch < buffer.numberOfChannels; ch++) {\n      audio2.copyToChannel(buffer.getChannelData(ch), ch);\n    }\n    audio2.metadata = metadata;\n    return audio2;\n  }\n  static fromSamples(samples, sampleRate = 48e3, metadata) {\n    if (!samples || samples.length == 0) return new _Audio({ length: 0, numberOfChannels: 1, sampleRate });\n    const audio2 = new _Audio({\n      length: samples.length,\n      numberOfChannels: 1,\n      sampleRate\n    });\n    audio2.copyToChannel(samples, 0);\n    audio2.metadata = metadata;\n    return audio2;\n  }\n  applyGain(gain) {\n    const numChannels = this.numberOfChannels;\n    for (let ch = 0; ch < numChannels; ch++) {\n      const data = this.getChannelData(ch).map((v) => v * gain);\n      this.copyToChannel(data, ch, 0);\n    }\n    return this;\n  }\n  getChannel(channel) {\n    if (channel < 0 || channel >= this.numberOfChannels) {\n      throw new Error(\"Invalid channel number\");\n    }\n    const channelData = this.getChannelData(channel);\n    const newBuffer = new AudioBuffer({\n      length: channelData.length,\n      numberOfChannels: 1,\n      sampleRate: this.sampleRate\n    });\n    newBuffer.copyToChannel(channelData, 0, 0);\n    return new _Audio(newBuffer);\n  }\n  rms(channel = 0) {\n    if (channel < 0 || channel >= this.numberOfChannels) {\n      throw new Error(\"Invalid channel number\");\n    }\n    const data = this.getChannelData(channel);\n    return rms(data);\n  }\n};\nfunction chirp(f_start, f_stop, duration = null, rate = null, fade = 0.01, fs = 48e3) {\n  const c = Math.log(f_stop / f_start);\n  let L;\n  let samples_count;\n  if (duration == null && rate == null) {\n    rate = 1;\n  }\n  if (duration == null) {\n    L = rate / Math.log(10);\n    samples_count = Math.round(L * c * fs);\n    duration = samples_count / fs;\n  } else {\n    L = duration / c;\n    rate = Math.log(10) * L;\n    samples_count = Math.round(L * c * fs);\n  }\n  samples_count = Math.max(1, samples_count);\n  const fade_in = Math.max(0, Math.floor(fade * fs));\n  const fade_out = Math.max(0, Math.floor(fade / 10 * fs));\n  const pre = Math.max(0, fade_in);\n  const post = Math.max(0, fade_out);\n  const phi = Float32Array.from({ length: pre + samples_count + post }, () => 0);\n  const offset = f_start * ((fade_in + 1) / fs);\n  for (let i = 0; i < pre; i++) phi[i] = f_start * (i / fs);\n  const baseIdx = pre;\n  for (let i = 0; i < samples_count; i++) {\n    let t2 = i / fs;\n    phi[baseIdx + i] = L * f_start * (Math.exp(t2 / L) - 1) + offset;\n  }\n  const last = phi[baseIdx + samples_count - 1] || 0;\n  for (let i = 0; i < post; i++) {\n    phi[baseIdx + samples_count + i] = last + f_stop * ((i + 1) / fs);\n  }\n  const sweep = Float32Array.from({ length: phi.length }, () => 0);\n  for (let i = 0; i < phi.length; i++) sweep[i] = Math.sin(2 * Math.PI * phi[i]);\n  const t = Float32Array.from({ length: sweep.length }, () => 0);\n  for (let i = 0; i < sweep.length; i++) t[i] = i / fs;\n  const envMain = Float32Array.from({ length: t.length }, () => 0);\n  const factor = f_stop * duration * duration;\n  for (let i = 0; i < t.length; i++) envMain[i] = Math.exp(-t[i] / L) / L * factor;\n  const startZeros = Math.floor(0.01 * fs);\n  const endZeros = Math.floor(1e-3 * fs);\n  const envelope = Float32Array.from({ length: startZeros + envMain.length + endZeros }, () => 0);\n  for (let i = 0; i < envMain.length; i++) {\n    envelope[startZeros + i] = envMain[i];\n  }\n  const window2 = Float32Array.from({ length: sweep.length }, () => 0);\n  for (let i = 0; i < sweep.length; i++) {\n    let w = 1;\n    if (fade_in > 0 && i < fade_in) {\n      w = i / Math.max(1, fade_in);\n    }\n    if (fade_out > 0 && i >= sweep.length - fade_out) {\n      const k = i - (sweep.length - fade_out);\n      w *= 1 - k / Math.max(1, fade_out);\n    }\n    window2[i] = w;\n  }\n  const sweepWindowed = Float32Array.from({ length: sweep.length }, () => 0);\n  for (let i = 0; i < sweep.length; i++) sweepWindowed[i] = sweep[i] * window2[i];\n  return [sweepWindowed, t, envelope];\n}\nfunction smoothFFT(fftData, fraction, resolution) {\n  const { frequency, magnitude, phase, fftSize } = fftData;\n  const smoothedMagnitude = Float32Array.from({ length: magnitude.length }, () => 0);\n  const fractionalFrequencies = getFractionalOctaveFrequencies(resolution, 20, 24e3, fftSize);\n  const smoothed = fractionalOctaveSmoothing(db(magnitude), fraction, fractionalFrequencies);\n  const smoothedPhase = fractionalOctaveSmoothing(phase, fraction, fractionalFrequencies);\n  return {\n    frequency: fractionalFrequencies,\n    magnitude: smoothed,\n    phase: smoothedPhase,\n    fftSize\n  };\n}\nfunction computeFFT(data, fftSize = null) {\n  fftSize ?? (fftSize = 2 ** Math.ceil(Math.log2(data.length)));\n  console.log(`Computing FFT with ${fftSize} bins for data length ${data.length}`);\n  const fft = new FFT(fftSize);\n  const out = fft.createComplexArray();\n  const frame = Float32Array.from({ length: fftSize }, () => 0);\n  for (let i = 0; i < fftSize; i++) {\n    frame[i] = (data[i] || 0) * 1;\n  }\n  fft.realTransform(out, frame);\n  const frequency = Float32Array.from({ length: fftSize / 2 }, () => 0);\n  const magnitude = Float32Array.from({ length: fftSize / 2 }, () => 0);\n  const phase = Float32Array.from({ length: fftSize / 2 }, () => 0);\n  for (let i = 0; i < fftSize / 2; i++) {\n    const re = out[2 * i];\n    const im = out[2 * i + 1];\n    magnitude[i] = abs(re, im) * Math.SQRT2;\n    phase[i] = Math.atan2(im, re);\n  }\n  const frequencyResolution = 48e3 / fftSize;\n  for (let i = 0; i < fftSize / 2; i++) {\n    frequency[i] = i * frequencyResolution;\n  }\n  return {\n    frequency,\n    magnitude,\n    phase,\n    fftSize\n  };\n}\nfunction fftCorrelation(x, y) {\n  const lenX = x.length;\n  const lenY = y.length;\n  const fullLen = lenX + lenY - 1;\n  const nextPow22 = (v) => {\n    let p = 1;\n    while (p < v) p <<= 1;\n    return p;\n  };\n  const n = nextPow22(fullLen);\n  const xP = Float32Array.from({ length: n }, () => 0);\n  const yP = Float32Array.from({ length: n }, () => 0);\n  xP.set(x, 0);\n  yP.set(y, 0);\n  const fft = new FFT(n);\n  const A = fft.createComplexArray();\n  const B = fft.createComplexArray();\n  fft.realTransform(A, xP);\n  fft.realTransform(B, yP);\n  if (typeof fft.completeSpectrum === \"function\") {\n    fft.completeSpectrum(A);\n    fft.completeSpectrum(B);\n  }\n  const C = fft.createComplexArray();\n  for (let k = 0; k < n; k++) {\n    const ar = A[2 * k], ai = A[2 * k + 1];\n    const br = B[2 * k], bi = B[2 * k + 1];\n    C[2 * k] = ar * br + ai * bi;\n    C[2 * k + 1] = ai * br - ar * bi;\n  }\n  const out = fft.createComplexArray();\n  fft.inverseTransform(out, C);\n  const corr = Float64Array.from({ length: fullLen }, () => 0);\n  for (let i = 0; i < fullLen; i++) {\n    corr[i] = out[2 * i] / n;\n  }\n  let sumX2 = 0, sumY2 = 0;\n  for (let i = 0; i < lenX; i++) sumX2 += x[i] * x[i];\n  for (let i = 0; i < lenY; i++) sumY2 += y[i] * y[i];\n  const denom = Math.sqrt(sumX2 * sumY2);\n  const normalized = Float64Array.from({ length: fullLen }, () => 0);\n  if (denom > 0) {\n    for (let i = 0; i < fullLen; i++) normalized[i] = corr[i] / denom;\n  } else {\n    for (let i = 0; i < fullLen; i++) normalized[i] = 0;\n  }\n  const lags = new Int32Array(fullLen);\n  for (let i = 0; i < fullLen; i++) lags[i] = i - (lenY - 1);\n  let peakIdx = 0;\n  let peakVal = -Infinity;\n  for (let i = 0; i < fullLen; i++) {\n    if (normalized[i] > peakVal) {\n      peakVal = normalized[i];\n      peakIdx = i;\n    }\n  }\n  const estimatedLag = lags[peakIdx];\n  return {\n    corr: normalized,\n    lags,\n    estimatedLagSamples: estimatedLag,\n    estimatedLagIndex: peakIdx,\n    peakCorrelation: peakVal,\n    raw: corr,\n    nfft: n\n  };\n}\nfunction fftConvolve(x, y, mode = \"same\") {\n  const lenX = x.length;\n  const lenY = y.length;\n  const fullLen = lenX + lenY - 1;\n  const n = nextPow2(fullLen);\n  const xP = Float32Array.from({ length: n }, () => 0);\n  const yP = Float32Array.from({ length: n }, () => 0);\n  xP.set(x, 0);\n  yP.set(y, 0);\n  const fft = new FFT(n);\n  const A = fft.createComplexArray();\n  const B = fft.createComplexArray();\n  fft.realTransform(A, xP);\n  fft.realTransform(B, yP);\n  if (typeof fft.completeSpectrum === \"function\") {\n    fft.completeSpectrum(A);\n    fft.completeSpectrum(B);\n  }\n  const C = fft.createComplexArray();\n  for (let k = 0; k < n; k++) {\n    const ar = A[2 * k], ai = A[2 * k + 1];\n    const br = B[2 * k], bi = B[2 * k + 1];\n    C[2 * k] = ar * br - ai * bi;\n    C[2 * k + 1] = ai * br + ar * bi;\n  }\n  const out = fft.createComplexArray();\n  fft.inverseTransform(out, C);\n  const result = Float32Array.from({ length: fullLen }, () => 0);\n  for (let i = 0; i < fullLen; i++) {\n    result[i] = out[2 * i];\n  }\n  if (mode === \"same\") {\n    const start = Math.floor((fullLen - lenX) / 2);\n    return result.slice(start, start + lenX);\n  }\n  return result;\n}\nfunction twoChannelImpulseResponse(y, x) {\n  const fullLen = y.length + x.length - 1;\n  const N = nextPow2(fullLen);\n  const xP = Float32Array.from({ length: N }, () => 0);\n  const yP = Float32Array.from({ length: N }, () => 0);\n  xP.set(y, 0);\n  yP.set(x, 0);\n  const fft = new FFT(N);\n  const A = fft.createComplexArray();\n  const B = fft.createComplexArray();\n  fft.realTransform(A, xP);\n  fft.realTransform(B, yP);\n  const C = fft.createComplexArray();\n  const epsilon = 1e-20;\n  for (let k = 0; k < N; k++) {\n    const ar = A[2 * k], ai = A[2 * k + 1];\n    const br = B[2 * k], bi = B[2 * k + 1];\n    const denom = br * br + bi * bi + epsilon;\n    C[2 * k] = (ar * br + ai * bi) / denom;\n    C[2 * k + 1] = (ai * br - ar * bi) / denom;\n  }\n  const out = Float32Array.from(fft.createComplexArray());\n  fft.inverseTransform(out, C);\n  const ir = Float32Array.from({ length: N }, () => 0);\n  for (let i = 0; i < N; i++) {\n    ir[i] = out[2 * ((i + N / 2) % N)];\n  }\n  const peakAt = closest(1e8, ir) + -N / 2;\n  const ir_complex = out.slice();\n  for (let i = 0; i < N; i++) {\n    ir_complex[2 * i] = out[2 * mod(i + peakAt, N)];\n    ir_complex[2 * i + 1] = out[2 * mod(i + peakAt, N) + 1];\n  }\n  const mean = average(ir);\n  for (let i = 0; i < N; i++) {\n    ir[i] = ir[i] - mean;\n  }\n  return {\n    ir,\n    ir_complex,\n    t: linspace((-N - 1) / 2 / 48e3, (N - 1) / 2 / 48e3, N),\n    // assuming 48kHz\n    peakAt,\n    sampleRate: 48e3,\n    fftSize: N\n  };\n}\nfunction twoChannelFFT(dataArray, reference, fftSize, offset) {\n  const dataPadded = Float32Array.from({ length: fftSize }, () => 0);\n  const referencePadded = Float32Array.from({ length: fftSize }, () => 0);\n  if (offset >= 0) {\n    const refLen = Math.min(reference.length, Math.max(0, fftSize - offset));\n    for (let i = 0; i < refLen; i++) {\n      referencePadded[offset + i] = reference[i];\n    }\n    const dataLen = Math.min(dataArray.length, fftSize);\n    for (let i = 0; i < dataLen; i++) {\n      dataPadded[i] = dataArray[i];\n    }\n  } else {\n    const refLen = Math.min(reference.length, fftSize);\n    for (let i = 0; i < refLen; i++) {\n      referencePadded[i] = reference[i];\n    }\n    const start = -offset;\n    const dataLen = Math.min(dataArray.length, Math.max(0, fftSize - start));\n    for (let i = 0; i < dataLen; i++) {\n      dataPadded[start + i] = dataArray[i];\n    }\n  }\n  const reference_ = computeFFT(referencePadded);\n  const signal_ = computeFFT(dataPadded);\n  const signalMags = signal_.magnitude.map((v) => 20 * Math.log10(v === 0 ? 1e-20 : v));\n  const referenceMags = reference_.magnitude.map((v) => 20 * Math.log10(v === 0 ? 1e-20 : v));\n  const h = referenceMags.map((v, i) => signalMags[i] - v);\n  const frequency = linspace(0, 48e3 / 2, h.length);\n  const i_50 = closest(50, frequency);\n  const phase_signal = signal_.phase;\n  const phase_reference = reference_.phase;\n  const sphase = unwrapPhase(phase_signal.map((v, i) => v - phase_reference[i]));\n  const correction = Math.floor(sphase[i_50] / (2 * Math.PI) + 0.5) * (2 * Math.PI);\n  const phase = sphase.map((v) => v - correction);\n  function unwrapPhase(phases) {\n    const N = phases.length;\n    const out = Float32Array.from({ length: N }, () => 0);\n    if (N === 0) return out;\n    out[0] = phases[0];\n    let offset2 = 0;\n    const theta = Math.PI;\n    for (let i = 1; i < N; i++) {\n      let delta = phases[i] - phases[i - 1];\n      if (delta > theta) {\n        offset2 -= 2 * Math.PI;\n      } else if (delta < -theta) {\n        offset2 += 2 * Math.PI;\n      }\n      out[i] = phases[i] + offset2;\n    }\n    return out;\n  }\n  return {\n    frequency,\n    magnitude: h,\n    phase,\n    fftSize\n  };\n}\nfunction computeFFTFromIR(ir, f_phase_wrap = 1e3) {\n  const fftSize = nextPow2(ir.ir.length);\n  console.log(`Computing FFT from IR with size ${fftSize}`);\n  const fft = new FFT(fftSize);\n  const out = Float32Array.from(fft.createComplexArray());\n  if (ir.ir_complex[1] === 0) {\n    console.log(\"IR is in real format, converting to complex\");\n    const frame = Float32Array.from({ length: fftSize }, () => 0);\n    for (let i = 0; i < fftSize; i++) {\n      frame[i] = ir.ir_complex[2 * i] || 0;\n    }\n    fft.realTransform(out, frame);\n  } else {\n    fft.transform(out, ir.ir_complex);\n  }\n  const magnitude = Float32Array.from({ length: fftSize / 2 }, () => 0);\n  const phase = Float32Array.from({ length: fftSize / 2 }, () => 0);\n  for (let i = 0; i < fftSize / 2; i++) {\n    const re = out[2 * i];\n    const im = out[2 * i + 1];\n    magnitude[i] = abs(re, im);\n    phase[i] = Math.atan2(im, re);\n  }\n  const frequency = linspace(0, 48e3 / 2, magnitude.length);\n  const i_norm = closest(f_phase_wrap, frequency);\n  const unwraped_phase = unwrapPhase(phase);\n  const correction = Math.floor(unwraped_phase[i_norm] / (2 * Math.PI) + 0.5) * (2 * Math.PI);\n  const corrected_unwraped_phase = unwraped_phase.map((v) => v - correction);\n  function unwrapPhase(phases) {\n    const N = phases.length;\n    const out2 = Float32Array.from({ length: N }, () => 0);\n    if (N === 0) return out2;\n    out2[0] = phases[0];\n    let offset = 0;\n    for (let i = 1; i < N; i++) {\n      let delta = phases[i] - phases[i - 1];\n      if (delta > Math.PI) {\n        offset -= 2 * Math.PI;\n      } else if (delta < -Math.PI) {\n        offset += 2 * Math.PI;\n      }\n      out2[i] = phases[i] + offset;\n    }\n    return out2;\n  }\n  return {\n    frequency,\n    magnitude,\n    phase: corrected_unwraped_phase.map((v) => v / Math.PI * 180),\n    peakAt: ir.peakAt,\n    sampleRate: ir.sampleRate,\n    fftSize\n  };\n}\nfunction groupDelays(fftData, normalizeAt = 1e3) {\n  const { frequency, phase, peakAt } = fftData;\n  const N = frequency.length;\n  const groupDelay = Float32Array.from({ length: N }, () => 0);\n  for (let i = 1; i < N - 1; i++) {\n    const dPhase = phase[i] - phase[i - 1];\n    const dFreq = frequency[i] - frequency[i - 1];\n    groupDelay[i] = -dPhase / dFreq / 360;\n  }\n  groupDelay[0] = groupDelay[1];\n  groupDelay[N - 1] = groupDelay[N - 2];\n  const normIdx = closest(normalizeAt, frequency);\n  const delayAtNorm = groupDelay[normIdx];\n  for (let i = 0; i < N; i++) {\n    groupDelay[i] = groupDelay[i] - delayAtNorm;\n  }\n  return groupDelay;\n}\nvar A_WEIGHTING_COEFFICIENTS = [\n  Float32Array.from([0.234301792299513, -0.468603584599026, -0.234301792299513, 0.937207169198054, -0.234301792299515, -0.468603584599025, 0.234301792299513]),\n  Float32Array.from([1, -4.113043408775871, 6.553121752655047, -4.990849294163381, 1.785737302937573, -0.246190595319487, 0.011224250033231])\n];\nvar K_WEIGHTING_COEFFICIENTS_PRE = [\n  Float32Array.from([1.53512485958697, -2.69169618940638, 1.19839281085285]),\n  Float32Array.from([1, -1.69065929318241, 0.73248077421585])\n];\nvar K_WEIGHTING_COEFFICIENTS_RLB = [\n  Float32Array.from([1, -2, 1]),\n  Float32Array.from([1, -1.99004745483398, 0.99007225036621])\n];\nfunction applyAWeightingToBuffer(buffer, zi) {\n  const b = A_WEIGHTING_COEFFICIENTS[0];\n  const a = A_WEIGHTING_COEFFICIENTS[1];\n  const output = Float32Array.from({ length: buffer.length }, () => 0);\n  for (let n = 0; n < buffer.length; n++) {\n    output[n] = b[0] * buffer[n] + zi[0];\n    for (let i = 1; i < b.length; i++) {\n      zi[i - 1] = b[i] * buffer[n] + zi[i] - a[i] * output[n];\n    }\n  }\n  return output;\n}\nfunction gateBuffer(buffer, sampleRate, thresholdDb = -70, blockMs = 400, overlap = 0.75) {\n  const blockSize = Math.floor(blockMs / 1e3 * sampleRate);\n  const hopSize = Math.floor(blockSize * (1 - overlap));\n  const threshold = dbToLinear(thresholdDb);\n  const gated = Float32Array.from({ length: buffer.length }, () => 0);\n  let i = 0;\n  while (i < buffer.length) {\n    const start = i;\n    const end = Math.min(i + blockSize, buffer.length);\n    const block = buffer.slice(start, end);\n    const blockRms = rms(block);\n    if (blockRms >= threshold) {\n      for (let j = 0; j < block.length; j++) {\n        gated[start + j] = block[j];\n      }\n    }\n    i += hopSize;\n  }\n  return gated;\n}\nvar audio = {\n  loadAudioFile,\n  chirp,\n  computeFFT,\n  smoothFFT,\n  fftCorrelation,\n  fftConvolve,\n  twoChannelImpulseResponse,\n  computeFFTFromIR,\n  twoChannelFFT,\n  groupDelays,\n  applyAWeightingToBuffer,\n  gateBuffer\n};\n\n// src/windows.ts\nfunction hanningWindow(length) {\n  const window2 = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    window2[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (length - 1)));\n  }\n  return window2;\n}\nfunction hammingWindow(length) {\n  const window2 = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    window2[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (length - 1));\n  }\n  return window2;\n}\nfunction blackmanWindow(length) {\n  const window2 = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    window2[i] = 0.42 - 0.5 * Math.cos(2 * Math.PI * i / (length - 1)) + 0.08 * Math.cos(4 * Math.PI * i / (length - 1));\n  }\n  return window2;\n}\nfunction rectangularWindow(length) {\n  const window2 = new Float32Array(length);\n  window2.fill(1);\n  return window2;\n}\nfunction getSelectedWindow(windowType, length) {\n  const type = windowType;\n  let window2 = new Float32Array(length);\n  let wcf = 1;\n  if (type === \"hanning\") {\n    window2 = hanningWindow(length);\n    wcf = 2;\n  }\n  if (type === \"hamming\") {\n    window2 = hammingWindow(length);\n    wcf = 1.852;\n  }\n  if (type === \"blackman\") {\n    window2 = blackmanWindow(length);\n    wcf = 2.381;\n  }\n  if (type === \"rectangular\") {\n    window2 = rectangularWindow(length);\n    wcf = 1;\n  }\n  window2 = window2.map((v) => v / wcf);\n  return window2;\n}\n\n// src/farina.ts\nvar Farina = class {\n  /* Farina deconvolution implementation according to the Python implementation. */\n  constructor(stimulus, f_start = 50, f_stop = 22800, fs = 48e3) {\n    this.deconvolved = Float32Array.from([]);\n    this.f_start = f_start;\n    this.f_stop = f_stop;\n    this.fs = fs;\n    this.stimulus = stimulus;\n    this.duration = this.stimulus.length / this.fs;\n  }\n  lag_of_harmonic(n) {\n    return this.ell() * Math.log(n);\n  }\n  margin_of_harmonic(n) {\n    return this.ell() * Math.log(n + 1) - this.ell() * Math.log(n);\n  }\n  max_safe_harmonic(window_size) {\n    const t = [];\n    for (let n = 1; n < 1e3; n++) {\n      if (this.margin_of_harmonic(n) > window_size) {\n        t.push(this.margin_of_harmonic(n));\n      }\n    }\n    return t.length < 999 ? t.length : 0;\n  }\n  ell() {\n    return this.duration / Math.log(this.f_stop / this.f_start);\n  }\n  rate(length) {\n    return 1 / this.f_start * Math.PI * Math.round(length * this.f_start / Math.log2(this.f_stop / this.f_start));\n  }\n  instant() {\n    return closest(1e8, this.deconvolved);\n  }\n  window(signal, at, length) {\n    const size = Math.floor(length * this.fs);\n    const window2 = getSelectedWindow(\"hanning\", size);\n    const sig = this.deconvolution(signal);\n    const si = sig.slice(at - size / 2, at + size / 2);\n    const w = Float32Array.from({ length: size }, () => 0);\n    return si;\n    if (si.length === window2.length) {\n      for (let i = 0; i < window2.length; i++) {\n        w[i] = window2[i] * si[i];\n      }\n      return w;\n    } else {\n      return Float32Array.from({ length: window2.length }, () => 0);\n    }\n  }\n  deconvolution(signal, customLength = 5.5) {\n    const n = linspace(0, this.stimulus.length - 1, this.stimulus.length);\n    const k = n.map((v) => Math.exp(v / this.ell() / this.fs));\n    const inv_stimulus = this.stimulus.slice().reverse().map((v, i) => v / k[i]);\n    const deconvolved = fftConvolve(signal, inv_stimulus, \"same\").slice().reverse();\n    const norm = max(fftConvolve(this.stimulus, inv_stimulus, \"same\").map((v) => Math.abs(v)));\n    this.deconvolved = deconvolved;\n    return deconvolved.map((v) => v / norm);\n  }\n};\nfunction FarinaImpulseResponse(y, x, customLength = 5.5) {\n  const farina = new Farina(x, 2, 2e4, 48e3);\n  const measurementResponse = farina.deconvolution(y, customLength);\n  console.log(farina.max_safe_harmonic(0.1));\n  const peakAt = farina.instant();\n  console.log(\"peakAt\", peakAt);\n  const s = farina.window(y, (measurementResponse.length - 1) / 2, 0.1);\n  const ir = Float32Array.from({ length: s.length }, () => 0);\n  for (let i = 0; i < s.length; i++) {\n    ir[i] = s[i];\n  }\n  const ir_complex = Float32Array.from({ length: s.length * 2 }, () => 0);\n  for (let i = 0; i < s.length; i++) {\n    ir_complex[2 * i] = s[i];\n    ir_complex[2 * i + 1] = 0;\n  }\n  return {\n    ir,\n    ir_complex,\n    t: linspace((-measurementResponse.length - 1) / 2 / 48e3, (measurementResponse.length - 1) / 2 / 48e3, measurementResponse.length),\n    peakAt,\n    sampleRate: 48e3,\n    fftSize: measurementResponse.length\n  };\n}\n\n// src/storage.ts\nfunction openIDB() {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.open(\"dunkadunka-storage\", 1);\n    req.onupgradeneeded = () => {\n      const db2 = req.result;\n      if (!db2.objectStoreNames.contains(\"kv\")) {\n        db2.createObjectStore(\"kv\", { keyPath: \"key\" });\n      }\n    };\n    req.onsuccess = () => resolve(req.result);\n    req.onerror = () => reject(req.error);\n  });\n}\nasync function setItem(key, value) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.put({ key, value });\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n    try {\n      setItem(key, value);\n    } catch {\n    }\n  } catch (e) {\n    console.error(\"setItem(idb) failed\", e);\n  }\n}\nasync function getItem(key) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readonly\");\n    const store = tx.objectStore(\"kv\");\n    const req = store.get(key);\n    const res = await new Promise((resolve, reject) => {\n      req.onsuccess = () => resolve(req.result);\n      req.onerror = () => reject(req.error);\n    });\n    return res?.value ?? null;\n  } catch (e) {\n    console.error(\"getItem(idb) failed\", e);\n    return null;\n  }\n}\nasync function removeItem(key) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.delete(key);\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n  } catch (e) {\n    console.error(\"removeItem(idb) failed\", e);\n  }\n}\nasync function clearStorage() {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.clear();\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n    try {\n      sessionStorage.clear();\n    } catch {\n    }\n  } catch (e) {\n    console.error(\"clearStorage(idb) failed\", e);\n  }\n}\nasync function dumpStorage() {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readonly\");\n    const store = tx.objectStore(\"kv\");\n    const req = store.openCursor();\n    req.onsuccess = (event) => {\n      const cursor = event.target.result;\n      if (cursor) {\n        console.log(`Key: ${cursor.key}, Value: ${cursor.value.value}`);\n        cursor.continue();\n      }\n    };\n    req.onerror = () => {\n      console.error(\"dumpStorage(idb) failed\", req.error);\n    };\n  } catch (e) {\n    console.error(\"dumpStorage(idb) failed\", e);\n  }\n}\nvar storage = {\n  setItem,\n  getItem,\n  removeItem,\n  clearStorage,\n  dumpStorage\n};\n\n// src/device-settings.ts\nvar INPUT_KEY = \"preferredAudioInputId\";\nvar OUTPUT_KEY = \"preferredAudioOutputId\";\nfunction openDeviceSettings() {\n  const modal = document.getElementById(\"deviceSettingsModal\");\n  if (modal) {\n    modal.style.display = \"flex\";\n    initDeviceSettings();\n  }\n}\nfunction closeDeviceSettings() {\n  const modal = document.getElementById(\"deviceSettingsModal\");\n  if (modal) {\n    modal.style.display = \"none\";\n  }\n}\nasync function ensureDeviceAccess() {\n  try {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;\n    await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n  } catch (_) {\n  }\n}\nasync function refreshAudioDeviceList() {\n  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n    console.warn(\"MediaDevices API not available\");\n    return;\n  }\n  await ensureDeviceAccess();\n  const devices = await navigator.mediaDevices.enumerateDevices();\n  const inputSel = document.getElementById(\"inputDeviceSelect\");\n  const outputSel = document.getElementById(\"outputDeviceSelect\");\n  if (!inputSel || !outputSel) return;\n  inputSel.innerHTML = '<option value=\"\">Default input</option>';\n  outputSel.innerHTML = '<option value=\"\">Default output</option>';\n  const inputId = localStorage.getItem(INPUT_KEY) || \"\";\n  const outputId = localStorage.getItem(OUTPUT_KEY) || \"\";\n  devices.forEach((d) => {\n    if (d.kind === \"audioinput\") {\n      const opt = document.createElement(\"option\");\n      opt.value = d.deviceId;\n      opt.textContent = d.label || `Microphone (${d.deviceId.slice(0, 8)}\\u2026)`;\n      if (d.deviceId === inputId) opt.selected = true;\n      inputSel.appendChild(opt);\n    } else if (d.kind === \"audiooutput\") {\n      const opt = document.createElement(\"option\");\n      opt.value = d.deviceId;\n      opt.textContent = d.label || `Speaker (${d.deviceId.slice(0, 8)}\\u2026)`;\n      if (d.deviceId === outputId) opt.selected = true;\n      outputSel.appendChild(opt);\n    }\n  });\n  const note = document.getElementById(\"sinkSupportNote\");\n  if (note) {\n    const sinkSupported = typeof HTMLMediaElement !== \"undefined\" && \"setSinkId\" in HTMLMediaElement.prototype;\n    note.textContent = sinkSupported ? \"Output routing supported on this browser.\" : \"Output routing (setSinkId) not supported by this browser.\";\n  }\n}\nasync function applyOutputDevice(deviceId) {\n  const router = document.getElementById(\"appOutputRouter\");\n  if (!router) return;\n  if (\"setSinkId\" in HTMLMediaElement.prototype) {\n    try {\n      await router.setSinkId(deviceId || \"\");\n    } catch (e) {\n      console.warn(\"Failed to set sinkId:\", e);\n    }\n  }\n}\nfunction saveDeviceSelections() {\n  const inputSel = document.getElementById(\"inputDeviceSelect\");\n  const outputSel = document.getElementById(\"outputDeviceSelect\");\n  if (!inputSel || !outputSel) return;\n  localStorage.setItem(INPUT_KEY, inputSel.value || \"\");\n  localStorage.setItem(OUTPUT_KEY, outputSel.value || \"\");\n  applyOutputDevice(outputSel.value || \"\");\n  closeDeviceSettings();\n}\nasync function initDeviceSettings() {\n  await refreshAudioDeviceList();\n  const inputSel = document.getElementById(\"inputDeviceSelect\");\n  const outputSel = document.getElementById(\"outputDeviceSelect\");\n  if (!inputSel || !outputSel) return;\n  inputSel.onchange = () => {\n    localStorage.setItem(INPUT_KEY, inputSel.value || \"\");\n  };\n  outputSel.onchange = () => {\n    localStorage.setItem(OUTPUT_KEY, outputSel.value || \"\");\n    applyOutputDevice(outputSel.value || \"\");\n  };\n}\nif (navigator.mediaDevices && \"ondevicechange\" in navigator.mediaDevices) {\n  navigator.mediaDevices.addEventListener(\"devicechange\", () => {\n    const modal = document.getElementById(\"deviceSettingsModal\");\n    if (modal && modal.style.display === \"flex\") {\n      refreshAudioDeviceList();\n    }\n  });\n}\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const outId = localStorage.getItem(OUTPUT_KEY);\n  if (outId) applyOutputDevice(outId);\n});\nwindow.openDeviceSettings = openDeviceSettings;\nwindow.closeDeviceSettings = closeDeviceSettings;\nwindow.refreshAudioDeviceList = refreshAudioDeviceList;\nwindow.saveDeviceSelections = saveDeviceSelections;\n\n// src/app.ts\nconsole.debug(\"App module loaded\");\nvar root = document.documentElement;\nvar uiColor = \"#0366d6\";\nroot.style.setProperty(\"--color\", uiColor);\nvar tabCounter = 0;\nvar tabsContainer = document.getElementById(\"tabs-outer\");\nvar tabsInnerContainer = document.getElementById(\"tabs\");\nvar tabContents = document.getElementById(\"tab-contents\");\nvar responseFileInput = document.getElementById(\"responseFile\");\nvar referenceFileInput = document.getElementById(\"referenceFile\");\nvar analyzeBtn = document.getElementById(\"analyzeBtn\");\nresponseFileInput.addEventListener(\"change\", () => {\n  analyzeBtn.disabled = !responseFileInput.files?.length;\n});\nvar acquisitionState = {\n  audioContext: null,\n  mediaRecorder: null,\n  recordedChunks: [],\n  oscillatorNode: null,\n  playbackSource: null,\n  isRecording: false\n};\nvar startBtn = document.getElementById(\"startBtn\");\nvar stopBtn = document.getElementById(\"stopBtn\");\nvar playBtn = document.getElementById(\"playBtn\");\nvar stopPlayBtn = document.getElementById(\"stopPlayBtn\");\nvar sweepStartFreqInput = document.getElementById(\"sweepStartFreq\");\nvar sweepEndFreqInput = document.getElementById(\"sweepEndFreq\");\nvar sweepDurationInput = document.getElementById(\"sweepDuration\");\nvar recordingStatusEl = document.getElementById(\"recordingStatus\");\nvar recordingMeterEl = document.getElementById(\"recordingMeter\");\nvar recordingVisualizationEl = document.getElementById(\"recordingVisualization\");\nvar recordedAudioContainer = document.getElementById(\"recordedAudioContainer\");\nvar recordedAudioEl = document.getElementById(\"recordedAudio\");\nvar analyzeRecordingBtn = document.getElementById(\"analyzeRecordingBtn\");\nvar viewWaveformBtn = document.getElementById(\"viewWaveformBtn\");\nvar channelSelectionContainer = document.getElementById(\"channelSelectionContainer\");\nvar channelSelect = document.getElementById(\"channelSelect\");\nasync function initializeAudioContext() {\n  if (!acquisitionState.audioContext) {\n    acquisitionState.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  }\n  if (acquisitionState.audioContext.state === \"suspended\") {\n    await acquisitionState.audioContext.resume();\n  }\n  return acquisitionState.audioContext;\n}\nasync function detectAndSetupChannels() {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }\n    });\n    const audioContext = await initializeAudioContext();\n    const analyser = audioContext.createAnalyser();\n    const source = audioContext.createMediaStreamSource(stream);\n    source.connect(analyser);\n    const channelCount = source.mediaStream.getAudioTracks()[0].getSettings()?.channelCount || 1;\n    stream.getTracks().forEach((track) => track.stop());\n    channelSelect.innerHTML = \"\";\n    for (let i = 0; i < channelCount; i++) {\n      const option = document.createElement(\"option\");\n      option.value = i.toString();\n      const channelNames = [\"Left\", \"Right\", \"Center\", \"LFE\", \"Back Left\", \"Back Right\"];\n      option.textContent = `Channel ${i + 1}${channelNames[i] ? ` (${channelNames[i]})` : \"\"}`;\n      channelSelect.appendChild(option);\n    }\n    if (channelCount > 1) {\n      channelSelectionContainer.style.display = \"flex\";\n    } else {\n      channelSelectionContainer.style.display = \"none\";\n    }\n  } catch (error) {\n    console.error(\"Error detecting channels:\", error);\n    channelSelectionContainer.style.display = \"none\";\n  }\n}\ntabsContainer.addEventListener(\"click\", (e) => {\n  const target = e.target;\n  if (target.classList.contains(\"tab\") && target.dataset.tab === \"acquisition\") {\n    detectAndSetupChannels();\n  }\n});\nasync function startRecordingAndPlayback() {\n  try {\n    const audioContext = await initializeAudioContext();\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: {\n        echoCancellation: false,\n        noiseSuppression: false,\n        autoGainControl: false\n      }\n    });\n    acquisitionState.recordedChunks = [];\n    acquisitionState.mediaRecorder = new MediaRecorder(stream);\n    acquisitionState.isRecording = true;\n    acquisitionState.mediaRecorder.ondataavailable = (e) => {\n      acquisitionState.recordedChunks.push(e.data);\n    };\n    acquisitionState.mediaRecorder.onstop = async () => {\n      const recordedBlob = new Blob(acquisitionState.recordedChunks, { type: \"audio/wav\" });\n      const url = URL.createObjectURL(recordedBlob);\n      recordedAudioEl.src = url;\n      recordedAudioContainer.style.display = \"block\";\n      recordingVisualizationEl.style.display = \"none\";\n    };\n    const startFreq = parseFloat(sweepStartFreqInput.value);\n    const endFreq = parseFloat(sweepEndFreqInput.value);\n    const duration = parseFloat(sweepDurationInput.value);\n    const preRecordTime = 0.5;\n    const postRecordTime = 1;\n    const totalRecordTime = preRecordTime + duration + postRecordTime;\n    const [sweepSignal, ,] = audio.chirp(startFreq, endFreq, duration);\n    const audioBuffer = audioContext.createBuffer(1, sweepSignal.length, audioContext.sampleRate);\n    const channelData = audioBuffer.getChannelData(0);\n    channelData.set(sweepSignal);\n    const sourceGain = audioContext.createGain();\n    sourceGain.gain.value = 0.5;\n    recordingStatusEl.textContent = `Recording for ${totalRecordTime.toFixed(1)}s...`;\n    recordingVisualizationEl.style.display = \"block\";\n    acquisitionState.mediaRecorder.start();\n    startBtn.disabled = true;\n    stopBtn.disabled = false;\n    playBtn.disabled = true;\n    sweepStartFreqInput.disabled = true;\n    sweepEndFreqInput.disabled = true;\n    sweepDurationInput.disabled = true;\n    setTimeout(() => {\n      acquisitionState.playbackSource = audioContext.createBufferSource();\n      acquisitionState.playbackSource.buffer = audioBuffer;\n      acquisitionState.playbackSource.connect(sourceGain);\n      sourceGain.connect(audioContext.destination);\n      acquisitionState.playbackSource.start();\n    }, preRecordTime * 1e3);\n    setTimeout(() => {\n      stopRecording();\n    }, totalRecordTime * 1e3);\n  } catch (error) {\n    console.error(\"Error starting recording:\", error);\n    recordingStatusEl.textContent = `Error: ${error.message}`;\n    recordingStatusEl.style.color = \"#d73a49\";\n  }\n}\nasync function playbackOnly() {\n  try {\n    const audioContext = await initializeAudioContext();\n    const startFreq = parseFloat(sweepStartFreqInput.value);\n    const endFreq = parseFloat(sweepEndFreqInput.value);\n    const duration = parseFloat(sweepDurationInput.value);\n    const [sweepSignal] = audio.chirp(startFreq, endFreq, duration);\n    const audioBuffer = audioContext.createBuffer(1, sweepSignal.length, audioContext.sampleRate);\n    const channelData = audioBuffer.getChannelData(0);\n    channelData.set(sweepSignal);\n    const sourceGain = audioContext.createGain();\n    sourceGain.gain.value = 0.5;\n    acquisitionState.playbackSource = audioContext.createBufferSource();\n    acquisitionState.playbackSource.buffer = audioBuffer;\n    acquisitionState.playbackSource.connect(sourceGain);\n    sourceGain.connect(audioContext.destination);\n    acquisitionState.playbackSource.start();\n    recordingStatusEl.textContent = `Playing sweep...`;\n    recordingStatusEl.style.color = \"#0366d6\";\n    playBtn.disabled = true;\n    stopPlayBtn.disabled = false;\n    setTimeout(() => {\n      stopPlayback();\n    }, (duration + 0.5) * 1e3);\n  } catch (error) {\n    console.error(\"Error during playback:\", error);\n    recordingStatusEl.textContent = `Error: ${error.message}`;\n    recordingStatusEl.style.color = \"#d73a49\";\n  }\n}\nfunction stopRecording() {\n  if (acquisitionState.mediaRecorder && acquisitionState.isRecording) {\n    acquisitionState.mediaRecorder.stop();\n    acquisitionState.isRecording = false;\n    acquisitionState.mediaRecorder.stream.getTracks().forEach((track) => track.stop());\n    recordingStatusEl.textContent = \"Recording complete. Ready to analyze.\";\n    recordingStatusEl.style.color = \"#28a745\";\n  }\n  if (acquisitionState.playbackSource) {\n    acquisitionState.playbackSource.stop();\n  }\n  startBtn.disabled = false;\n  stopBtn.disabled = true;\n  playBtn.disabled = false;\n  sweepStartFreqInput.disabled = false;\n  sweepEndFreqInput.disabled = false;\n  sweepDurationInput.disabled = false;\n}\nfunction stopPlayback() {\n  if (acquisitionState.playbackSource) {\n    try {\n      acquisitionState.playbackSource.stop();\n    } catch (e) {\n    }\n  }\n  recordingStatusEl.textContent = \"Playback stopped.\";\n  playBtn.disabled = false;\n  stopPlayBtn.disabled = true;\n}\nstartBtn.addEventListener(\"click\", startRecordingAndPlayback);\nstopBtn.addEventListener(\"click\", stopRecording);\nplayBtn.addEventListener(\"click\", playbackOnly);\nstopPlayBtn.addEventListener(\"click\", stopPlayback);\nanalyzeRecordingBtn.addEventListener(\"click\", async () => {\n  if (!recordedAudioEl.src) return;\n  try {\n    const audioContext = await initializeAudioContext();\n    const response = await fetch(recordedAudioEl.src);\n    const arrayBuffer = await response.arrayBuffer();\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n    const selectedChannel = parseInt(channelSelect.value, 10);\n    let recordedAudio;\n    if (audioBuffer.numberOfChannels > 1 && selectedChannel < audioBuffer.numberOfChannels) {\n      const channelData = audioBuffer.getChannelData(selectedChannel);\n      recordedAudio = Audio.fromSamples(channelData, audioBuffer.sampleRate);\n    } else {\n      recordedAudio = Audio.fromAudioBuffer(audioBuffer);\n    }\n    const startFreq = parseFloat(sweepStartFreqInput.value);\n    const endFreq = parseFloat(sweepEndFreqInput.value);\n    const duration = parseFloat(sweepDurationInput.value);\n    const [sweepSignal] = audio.chirp(startFreq, endFreq, duration);\n    const referenceAudio = Audio.fromSamples(sweepSignal, audioContext.sampleRate);\n    const now = /* @__PURE__ */ new Date();\n    const dateTime = now.toLocaleString(\"sv-SE\", {\n      year: \"2-digit\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      hour12: false\n    }).replace(\",\", \"\");\n    const recordingName = `${dateTime}`;\n    createAnalysisTab(\n      recordedAudio.applyGain(1 / 16384),\n      referenceAudio.applyGain(1 / 16384),\n      recordingName,\n      `${startFreq}-${endFreq}Hz`\n    );\n  } catch (error) {\n    console.error(\"Error analyzing recording:\", error);\n    alert(\"Error analyzing recording: \" + error.message);\n  }\n});\nviewWaveformBtn.addEventListener(\"click\", async () => {\n  if (!recordedAudioEl.src) return;\n  try {\n    const audioContext = await initializeAudioContext();\n    const response = await fetch(recordedAudioEl.src);\n    const arrayBuffer = await response.arrayBuffer();\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n    const selectedChannel = parseInt(channelSelect.value, 10);\n    let recordedAudio;\n    if (audioBuffer.numberOfChannels > 1 && selectedChannel < audioBuffer.numberOfChannels) {\n      const channelData = audioBuffer.getChannelData(selectedChannel);\n      recordedAudio = Audio.fromSamples(channelData, audioBuffer.sampleRate);\n    } else {\n      recordedAudio = Audio.fromAudioBuffer(audioBuffer);\n    }\n    const now = /* @__PURE__ */ new Date();\n    const dateTime = now.toLocaleString(\"sv-SE\", {\n      year: \"2-digit\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      hour12: false\n    }).replace(\",\", \"\");\n    const recordingName = `${dateTime}`;\n    createAnalysisTab(\n      recordedAudio.applyGain(1 / 16384),\n      null,\n      recordingName,\n      \"Waveform View\"\n    );\n  } catch (error) {\n    console.error(\"Error viewing waveform:\", error);\n    alert(\"Error viewing waveform: \" + error.message);\n  }\n});\nwindow.addEventListener(\"beforeunload\", (e) => {\n  try {\n    saveState();\n  } catch (err) {\n    console.error(\"Failed to save state on beforeunload:\", err);\n  }\n});\ntabsContainer.addEventListener(\"click\", (e) => {\n  const target = e.target;\n  if (target.classList.contains(\"tab-close\")) {\n    const tab = target.parentElement;\n    const tabId = tab.dataset.tab;\n    if (tabId == \"upload\") return;\n    console.debug(\"Closing tab\", tabId);\n    tab.remove();\n    document.querySelector(`[data-content=\"${tabId}\"]`)?.remove();\n    storage.removeItem(`analysis-${tabId}`).catch((err) => console.error(\"Failed to remove analysis from storage:\", err));\n    if (tab.classList.contains(\"active\")) {\n      switchTab(\"upload\");\n    }\n    saveState();\n    e.stopPropagation();\n  } else if (target.classList.contains(\"tab\")) {\n    const tabId = target.dataset.tab;\n    if (tabId) {\n      switchTab(tabId);\n    }\n  }\n});\nfunction switchTab(tabId) {\n  document.querySelectorAll(\".tab\").forEach((t) => t.classList.remove(\"active\"));\n  document.querySelectorAll(\".tab-content\").forEach((c) => c.classList.remove(\"active\"));\n  document.querySelector(`[data-tab=\"${tabId}\"]`)?.classList.add(\"active\");\n  document.querySelector(`[data-content=\"${tabId}\"]`)?.classList.add(\"active\");\n}\nanalyzeBtn.addEventListener(\"click\", async () => {\n  const responseFile = responseFileInput.files?.[0];\n  const referenceFile = referenceFileInput.files?.[0];\n  if (!responseFile) return;\n  analyzeBtn.disabled = true;\n  analyzeBtn.textContent = \"Analyzing...\";\n  try {\n    const responseData = await audio.loadAudioFile(responseFile);\n    const referenceData = referenceFile ? await audio.loadAudioFile(referenceFile) : null;\n    createAnalysisTab(responseData.applyGain(1 / 16384), referenceData ? referenceData.applyGain(1 / 16384) : null, responseFile.name, referenceFile?.name || null);\n  } catch (error) {\n    alert(\"Error analyzing files: \" + error.message);\n  } finally {\n    analyzeBtn.disabled = false;\n    analyzeBtn.textContent = \"Analyze Frequency Response\";\n  }\n});\nfunction createAnalysisTab(responseData, referenceData, filename, referenceFilename) {\n  tabCounter++;\n  const tabId = `analysis-${tabCounter}`;\n  let shortName = filename.length > 20 ? filename.substring(0, 17) + \"...\" : filename;\n  if (referenceFilename != null) {\n    const shortReferenceName = referenceFilename?.length > 20 ? referenceFilename.substring(0, 17) + \"...\" : referenceFilename;\n    shortName += \" / \" + shortReferenceName;\n  }\n  const tab = document.createElement(\"button\");\n  tab.className = \"tab tab-closable\";\n  tab.dataset.tab = tabId;\n  tab.innerHTML = `<span class=\"tab-icon-analysis\"></span>${shortName} <span class=\"tab-close\">\\u2715</span>`;\n  tabsInnerContainer.appendChild(tab);\n  const content = document.createElement(\"div\");\n  content.className = \"tab-content\";\n  content.dataset.content = tabId;\n  content.innerHTML = `\n    <!-- nav class=\"tab-menu-bar\">\n                <div>\n                    <label for=\"smoothing-${tabId}\">Smoothing</label>\n                    <select id=\"smoothing-${tabId}\" class=\"smoothing-select\" aria-label=\"Smoothing factor\">\n                        <option value=\"0\">None</option>\n                        <option value=\"1/3\">1/3 octave</option>\n                        <option value=\"1/6\" selected>1/6 octave</option>\n                        <option value=\"1/12\">1/12 octave</option>\n                        <option value=\"1/24\">1/24 octave</option>\n                        <option value=\"1/48\">1/48 octave</option>\n                    </select>\n                </div>\n            </nav> <h5 class=\"text-xs italic text-gray-600\">Frequency Response Analysis of ${filename}${referenceFilename ? \" / \" + referenceFilename : \"\"}</h5 -->\n        <button class=\"sidecar-toggle\" id=\"sidebar-toggle-${tabId}\" title=\"Toggle Sidecar\">Open settings pane</button>\n        <div class=\"flex h-full\">\n            <div class=\"flex-none w-86 border-r border-[#ddd] p-2 relative sidecar\" style=\"transition:50ms linear;\">\n                <div class=\"section\">\n                    <div class=\"title\">Settings</div>\n                    <p><i>There are no settings for this analysis.</i></p>\n                </div>\n                <div class=\"section\">\n                    <div class=\"title\">Plots</div>\n                    <ul class=\"list\">\n                        <li><input type=\"checkbox\" id=\"checkbox-magnitude-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-magnitude-${tabId}\">Magnitude</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-phase-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-phase-${tabId}\">Phase</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-ir-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-ir-${tabId}\">Impulse Response</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-ir-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-ir-${tabId}\">Fundamental + Harmonic Distortion</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-distortion-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-distortion-${tabId}\">Distortion</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-distortion-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-distortion-${tabId}\">Sound Pressure Level</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-deconvoluted-ir-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-deconvoluted-ir-${tabId}\">Deconvoluted Impulse Response</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-stimulus-waveform-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-stimulus-waveform-${tabId}\">Stimulus Waveform</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-recorded-waveform-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-recorded-waveform-${tabId}\">Recorded Waveform</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-target-curve-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-target-curve-${tabId}\">Target Curve<button class=\"float-right text-xs cursor-pointer\" style=\"color: #bbb; padding-top: 3px\">Set</button></label></li>\n                    </ul>\n                </div>\n                <div class=\"section\">\n                    <div class=\"title\">Properties</div>\n                    <p><i>There are no properties for this analysis.</i></p>\n                </div>\n                <div id=\"resize-handle\" class=\"resize-handle\"></div>\n            </div>\n            <div class=\"flex-1 main-content\">\n                <div class=\"grid grid-cols-6 gap-[1px] bg-[#ddd] border-b border-[#ddd]\">\n                    <div class=\"plot-box\">\n                        <div id=\"plot-${tabId}-magnitude\" class=\"plot-medium\"></div>\n                        <div class=\"button-bar\">\n                            <button>Customize...</button>\n                            <button>Export as...</button>\n                            <label for=\"checkbox-magnitude-${tabId}\">Hide</label>\n                        </div>\n                    </div>\n                    <div class=\"plot-box\">\n                        <div id=\"plot-${tabId}-phase\" class=\"plot-medium\"></div>\n                        <div class=\"button-bar\">\n                            <button>Customize...</button>\n                            <button>Export as...</button>\n                            <label for=\"checkbox-phase-${tabId}\">Hide</label>\n                        </div>\n                    </div>\n                    <div class=\"plot-box\">\n                        <div id=\"plot-${tabId}-ir\" class=\"plot-medium\"></div>\n                        <div class=\"button-bar\">\n                            <button>Customize...</button>\n                            <button>Export as...</button>\n                            <label for=\"checkbox-ir-${tabId}\">Hide</label>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n       \n        \n    `;\n  tabContents.appendChild(content);\n  switchTab(tabId);\n  console.log(\"Analyzing response file:\", filename);\n  console.log(\"Response audio data:\", responseData);\n  const responseSamples = responseData.getChannelData(0);\n  console.log(responseData.getChannelData(0));\n  const responseFFT = computeFFT(responseSamples);\n  const smoothedResponseFFT = smoothFFT(responseFFT, 1 / 6, 1 / 48);\n  const tracesMagnitude = [{\n    x: responseFFT.frequency,\n    y: db(responseFFT.magnitude),\n    type: \"scatter\",\n    mode: \"lines\",\n    name: \"Measurement signal\",\n    line: { color: \"#0366d633\", width: 1 }\n  }];\n  tracesMagnitude.push({\n    x: smoothedResponseFFT.frequency,\n    y: smoothedResponseFFT.magnitude,\n    type: \"scatter\",\n    mode: \"lines\",\n    name: \"Measurement signal (Smoothed)\",\n    line: { color: \"#0366d6\", width: 2 }\n  });\n  const tracesPhase = [];\n  const tracesPhaseSecondary = [];\n  const tracesIR = [];\n  let irPeakAt = 0;\n  let referenceSamples = Float32Array.from([]);\n  if (referenceData) {\n    referenceSamples = referenceData.getChannelData(0);\n    const referenceFFT = computeFFT(referenceSamples);\n    tracesMagnitude.push({\n      x: referenceFFT.frequency,\n      y: db(referenceFFT.magnitude),\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Reference signal\",\n      line: { color: \"#0366d6\", width: 2 }\n    });\n    const ir = twoChannelImpulseResponse(responseSamples, referenceSamples);\n    const farina_ir = FarinaImpulseResponse(responseSamples, referenceSamples);\n    console.log(\"Impulse response peak at\", ir.peakAt);\n    irPeakAt = ir.peakAt;\n    tracesIR.push({\n      x: ir.t,\n      y: ir.ir,\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Dual-FFT Impulse Response\",\n      line: { color: \"#d73a49\", width: 1 }\n    });\n    const transferFunction = computeFFTFromIR(ir);\n    const transferFunctionFarina = computeFFTFromIR(farina_ir);\n    const smoothedFreqResponse = smoothFFT(transferFunction, 1 / 6, 1 / 48);\n    const smoothedFreqResponseFarina = smoothFFT(transferFunctionFarina, 1 / 6, 1 / 48);\n    const rmsValue = 1;\n    console.log(\"Reference RMS:\", db(rmsValue));\n    tracesMagnitude.push({\n      x: transferFunction.frequency,\n      y: db(transferFunction.magnitude.map((v) => v * rmsValue)),\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Dual-FFT Transfer Function (Raw)\",\n      line: { color: \"#d73a4933\", width: 1 }\n    });\n    tracesMagnitude.push({\n      x: smoothedFreqResponse.frequency,\n      y: smoothedFreqResponse.magnitude.map((v) => v + db(rmsValue)),\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Dual-FFT Transfer Function (Smoothed)\",\n      line: { color: \"#d73a49\", width: 2 }\n    });\n    tracesMagnitude.push({\n      x: transferFunctionFarina.frequency.map((v) => v),\n      y: db(transferFunctionFarina.magnitude.map((v) => v * rmsValue)),\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Farina Transfer Function\",\n      line: { color: \"#341fad33\", width: 1 }\n    });\n    tracesMagnitude.push({\n      x: smoothedFreqResponseFarina.frequency.map((v) => v),\n      y: smoothedFreqResponseFarina.magnitude.map((v) => v + db(rmsValue)),\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Farina Transfer Function (Smoothed)\",\n      line: { color: \"#341fadff\", width: 2 }\n    });\n    tracesPhase.push({\n      x: transferFunction.frequency,\n      y: transferFunction.phase,\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Dual-FFT Transfer Function (Raw)\",\n      line: { color: \"#d73a4933\", width: 1 }\n    });\n    tracesPhase.push({\n      x: smoothedFreqResponse.frequency,\n      y: smoothedFreqResponse.phase,\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Dual-FFT Transfer Function (Smoothed)\",\n      line: { color: \"#d73a49\", width: 2 }\n    });\n    const gd = groupDelays(transferFunction, 1e3);\n    tracesPhase.push({\n      x: transferFunction.frequency,\n      y: gd,\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Group Delay (Calculated on a reduced set of points)\",\n      line: { color: \"#d73a49\", width: 2, dash: \"dot\" },\n      yaxis: \"y2\"\n    });\n  }\n  const plotSettings = {\n    plotGlPixelRatio: 2,\n    // For better clarity on high-DPI screens\n    legend: { \"orientation\": \"h\", \"y\": -0.2, \"yanchor\": \"top\" },\n    plot_bgcolor: \"#fafbfc\",\n    paper_bgcolor: \"#fff\",\n    staticPlot: false,\n    // Enable interactivity\n    dragmode: \"pan\",\n    showAxisDragHandles: true,\n    showAxisRangeEntryBoxes: true,\n    axisDragOnHover: true,\n    tightenLats: true,\n    font: {\n      family: \"'Newsreader', Georgia, 'Times New Roman', Times, serif\"\n    },\n    margin: { t: 80, r: 65, b: 70, l: 65 }\n  };\n  const layoutPhase = {\n    title: \"Phase Analysis\",\n    xaxis: {\n      title: \"Frequency (Hz)\",\n      type: \"log\",\n      gridcolor: \"#e1e4e8\",\n      range: [Math.log10(20), Math.log10(2e4)],\n      tickformat: \".0f\"\n    },\n    yaxis: {\n      title: \"Phase (degrees)\",\n      gridcolor: \"#e1e4e8\",\n      automargin: true,\n      range: [-720, 720]\n    },\n    yaxis2: {\n      title: \"Group Delay (ms)\",\n      gridcolor: \"#e1e4e8\",\n      automargin: true,\n      anchor: \"x\",\n      overlaying: \"y\",\n      side: \"right\",\n      range: [-20, 20]\n    },\n    ...plotSettings\n  };\n  window.Plotly.newPlot(`plot-${tabId}-phase`, tracesPhase, layoutPhase, { responsive: true });\n  const layoutMagnitude = {\n    title: \"Magnitude Analysis\",\n    xaxis: {\n      title: \"Frequency (Hz)\",\n      type: \"log\",\n      gridcolor: \"#e1e4e8\",\n      range: [Math.log10(20), Math.log10(2e4)],\n      tickformat: \".0f\"\n    },\n    yaxis: {\n      title: \"Magnitude (dB)\",\n      gridcolor: \"#e1e4e8\",\n      rangemode: \"tozero\",\n      range: [-85, 5]\n    },\n    ...plotSettings\n  };\n  window.Plotly.newPlot(`plot-${tabId}-magnitude`, tracesMagnitude, layoutMagnitude, { responsive: true });\n  const layoutIR = {\n    title: \"Impulse response\",\n    xaxis: {\n      title: \"Amplitude\",\n      gridcolor: \"#e1e4e8\",\n      range: [-0.05 + irPeakAt / responseData.sampleRate, 0.05 + irPeakAt / responseData.sampleRate]\n    },\n    yaxis: {\n      title: \"Amplitude (gain)\",\n      gridcolor: \"#e1e4e8\",\n      automargin: true\n    },\n    ...plotSettings\n  };\n  window.Plotly.newPlot(`plot-${tabId}-ir`, tracesIR, layoutIR, { responsive: true });\n  saveState();\n  storage.setItem(`${tabId}`, JSON.stringify({\n    filename,\n    referenceFilename,\n    responseSamples: Array.from(responseSamples),\n    referenceSamples: referenceSamples.length > 0 ? Array.from(referenceSamples) : null\n  })).catch((err) => console.error(\"Failed to persist analysis:\", err));\n  function initResize(e) {\n    e.preventDefault();\n    window.addEventListener(\"mousemove\", resize, false);\n    window.addEventListener(\"mouseup\", stopResize, false);\n    console.log(\"Init resize\");\n    document.body.style.cursor = \"col-resize\";\n  }\n  function resize(e) {\n    const container = content.querySelector(\".flex\");\n    const handle = document.getElementById(\"resize-handle\")?.parentElement;\n    const rect = container.getBoundingClientRect();\n    const newWidth = e.clientX - rect.left;\n    if (newWidth > 150 && newWidth < rect.width - 150) {\n      handle.style.width = `${newWidth}px`;\n    }\n  }\n  function stopResize() {\n    window.removeEventListener(\"mousemove\", resize, false);\n    window.removeEventListener(\"mouseup\", stopResize, false);\n    window.dispatchEvent(new Event(\"resize\"));\n    document.body.style.cursor = \"default\";\n  }\n  document.getElementById(\"resize-handle\")?.addEventListener(\"mousedown\", initResize, false);\n  document.getElementById(`checkbox-magnitude-${tabId}`)?.addEventListener(\"change\", (e) => {\n    console.log(\"Toggling magnitude plot visibility\");\n    const box = document.getElementById(`plot-${tabId}-magnitude`).parentElement;\n    box.setAttribute(\"style\", e.target.checked ? \"display: block;\" : \"display: none;\");\n  });\n  document.getElementById(`checkbox-phase-${tabId}`)?.addEventListener(\"change\", (e) => {\n    const box = document.getElementById(`plot-${tabId}-phase`).parentElement;\n    box.setAttribute(\"style\", e.target.checked ? \"display: block;\" : \"display: none;\");\n  });\n  document.getElementById(`checkbox-ir-${tabId}`)?.addEventListener(\"change\", (e) => {\n    const box = document.getElementById(`plot-${tabId}-ir`).parentElement;\n    box.setAttribute(\"style\", e.target.checked ? \"display: block;\" : \"display: none;\");\n  });\n}\nfunction saveState() {\n  const tabs = Array.from(document.querySelectorAll(\".tab[data-tab]\")).map((tab) => ({\n    id: tab.dataset.tab,\n    name: tab.textContent?.replace(\"\\xD7\", \"\").trim()\n  }));\n  storage.setItem(\"tabs\", JSON.stringify(tabs));\n  console.log(\"Saved state with tabs:\", tabs);\n}\nasync function loadState() {\n  try {\n    const savedTabs = await storage.getItem(\"tabs\");\n    if (!savedTabs) return;\n    const tabs = JSON.parse(savedTabs);\n    console.log(\"Loading saved tabs:\", tabs);\n    for (const tab of tabs) {\n      const raw = await storage.getItem(`${tab.id}`);\n      const analysisData = raw ? JSON.parse(raw) : null;\n      console.log(\"Restoring analysis data for tab\", tab.id, analysisData);\n      if (analysisData) {\n        createAnalysisTab(Audio.fromSamples(Float32Array.from(analysisData.responseSamples)), analysisData.referenceSamples ? Audio.fromSamples(Float32Array.from(analysisData.referenceSamples)) : null, analysisData.filename, analysisData.referenceFilename);\n      }\n    }\n  } catch (e) {\n    console.error(\"Failed to load saved state:\", e);\n  }\n}\nloadState();\n","console.debug(\"Math module loaded\");\n\nexport function logspace(start: number, end: number, num: number): Float32Array {\n    const logStart = Math.log10(start);\n    const logEnd = Math.log10(end);\n    const logStep = (logEnd - logStart) / (num - 1);\n    return Float32Array.from({ length: num }, (_, i) => Math.pow(10, logStart + i * logStep));\n}\n\nexport function linspace(start: number, end: number, num: number): Float32Array {\n    if (num === 1) return Float32Array.from([start]);\n    const step = (end - start) / (num - 1);\n    return Float32Array.from({ length: num }, (_, i) => start + i * step);\n}\n\nexport function closest(num: number, arr: Float32Array): number {\n    let curr = arr[0];\n    let diff = Math.abs(num - curr);\n    let index = 0;\n    for (let val = 0; val < arr.length; val++) {\n        const newDiff = Math.abs(num - arr[val]);\n        if (newDiff < diff) {\n            diff = newDiff;\n            curr = arr[val];\n            index = val;\n        }\n    }\n    return index;\n}\n\nexport function clamp(v: number, lower: number, upper: number): number {\n    return Math.max(lower, Math.min(upper, v));\n}\n\nexport const average = (array: Float32Array): number => array.reduce((a, b) => a + b) / array.length;\n\nexport const abs = (re: number, im: number = 0): number => Math.sqrt(re * re + im * im);\n\nexport const mod = (n: number, m: number): number => ((n % m) + m) % m;\n\nexport const nextPow2 = (v: number): number => {\n        let p = 1;\n        while (p < v) p <<= 1;\n        return p;\n    };\n\nexport function max(arr: Float32Array): number {\n    let maxVal = -Infinity;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] > maxVal) maxVal = Math.abs(arr[i]);\n    }\n    return maxVal;\n}","/* This software is licensed under the MIT License.\n\nCopyright Fedor Indutny, 2017.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\nconsole.debug(\"FFT module loaded\");\n\nexport class FFT {\n  size: number;\n  private _csize: number;\n  table: number[];\n  private _width: number;\n  private _bitrev: number[];\n  private _out: number[] | null;\n  private _data: number[] | null;\n  private _inv: number;\n\n  constructor(size: number) {\n    this.size = size | 0;\n    if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n      throw new Error('FFT size must be a power of two and bigger than 1');\n\n    this._csize = size << 1;\n\n    // NOTE: Use of `var` is intentional for old V8 versions\n    const table = new Array<number>(this.size * 2);\n    for (let i = 0; i < table.length; i += 2) {\n      const angle = Math.PI * i / this.size;\n      table[i] = Math.cos(angle);\n      table[i + 1] = -Math.sin(angle);\n    }\n    this.table = table;\n\n    // Find size's power of two\n    let power = 0;\n    for (let t = 1; this.size > t; t <<= 1)\n      power++;\n\n    // Calculate initial step's width:\n    //   * If we are full radix-4 - it is 2x smaller to give inital len=8\n    //   * Otherwise it is the same as `power` to give len=4\n    this._width = power % 2 === 0 ? power - 1 : power;\n\n    // Pre-compute bit-reversal patterns\n    this._bitrev = new Array<number>(1 << this._width);\n    for (let j = 0; j < this._bitrev.length; j++) {\n      this._bitrev[j] = 0;\n      for (let shift = 0; shift < this._width; shift += 2) {\n        const revShift = this._width - shift - 2;\n        this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n      }\n    }\n\n    this._out = null;\n    this._data = null;\n    this._inv = 0;\n  }\n\n  fromComplexArray(complex: number[] | Float32Array, storage?: number[] | Float32Array): number[] | Float32Array {\n    const res = storage || new Array<number>(complex.length >>> 1);\n    for (let i = 0; i < complex.length; i += 2)\n      res[i >>> 1] = complex[i];\n    return res;\n  }\n\n  createComplexArray(): number[] {\n    const res = new Array<number>(this._csize);\n    for (let i = 0; i < res.length; i++)\n      res[i] = 0;\n    return res;\n  }\n\n  toComplexArray(input: number[] | Float32Array, storage?: number[] | Float32Array): number[] | Float32Array {\n    const res = storage || this.createComplexArray();\n    for (let i = 0; i < res.length; i += 2) {\n      res[i] = input[i >>> 1];\n      res[i + 1] = 0;\n    }\n    return res;\n  }\n\n  completeSpectrum(spectrum: number[] | Float32Array): void {\n    const size = this._csize;\n    const half = size >>> 1;\n    for (let i = 2; i < half; i += 2) {\n      spectrum[size - i] = spectrum[i];\n      spectrum[size - i + 1] = -spectrum[i + 1];\n    }\n  }\n\n  transform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 0;\n    this._transform4();\n    this._out = null;\n    this._data = null;\n  }\n\n  realTransform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 0;\n    this._realTransform4();\n    this._out = null;\n    this._data = null;\n  }\n\n  inverseTransform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 1;\n    this._transform4();\n    for (let i = 0; i < out.length; i++)\n      out[i] /= this.size;\n    this._out = null;\n    this._data = null;\n  }\n\n  // radix-4 implementation\n  //\n  // NOTE: Uses of `var` are intentional for older V8 version that do not\n  // support both `let compound assignments` and `const phi`\n  private _transform4(): void {\n    const out = this._out!;\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = (size / step) << 1;\n\n    let outOff: number;\n    let t: number;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform2(outOff, off, step);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform4(outOff, off, step);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = (size / step) << 1;\n      const quarterLen = len >>> 2;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        // Full case\n        const limit = outOff + quarterLen;\n        for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n          const A = i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n\n          // Middle values\n          const MAr = Ar;\n          const MAi = Ai;\n\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n\n          const FCr = T0r - T2r;\n          const FCi = T0i - T2i;\n\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n\n          const FDr = T1r - T3i;\n          const FDi = T1i + T3r;\n\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          out[D] = FDr;\n          out[D + 1] = FDi;\n        }\n      }\n    }\n  }\n\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  private _singleTransform2(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n\n    const evenR = data[off];\n    const evenI = data[off + 1];\n    const oddR = data[off + step];\n    const oddI = data[off + step + 1];\n\n    const leftR = evenR + oddR;\n    const leftI = evenI + oddI;\n    const rightR = evenR - oddR;\n    const rightI = evenI - oddI;\n\n    out[outOff] = leftR;\n    out[outOff + 1] = leftI;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = rightI;\n  }\n\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  private _singleTransform4(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Ai = data[off + 1];\n    const Br = data[off + step];\n    const Bi = data[off + step + 1];\n    const Cr = data[off + step2];\n    const Ci = data[off + step2 + 1];\n    const Dr = data[off + step3];\n    const Di = data[off + step3 + 1];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T0i = Ai + Ci;\n    const T1r = Ar - Cr;\n    const T1i = Ai - Ci;\n    const T2r = Br + Dr;\n    const T2i = Bi + Di;\n    const T3r = inv * (Br - Dr);\n    const T3i = inv * (Bi - Di);\n\n    // Final values\n    const FAr = T0r + T2r;\n    const FAi = T0i + T2i;\n\n    const FBr = T1r + T3i;\n    const FBi = T1i - T3r;\n\n    const FCr = T0r - T2r;\n    const FCi = T0i - T2i;\n\n    const FDr = T1r - T3i;\n    const FDi = T1i + T3r;\n\n    out[outOff] = FAr;\n    out[outOff + 1] = FAi;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = FCi;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n\n  // Real input radix-4 implementation\n  private _realTransform4(): void {\n    const out = this._out!;\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = (size / step) << 1;\n\n    let outOff: number;\n    let t: number;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = (size / step) << 1;\n      const halfLen = len >>> 1;\n      const quarterLen = halfLen >>> 1;\n      const hquarterLen = quarterLen >>> 1;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n          const A = outOff + i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n\n          // Middle values\n          const MAr = Ar;\n          const MAi = Ai;\n\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n\n          // Output final middle point\n          if (i === 0) {\n            const FCr = T0r - T2r;\n            const FCi = T0i - T2i;\n            out[C] = FCr;\n            out[C + 1] = FCi;\n            continue;\n          }\n\n          // Do not overwrite ourselves\n          if (i === hquarterLen)\n            continue;\n\n          // In the flipped case:\n          // MAi = -MAi\n          // MBr=-MBi, MBi=-MBr\n          // MCr=-MCr\n          // MDr=MDi, MDi=MDr\n          const ST0r = T1r;\n          const ST0i = -T1i;\n          const ST1r = T0r;\n          const ST1i = -T0i;\n          const ST2r = -inv * T3i;\n          const ST2i = -inv * T3r;\n          const ST3r = -inv * T2i;\n          const ST3i = -inv * T2r;\n\n          const SFAr = ST0r + ST2r;\n          const SFAi = ST0i + ST2i;\n\n          const SFBr = ST1r + ST3i;\n          const SFBi = ST1i - ST3r;\n\n          const SA = outOff + quarterLen - i;\n          const SB = outOff + halfLen - i;\n\n          out[SA] = SFAr;\n          out[SA + 1] = SFAi;\n          out[SB] = SFBr;\n          out[SB + 1] = SFBi;\n        }\n      }\n    }\n  }\n\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  private _singleRealTransform2(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n\n    const evenR = data[off];\n    const oddR = data[off + step];\n\n    const leftR = evenR + oddR;\n    const rightR = evenR - oddR;\n\n    out[outOff] = leftR;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = 0;\n  }\n\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  private _singleRealTransform4(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Br = data[off + step];\n    const Cr = data[off + step2];\n    const Dr = data[off + step3];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T1r = Ar - Cr;\n    const T2r = Br + Dr;\n    const T3r = inv * (Br - Dr);\n\n    // Final values\n    const FAr = T0r + T2r;\n\n    const FBr = T1r;\n    const FBi = -T3r;\n\n    const FCr = T0r - T2r;\n\n    const FDr = T1r;\n    const FDi = T3r;\n\n    out[outOff] = FAr;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = 0;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n}\n","import { average, closest, logspace, linspace } from './math';\n\nconsole.debug(\"Fractional Octave Smoothing module loaded\");\n\nexport function getFractionalOctaveFrequencies(fraction: number, f_low: number = 20, f_high: number = 24000, fftSize: number): Float32Array {\n    if (fraction <= 0) {\n        throw new Error(\"Fraction must be greater than 0\");\n    }\n    if (f_low <= 0 || f_high <= 0) {\n        throw new Error(\"Frequencies must be greater than 0\");\n    }\n    if (f_low >= f_high) {\n        throw new Error(\"f_low must be less than f_high\");\n    }\n    const num_points = Math.round((Math.log10(f_high) - Math.log10(f_low)) / fraction) + 1;\n\n    let frequencies = logspace(f_low, f_high, num_points);\n\n    const frequency_resolution = 48000 / fftSize; // Assuming a sample rate of 48000 Hz\n\n    for (let i = 0; i < frequencies.length; i++) {\n        frequencies[i] = Math.round(frequencies[i] / frequency_resolution) * frequency_resolution;\n    }\n    frequencies = Float32Array.from(new Set(frequencies)); // Remove duplicates\n\n    return frequencies;\n}\n\nexport function fractionalOctaveSmoothing(frequencyData: Float32Array, fraction: number, frequencies: Float32Array): Float32Array {\n    const frequenciesAll = linspace(0, 48000 / 2, frequencyData.length);\n    const frequency_resolution = 48000 / frequencyData.length;\n    const smoothedData = new Float32Array(frequencies.length);\n    const n = frequencyData.length;\n    const factor = Math.pow(2, (0.5 * fraction)) - Math.pow(0.5, (0.5 * fraction));\n    for (let p = 0; p < frequencies.length; p++) {\n        const i = closest(frequencies[p], frequenciesAll);\n        // If the distance between this and previous frequency is less than frequency_resolution, pass direct value\n\n        let sum = 0;\n        const width = Math.round(0.5 * factor * (n * 0.5 - Math.abs(n * 0.5 - i)));\n        if (width === 0) {\n            sum = frequencyData[i];\n        } else {\n            const as = frequencyData.slice(Math.round(i - width + 1), Math.min(Math.round(i + width), n - 1));\n            sum = average(as);\n        }\n        smoothedData[p] = sum;\n    }\n    return smoothedData;\n}","import { abs, average, closest, linspace, mod, nextPow2 } from './math';\nimport { FFT } from './fft';\nimport { fractionalOctaveSmoothing, getFractionalOctaveFrequencies } from './fractional_octave_smoothing';;\n\nconsole.debug(\"Audio module loaded\");\n\n(window as any).FFT = FFT; // Make FFT globally available\n\nexport function sum(buffer: Float32Array): number {\n    let sum = 0;\n    for (let i = 0; i < buffer.length; i++) {\n        sum += buffer[i] * buffer[i];\n    }\n    return sum\n}\n\nexport function rms(buffer: Float32Array): number {\n    // Assuming mono channel for simplicity; extend as needed for multi-channel\n    return Math.sqrt(sum(buffer) / buffer.length);\n}\n\nexport function normalize(input: Float32Array, peak: boolean = false): Float32Array {\n    const rms_value = rms(input);\n    if (rms_value === 0) return input; // avoid division by zero, return original (silence)\n\n    const factor = (1 / rms_value) * (peak ? 1 : Math.SQRT2);\n\n    return input.map(v => v * factor);\n}\n\nexport function db(value: Float32Array): Float32Array;\nexport function db(value: number): number;\nexport function db(value: Float32Array | number): Float32Array | number {\n    if (value instanceof Float32Array) {\n        return value.map(v => 20 * Math.log10(v + 1e-50));\n    } else {\n        return 20 * Math.log10(value + 1e-50);\n    }\n}\n\nexport function exponentialMovingAverage(old: number, value: number, alpha: number): number {\n    return alpha * value + (1 - alpha) * old;\n}\n\nexport const smoothingFactor = (timeConstant: number, sampleRate: number): number => {\n    return 1 - Math.exp(-1 / (sampleRate * timeConstant));\n}\n\nexport function dbToLinear(db: number): number {\n    return Math.pow(10, db / 20);\n}\n\nexport function getExponentialSmoothingFactor(timeConstant: number, sampleRate: number): number {\n    return 1 - Math.exp(-1 / (timeConstant * sampleRate));\n}\n\nexport interface FFTResult {\n    frequency: Float32Array;\n    magnitude: Float32Array;\n    phase: Float32Array;\n    fftSize: number;\n    peakAt?: number;\n    sampleRate?: number;\n}\n\nasync function loadAudioFile(file: File): Promise<Audio> {\n    const headerBuffer = await file.slice(0, 256 * 1024).arrayBuffer();\n\n    function getExt(name: string) {\n        return (name.split('.').pop() || '').toLowerCase();\n    }\n\n    function parseWav(buf: ArrayBuffer) {\n        const dv = new DataView(buf);\n        function readStr(off: number, len: number) {\n            let s = '';\n            for (let i = 0; i < len; i++) s += String.fromCharCode(dv.getUint8(off + i));\n            return s;\n        }\n\n        if (readStr(0, 4) !== 'RIFF' || readStr(8, 4) !== 'WAVE') return null;\n\n        let offset = 12;\n        const info: any = {};\n        while (offset + 8 <= dv.byteLength) {\n            const id = readStr(offset, 4);\n            const size = dv.getUint32(offset + 4, true);\n            if (id === 'fmt ') {\n                info.audioFormat = dv.getUint16(offset + 8, true);\n                info.numChannels = dv.getUint16(offset + 10, true);\n                info.sampleRate = dv.getUint32(offset + 12, true);\n                info.byteRate = dv.getUint32(offset + 16, true);\n                info.blockAlign = dv.getUint16(offset + 20, true);\n                info.bitsPerSample = dv.getUint16(offset + 22, true);\n            } else if (id === 'data') {\n                info.dataChunkSize = size;\n            }\n            offset += 8 + size + (size % 2);\n        }\n        if (info.sampleRate && info.byteRate && info.dataChunkSize) {\n            info.duration = info.dataChunkSize / info.byteRate;\n        }\n        return info;\n    }\n\n    function parseMp3(buf: ArrayBuffer) {\n        const bytes = new Uint8Array(buf);\n        let offset = 0;\n        // Skip ID3v2 tag if present\n        if (bytes[0] === 0x49 && bytes[1] === 0x44 && bytes[2] === 0x33) {\n            const size = ((bytes[6] & 0x7f) << 21) | ((bytes[7] & 0x7f) << 14) | ((bytes[8] & 0x7f) << 7) | (bytes[9] & 0x7f);\n            offset = 10 + size;\n        }\n        // find first frame header\n        let headerIndex = -1;\n        for (let i = offset; i < bytes.length - 4; i++) {\n            if (bytes[i] === 0xFF && (bytes[i + 1] & 0xE0) === 0xE0) {\n                headerIndex = i;\n                break;\n            }\n        }\n        if (headerIndex < 0) return null;\n        const b1 = bytes[headerIndex + 1];\n        const b2 = bytes[headerIndex + 2];\n        const b3 = bytes[headerIndex + 3];\n\n        const versionBits = (b1 >> 3) & 0x03;\n        const layerBits = (b1 >> 1) & 0x03;\n        const bitrateBits = (b2 >> 4) & 0x0f;\n        const sampleRateBits = (b2 >> 2) & 0x03;\n        const channelMode = (b3 >> 6) & 0x03;\n\n        const versions: any = {\n            0: 'MPEG Version 2.5',\n            1: 'reserved',\n            2: 'MPEG Version 2 (ISO/IEC 13818-3)',\n            3: 'MPEG Version 1 (ISO/IEC 11172-3)'\n        };\n        const layers: any = {\n            0: 'reserved',\n            1: 'Layer III',\n            2: 'Layer II',\n            3: 'Layer I'\n        };\n\n        const sampleRates: any = {\n            3: [44100, 48000, 32000],\n            2: [22050, 24000, 16000],\n            0: [11025, 12000, 8000]\n        };\n        const versionKey = versionBits;\n        const layerKey = layerBits;\n\n        // bitrate tables (kbps)\n        const bitrateTable: any = {\n            // MPEG1 Layer III\n            '3_1': [0,32,40,48,56,64,80,96,112,128,160,192,224,256,320,0],\n            // MPEG2/2.5 Layer III\n            '0_1': [0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0],\n            '2_1': [0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0],\n            // fallback generic table for other layers/versions (best-effort)\n            '3_2': [0,32,48,56,64,80,96,112,128,160,192,224,256,320,384,0],\n            '3_3': [0,32,64,96,128,160,192,224,256,320,384,448,512,576,640,0]\n        };\n\n        const versionStr = versions[versionKey] || 'unknown';\n        const layerStr = layers[layerKey] || 'unknown';\n        let sampleRate = sampleRates[versionKey]?.[sampleRateBits] || null;\n\n        let bitrateKbps = 0;\n        const tbKey = `${versionKey}_${layerKey}`;\n        if (bitrateTable[tbKey]) {\n            bitrateKbps = bitrateTable[tbKey][bitrateBits] || 0;\n        } else if (bitrateTable['3_1'] && versionKey === 3 && layerKey === 1) {\n            bitrateKbps = bitrateTable['3_1'][bitrateBits] || 0;\n        }\n\n        const channels = channelMode === 3 ? 1 : 2;\n        let duration = null;\n        if (bitrateKbps > 0) {\n            duration = (bytes.length * 8) / (bitrateKbps * 1000);\n        }\n\n        return {\n            version: versionStr,\n            layer: layerStr,\n            bitrateKbps: bitrateKbps || null,\n            sampleRate,\n            channels,\n            duration\n        };\n    }\n\n    const ext = getExt(file.name);\n    const mime = file.type || 'unknown';\n    let metadata: {[Key: string]: string | number | null} = {};\n\n    const wavInfo = parseWav(headerBuffer);\n    if (wavInfo) {\n        metadata.format = 'wav';\n        metadata = Object.assign(metadata, wavInfo || {});\n    } else if (mime === 'audio/mpeg' || ext === 'mp3') {\n        const mp3Info = parseMp3(headerBuffer);\n        metadata.format = 'mp3';\n        metadata = Object.assign(metadata, mp3Info || {});\n    } else {\n        // best-effort: report file.type and extension and later rely on AudioContext decode\n        metadata.format = mime || ext || 'unknown';\n    }\n\n    console.log('Extracted file metadata:', metadata);\n    const arrayBuffer = await file.arrayBuffer();\n    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n    const audioBuffer: AudioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n\n    return Audio.fromAudioBuffer(audioBuffer, metadata);\n}\n\nexport class Audio extends AudioBuffer {\n    metadata?: {[Key: string]: string | number | null};\n\n    static fromAudioBuffer(buffer: AudioBuffer, metadata?: {[Key: string]: string | number | null}): Audio {\n        const audio = new Audio({\n            length: buffer.length,\n            numberOfChannels: buffer.numberOfChannels,\n            sampleRate: buffer.sampleRate\n        });\n        for (let ch = 0; ch < buffer.numberOfChannels; ch++) {\n            audio.copyToChannel(buffer.getChannelData(ch), ch);\n        }\n        audio.metadata = metadata;\n        return audio;\n    }\n\n    static fromSamples(samples: Float32Array, sampleRate: number = 48000, metadata?: {[Key: string]: string | number | null}): Audio {\n        if (!samples || samples.length == 0) return new Audio({ length: 0, numberOfChannels: 1, sampleRate: sampleRate });\n        const audio = new Audio({\n            length: samples.length,\n            numberOfChannels: 1,\n            sampleRate: sampleRate\n        });\n        audio.copyToChannel(samples, 0);\n        audio.metadata = metadata;\n        return audio;\n    }\n\n    applyGain(gain: number): Audio {\n        const numChannels = this.numberOfChannels;\n        for (let ch = 0; ch < numChannels; ch++) {\n            const data = this.getChannelData(ch).map(v => v * gain);\n            this.copyToChannel(data, ch, 0);\n        }\n        return this;\n    }\n\n    getChannel(channel: number): Audio {\n        if (channel < 0 || channel >= this.numberOfChannels) {\n            throw new Error(\"Invalid channel number\");\n        }\n        const channelData = this.getChannelData(channel);\n        const newBuffer = new AudioBuffer({\n            length: channelData.length,\n            numberOfChannels: 1,\n            sampleRate: this.sampleRate\n        });\n        // copy channel samples into the mono buffer\n        newBuffer.copyToChannel(channelData, 0, 0);\n        return new Audio(newBuffer);\n    }\n\n    rms(channel: number = 0): number {\n        if (channel < 0 || channel >= this.numberOfChannels) {\n            throw new Error(\"Invalid channel number\");\n        }\n        const data = this.getChannelData(channel);\n        return rms(data);\n    }\n}\n\nexport function chirp(f_start: number, f_stop: number, duration: number | null = null, rate: number | null = null, fade: number = 0.01, fs: number = 48000): [Float32Array, Float32Array, Float32Array] {\n    const c = Math.log(f_stop / f_start);\n\n    let L: number;\n    let samples_count: number;\n\n    if (duration == null && rate == null) {\n        // Default to one decade per second if nothing provided\n        rate = 1.0;\n    }\n\n    if (duration == null) {\n        // rate is seconds per decade -> L = rate / ln(10)\n        L = (rate as number) / Math.log(10);\n        samples_count = Math.round(L * c * fs);\n        duration = samples_count / fs;\n    } else {\n        L = duration / c;\n        rate = Math.log(10) * L;\n        samples_count = Math.round(L * c * fs);\n    }\n\n    samples_count = Math.max(1, samples_count);\n\n    const fade_in = Math.max(0, Math.floor(fade * fs));\n    const fade_out = Math.max(0, Math.floor((fade / 10) * fs));\n\n    // instantaneous phase\n    // phi = (L * f_start) * (exp(t/L) - 1)\n    // compact phi: pre-fade (fade_in samples), main sweep, post-fade (fade_out samples)\n    const pre = Math.max(0, fade_in);\n    const post = Math.max(0, fade_out);\n    const phi = Float32Array.from({ length: pre + samples_count + post }, () => 0);\n\n    // offset matches original phi_fade_in last value: f_start * ((fade_in+1)/fs)\n    const offset = f_start * ((fade_in + 1) / fs);\n\n    // pre-fade linear ramp\n    for (let i = 0; i < pre; i++) phi[i] = f_start * (i / fs);\n\n    // main sweep (adds offset)\n    const baseIdx = pre;\n    for (let i = 0; i < samples_count; i++) {\n        let t = i / fs;\n        phi[baseIdx + i] = L * f_start * (Math.exp(t / L) - 1) + offset;\n    }\n\n    // post-fade linear ramp starting from last sweep value\n    const last = phi[baseIdx + samples_count - 1] || 0;\n    for (let i = 0; i < post; i++) {\n        phi[baseIdx + samples_count + i] = last + f_stop * ((i + 1) / fs);\n    }\n\n    // sweep = sin(2 * PI * phi)\n    const sweep = Float32Array.from({ length: phi.length }, () => 0);\n    for (let i = 0; i < phi.length; i++) sweep[i] = Math.sin(2 * Math.PI * phi[i]);\n\n    // compute time vector t for sweep length\n    const t = Float32Array.from({ length: sweep.length }, () => 0);\n    for (let i = 0; i < sweep.length; i++) t[i] = i / fs;\n\n    // envelope main: (exp(-t/L) / L) * f_stop * duration^2\n    const envMain = Float32Array.from({ length: t.length }, () => 0);\n    const factor = f_stop * (duration as number) * (duration as number);\n    for (let i = 0; i < t.length; i++) envMain[i] = (Math.exp(-t[i] / L) / L) * factor;\n\n    // prepend and append small zero pads (approx. 10ms and 1ms at given fs)\n    const startZeros = Math.floor(0.01 * fs); // ~480 samples at 48k\n    const endZeros = Math.floor(0.001 * fs);  // ~48 samples at 48k\n    const envelope = Float32Array.from({ length: startZeros + envMain.length + endZeros }, () => 0);\n    // copy envMain into middle\n    for (let i = 0; i < envMain.length; i++) {\n        envelope[startZeros + i] = envMain[i];\n    }\n\n    // window: simple linear fade in/out over fade_in / fade_out samples\n    const window = Float32Array.from({ length: sweep.length }, () => 0);\n    for (let i = 0; i < sweep.length; i++) {\n        let w = 1.0;\n        if (fade_in > 0 && i < fade_in) {\n            w = i / Math.max(1, fade_in);\n        }\n        if (fade_out > 0 && i >= sweep.length - fade_out) {\n            const k = i - (sweep.length - fade_out);\n            w *= 1 - (k / Math.max(1, fade_out));\n        }\n        window[i] = w;\n    }\n\n    // apply window to sweep\n    const sweepWindowed = Float32Array.from({ length: sweep.length }, () => 0);\n    for (let i = 0; i < sweep.length; i++) sweepWindowed[i] = sweep[i] * window[i];\n\n    return [sweepWindowed, t, envelope];\n}\n\nexport function smoothFFT(fftData: FFTResult, fraction: number, resolution: number): FFTResult {\n    const { frequency, magnitude, phase, fftSize } = fftData;\n    const smoothedMagnitude = Float32Array.from({ length: magnitude.length }, () => 0);\n\n    // Get fractional octave frequencies\n    const fractionalFrequencies = getFractionalOctaveFrequencies(resolution, 20, 24000, fftSize);\n\n    // Apply fractional octave smoothing\n    const smoothed = fractionalOctaveSmoothing(db(magnitude), fraction, fractionalFrequencies);\n    const smoothedPhase = fractionalOctaveSmoothing(phase, fraction, fractionalFrequencies);\n\n    return {\n        frequency: fractionalFrequencies,\n        magnitude: smoothed,\n        phase: smoothedPhase,\n        fftSize\n    };\n}\n\nexport function computeFFT(data: Float32Array | Float32Array, fftSize: number | null = null): FFTResult {\n    fftSize ??= 2 ** Math.ceil(Math.log2(data.length));\n    console.log(`Computing FFT with ${fftSize} bins for data length ${data.length}`);\n    const fft = new FFT(fftSize);\n    const out = fft.createComplexArray();\n\n    // Fix data length by zero-padding or truncating.\n    const frame = Float32Array.from({ length: fftSize }, () => 0);\n    for (let i = 0; i < fftSize; i++) {\n        frame[i] = (data[i] || 0) * 1;\n    }\n    fft.realTransform(out, frame);\n    \n    const frequency = Float32Array.from({ length: fftSize / 2 }, () => 0);\n    const magnitude = Float32Array.from({ length: fftSize / 2 }, () => 0);\n    const phase = Float32Array.from({ length: fftSize / 2 }, () => 0);\n\n    for (let i = 0; i < fftSize / 2; i++) {\n            const re = out[2 * i];\n            const im = out[2 * i + 1];\n            magnitude[i] = abs(re, im) * Math.SQRT2; // Scale by sqrt(2) for single-sided spectrum.\n            phase[i] = Math.atan2(im, re); // phase in radians, range [-PI, PI].\n    }\n    const frequencyResolution = 48000 / fftSize; // Assuming sample rate of 48000 Hz\n    for (let i = 0; i < fftSize / 2; i++) {\n        frequency[i] = i * frequencyResolution;\n    }\n\n    return {\n        frequency,\n        magnitude,\n        phase,\n        fftSize,\n    };\n}\n\nexport interface CorrelationResult {\n    corr: Float64Array;\n    lags: Int32Array;\n    estimatedLagSamples: number;\n    estimatedLagIndex: number;\n    peakCorrelation: number;\n    raw: Float64Array;\n    nfft: number;\n}\n\nexport function fftCorrelation(x: Float32Array | Float32Array, y: Float32Array | Float32Array): CorrelationResult {\n    // cross-correlate x with y using FFT (fft.js). Returns normalized cross-correlation,\n    // lags (samples), estimated lag (samples) and peak correlation value.\n    const lenX = x.length;\n    const lenY = y.length;\n    const fullLen = lenX + lenY - 1;\n\n    // next pow2 >= fullLen\n    const nextPow2 = (v: number): number => {\n        let p = 1;\n        while (p < v) p <<= 1;\n        return p;\n    };\n    const n = nextPow2(fullLen);\n\n    // zero-pad inputs to length n\n    const xP = Float32Array.from({ length: n }, () => 0);\n    const yP = Float32Array.from({ length: n }, () => 0);\n    xP.set(x, 0);\n    yP.set(y, 0);\n\n    const fft = new FFT(n);\n    const A = fft.createComplexArray();\n    const B = fft.createComplexArray();\n\n    // forward real FFTs\n    fft.realTransform(A, xP);\n    fft.realTransform(B, yP);\n    // complete the spectrum to full complex arrays (negative freqs)\n    if (typeof fft.completeSpectrum === 'function') {\n        fft.completeSpectrum(A);\n        fft.completeSpectrum(B);\n    }\n\n    // multiply A * conj(B) -> cross-spectrum\n    const C = fft.createComplexArray();\n    for (let k = 0; k < n; k++) {\n        const ar = A[2 * k], ai = A[2 * k + 1];\n        const br = B[2 * k], bi = B[2 * k + 1];\n        // A * conj(B) = (ar + i ai)*(br - i bi)\n        C[2 * k] = ar * br + ai * bi;\n        C[2 * k + 1] = ai * br - ar * bi;\n    }\n\n    // inverse FFT of cross-spectrum\n    const out = fft.createComplexArray();\n    fft.inverseTransform(out, C);\n\n    // real part / n gives linear cross-correlation (no circular wrap because padded)\n    const corr = Float64Array.from({ length: fullLen }, () => 0);\n    for (let i = 0; i < fullLen; i++) {\n        corr[i] = out[2 * i] / n;\n    }\n\n    // compute normalization factor (energy)\n    let sumX2 = 0, sumY2 = 0;\n    for (let i = 0; i < lenX; i++) sumX2 += x[i] * x[i];\n    for (let i = 0; i < lenY; i++) sumY2 += y[i] * y[i];\n    const denom = Math.sqrt(sumX2 * sumY2);\n\n    const normalized = Float64Array.from({ length: fullLen }, () => 0);\n    if (denom > 0) {\n        for (let i = 0; i < fullLen; i++) normalized[i] = corr[i] / denom;\n    } else {\n        // silence case -> zeros\n        for (let i = 0; i < fullLen; i++) normalized[i] = 0;\n    }\n\n    // lags: index i corresponds to lag = i - (lenY - 1)\n    const lags = new Int32Array(fullLen);\n    for (let i = 0; i < fullLen; i++) lags[i] = i - (lenY - 1);\n\n    // find peak\n    let peakIdx = 0;\n    let peakVal = -Infinity;\n    for (let i = 0; i < fullLen; i++) {\n        if (normalized[i] > peakVal) {\n            peakVal = normalized[i];\n            peakIdx = i;\n        }\n    }\n    const estimatedLag = lags[peakIdx];\n\n    return {\n        corr: normalized,\n        lags,\n        estimatedLagSamples: estimatedLag,\n        estimatedLagIndex: peakIdx,\n        peakCorrelation: peakVal,\n        raw: corr,\n        nfft: n\n    };\n}\n\n\nexport function fftConvolve(x: Float32Array | Float32Array, y: Float32Array | Float32Array, mode: 'same' | 'full' = 'same'): Float32Array {\n    const lenX = x.length;\n    const lenY = y.length;\n    const fullLen = lenX + lenY - 1;\n\n    // next pow2 >= fullLen\n    const n = nextPow2(fullLen);\n\n    // zero-pad inputs to length n\n    const xP = Float32Array.from({ length: n }, () => 0);\n    const yP = Float32Array.from({ length: n }, () => 0);\n    xP.set(x, 0);\n    yP.set(y, 0);\n\n    const fft = new FFT(n);\n    const A = fft.createComplexArray();\n    const B = fft.createComplexArray();\n\n    // forward real FFTs\n    fft.realTransform(A, xP);\n    fft.realTransform(B, yP);\n        // complete the spectrum to full complex arrays (negative freqs)\n    if (typeof fft.completeSpectrum === 'function') {\n        fft.completeSpectrum(A);\n        fft.completeSpectrum(B);\n    }\n\n    // multiply A * B -> convolution spectrum\n    const C = fft.createComplexArray();\n    for (let k = 0; k < n; k++) {\n        const ar = A[2 * k], ai = A[2 * k + 1];\n        const br = B[2 * k], bi = B[2 * k + 1];\n        C[2 * k] = ar * br - ai * bi;\n        C[2 * k + 1] = ai * br + ar * bi;\n    }\n\n    // inverse FFT\n    const out = fft.createComplexArray();\n    fft.inverseTransform(out, C);\n\n    // extract real part and normalize by n\n    const result = Float32Array.from({ length: fullLen }, () => 0);\n    for (let i = 0; i < fullLen; i++) {\n        result[i] = out[2 * i];\n    }\n\n    // return 'same' mode (centered, matching first input length)\n    if (mode === 'same') {\n        const start = Math.floor((fullLen - lenX) / 2);\n        return result.slice(start, start + lenX);\n    }\n\n    return result;\n}\n\nexport interface ImpulseResponseResult {\n    ir: Float32Array;\n    ir_complex: Float32Array;\n    t: Float32Array;\n    peakAt: number;\n    sampleRate: number;\n    fftSize: number;\n}\n\n\nexport function twoChannelImpulseResponse(y: Float32Array, x: Float32Array): ImpulseResponseResult {\n    // Calculate the impulse response by taking the IFFT of the division of the FFTs of output and input signals.\n    const fullLen = y.length + x.length - 1;\n    \n    const N = nextPow2(fullLen);\n\n    // zero-pad inputs to length n\n    const xP = Float32Array.from({ length: N }, () => 0);\n    const yP = Float32Array.from({ length: N }, () => 0);\n    xP.set(y, 0);\n    yP.set(x, 0);\n\n    const fft = new FFT(N);\n    const A = fft.createComplexArray();\n    const B = fft.createComplexArray();\n\n    // forward real FFTs\n    fft.realTransform(A, xP);\n    fft.realTransform(B, yP);\n\n    // Division A / B with regularization to avoid division by zero\n    const C = fft.createComplexArray();\n    const epsilon = 1e-20;\n    for (let k = 0; k < N; k++) {\n        const ar = A[2 * k], ai = A[2 * k + 1];\n        const br = B[2 * k], bi = B[2 * k + 1];\n        const denom = br * br + bi * bi + epsilon;\n        C[2 * k] = (ar * br + ai * bi) / denom;\n        C[2 * k + 1] = (ai * br - ar * bi) / denom;\n    }\n\n    // inverse FFT of cross-spectrum\n    const out = Float32Array.from(fft.createComplexArray());\n    fft.inverseTransform(out, C);\n\n    // Real part / N gives impulse response. This is shifted by N/2.\n    const ir = Float32Array.from({ length: N }, () => 0);\n    for (let i = 0; i < N; i++) {\n        ir[i] = out[2 * (( i + N/2) % N)]; // normalize by input length\n    }\n\n    const peakAt = closest(100000000, ir) + (-N) / 2;\n    const ir_complex = out.slice(); // copy\n    for (let i = 0; i < N; i++) {\n        ir_complex[2 * i] = out[2 * mod(i + peakAt, N)];\n        ir_complex[2 * i + 1] = out[2 * mod(i + peakAt, N) + 1];\n    }\n\n    // Remove DC offset.\n    const mean = average(ir)\n    for (let i = 0; i < N; i++) {\n        ir[i] = ir[i] - mean;\n    }\n\n    return {\n        ir,\n        ir_complex,\n        t: linspace((-N - 1) / 2 / 48000, (N - 1) / 2 / 48000, N), // assuming 48kHz\n        peakAt,\n        sampleRate: 48000,\n        fftSize: N,\n    };\n}\n\nexport function twoChannelFFT(dataArray: Float32Array | Float32Array, reference: Float32Array | Float32Array, fftSize: number, offset: number): FFTResult {\n    const dataPadded = Float32Array.from({ length: fftSize }, () => 0);\n    const referencePadded = Float32Array.from({ length: fftSize }, () => 0);\n\n    if (offset >= 0) {\n        // copy reference into referencePadded starting at 'offset'\n        const refLen = Math.min(reference.length, Math.max(0, fftSize - offset));\n        for (let i = 0; i < refLen; i++) {\n            referencePadded[offset + i] = reference[i];\n        }\n        // copy dataArray into dataPadded starting at 0\n        const dataLen = Math.min((dataArray as Float32Array).length, fftSize);\n        for (let i = 0; i < dataLen; i++) {\n            dataPadded[i] = (dataArray as Float32Array)[i];\n        }\n    } else {\n        // offset < 0: copy reference starting at 0\n        const refLen = Math.min(reference.length, fftSize);\n        for (let i = 0; i < refLen; i++) {\n            referencePadded[i] = reference[i];\n        }\n        // place dataArray into dataPadded starting at -offset\n        const start = -offset;\n        const dataLen = Math.min((dataArray as Float32Array).length, Math.max(0, fftSize - start));\n        for (let i = 0; i < dataLen; i++) {\n            dataPadded[start + i] = (dataArray as Float32Array)[i];\n        }\n    }\n\n    //const rmss = rms(referencePadded);\n    const reference_ = computeFFT(referencePadded);  // Avoid log(0)\n    const signal_ = computeFFT(dataPadded);\n    const signalMags = signal_.magnitude.map(v => 20 * Math.log10(v === 0 ? 1e-20 : v));\n    const referenceMags = reference_.magnitude.map(v => 20 * Math.log10(v === 0 ? 1e-20 : v));\n    const h = referenceMags.map((v, i) => signalMags[i] - v); // dB difference\n    const frequency = linspace(0, 48000 / 2, h.length);\n\n    // For phase, align the reference and signal using a fixed offset (26718 samples for 1m @ 340m/s and 48kHz)\n    // This is a hack to get a reasonable phase response for the measurement setup\n    // In a real application, use cross-correlation to find the delay between signals\n\n    const i_50 = closest(50, frequency); // Example usage of closest function\n    const phase_signal = signal_.phase;\n    const phase_reference = reference_.phase;\n    // phase difference (unwrap phases first)\n    const sphase = unwrapPhase(phase_signal.map((v, i) => v - phase_reference[i])); // phase difference in radians\n    const correction = (Math.floor(sphase[i_50] / (2 * Math.PI) + 0.5)) * (2 * Math.PI);\n    const phase = sphase.map(v => (v - correction)); // relative to 50 Hz\n\n    // simple phase unwrapping (returns Float32Array)\n    function unwrapPhase(phases: Float32Array): Float32Array {\n        const N = phases.length;\n        const out = Float32Array.from({ length: N }, () => 0);\n        if (N === 0) return out;\n        out[0] = phases[0];\n        let offset = 0;\n        const theta = Math.PI; // unwrapping threshold\n        for (let i = 1; i < N; i++) {\n            let delta = phases[i] - phases[i - 1];\n            if (delta > theta) {\n                offset -= 2 * Math.PI;\n            } else if (delta < -theta) {\n                offset += 2 * Math.PI;\n            }\n            out[i] = phases[i] + offset;\n        }\n        return out;\n    }\n\n    return {\n        frequency,\n        magnitude: h,\n        phase,\n        fftSize\n    };\n}\n\nexport function computeFFTFromIR(ir: ImpulseResponseResult, f_phase_wrap: number = 1000): FFTResult {\n    const fftSize = nextPow2(ir.ir.length);\n    console.log(`Computing FFT from IR with size ${fftSize}`);\n    \n    const fft = new FFT(fftSize);\n    const out = Float32Array.from(fft.createComplexArray());\n    if (ir.ir_complex[1] === 0) {\n        console.log(\"IR is in real format, converting to complex\");\n        // real IR, convert to complex\n        const frame = Float32Array.from({ length: fftSize }, () => 0);\n        for (let i = 0; i < fftSize; i++) {\n            frame[i] = (ir.ir_complex[2 * i] || 0);\n        }\n        fft.realTransform(out, frame);\n    } else {\n        fft.transform(out, ir.ir_complex);\n    }\n\n    const magnitude = Float32Array.from({ length: fftSize / 2 }, () => 0);\n    const phase = Float32Array.from({ length: fftSize / 2 }, () => 0);\n    \n    for (let i = 0; i < fftSize / 2; i++) {\n        const re = out[2 * i];\n        const im = out[2 * i + 1];\n        magnitude[i] = abs(re, im);\n        phase[i] = Math.atan2(im, re); // phase in radians, range [-PI, PI].\n    }\n    const frequency = linspace(0, 48000 / 2, magnitude.length);\n\n    const i_norm = closest(f_phase_wrap, frequency); // Example usage of closest function\n    // phase difference (unwrap phases first)\n    const unwraped_phase = unwrapPhase(phase); // phase difference in radians\n    const correction = (Math.floor(unwraped_phase[i_norm] / (2 * Math.PI) + 0.5)) * (2 * Math.PI);\n    const corrected_unwraped_phase = unwraped_phase.map(v => (v - correction)); // relative to 50 Hz\n\n    // simple phase unwrapping (returns Float32Array)\n    function unwrapPhase(phases: Float32Array): Float32Array {\n        const N = phases.length;\n        const out = Float32Array.from({ length: N }, () => 0);\n        if (N === 0) return out;\n        out[0] = phases[0];\n        let offset = 0;\n        for (let i = 1; i < N; i++) {\n            let delta = phases[i] - phases[i - 1];\n            if (delta > Math.PI) {\n                offset -= 2 * Math.PI;\n            } else if (delta < -Math.PI) {\n                offset += 2 * Math.PI;\n            }\n            out[i] = phases[i] + offset;\n        }\n        return out;\n    }\n\n    return {\n        frequency,\n        magnitude,\n        phase: corrected_unwraped_phase.map(v => v / Math.PI * 180),\n        peakAt: ir.peakAt,\n        sampleRate: ir.sampleRate,\n        fftSize: fftSize,\n    };\n}\n\nexport function groupDelays(fftData: FFTResult, normalizeAt: number = 1000): Float32Array {\n    const { frequency, phase, peakAt } = fftData;\n    const N = frequency.length;\n    const groupDelay = Float32Array.from({ length: N }, () => 0);\n\n    // Numerical differentiation of unwrapped phase\n    for (let i = 1; i < N - 1; i++) {\n        const dPhase = (phase[i] - phase[i - 1]);\n        const dFreq = (frequency[i] - frequency[i - 1]);\n        groupDelay[i] = -dPhase / dFreq / 360; // in seconds\n    }\n    // Edge cases\n    groupDelay[0] = groupDelay[1];\n    groupDelay[N - 1] = groupDelay[N - 2];\n\n    // Normalize group delay at specified frequency and add delay to make it zero there.\n    const normIdx = closest(normalizeAt, frequency);\n    const delayAtNorm = groupDelay[normIdx];\n    for (let i = 0; i < N; i++) {\n        groupDelay[i] = (groupDelay[i] - delayAtNorm); // assuming 48kHz sample rate, s => ms.\n    }\n\n    return groupDelay;\n}\n\nexport const A_WEIGHTING_COEFFICIENTS: [Float32Array, Float32Array] = [\n    Float32Array.from([0.234301792299513, -0.468603584599026, -0.234301792299513, 0.937207169198054, -0.234301792299515, -0.468603584599025, 0.234301792299513]),\n    Float32Array.from([1.000000000000000, -4.113043408775871, 6.553121752655047, -4.990849294163381, 1.785737302937573, -0.246190595319487, 0.011224250033231]),\n];\n// Coefficients for K-weighting filter (pre-emphasis and high-frequency shelving)\n// From ITU-R BS.1770-4, Table 1\n// https://www.itu.int/dms_pubrec/itu-r/rec/bs/r-rec-bs.1770-2-201103-s!!pdf-e.pdf\nexport const K_WEIGHTING_COEFFICIENTS_PRE: [Float32Array, Float32Array] = [\n    Float32Array.from([1.53512485958697, -2.69169618940638, 1.19839281085285]),\n    Float32Array.from([1, -1.69065929318241, 0.73248077421585])\n];\n\nexport const K_WEIGHTING_COEFFICIENTS_RLB: [Float32Array, Float32Array] = [\n    Float32Array.from([1.0, -2.0, 1.0]),\n    Float32Array.from([1, -1.99004745483398, 0.99007225036621])\n];\n\nexport function applyAWeightingToBuffer(buffer: Float32Array, zi: Float32Array): Float32Array {\n    const b = A_WEIGHTING_COEFFICIENTS[0];\n    const a = A_WEIGHTING_COEFFICIENTS[1];\n    const output = Float32Array.from({ length: buffer.length }, () => 0);\n    for (let n = 0; n < buffer.length; n++) {\n        output[n] = b[0] * buffer[n] + zi[0];\n        for (let i = 1; i < b.length; i++) {\n            zi[i - 1] = b[i] * buffer[n] + zi[i] - a[i] * output[n];\n        }\n    }\n    return output;\n}\n\nexport function gateBuffer(buffer: Float32Array, sampleRate: number, thresholdDb: number = -70, blockMs: number = 400, overlap: number = 0.75): Float32Array {\n    const blockSize = Math.floor((blockMs / 1000) * sampleRate);\n    const hopSize = Math.floor(blockSize * (1 - overlap));\n    const threshold = dbToLinear(thresholdDb);\n\n    const gated = Float32Array.from({ length: buffer.length }, () => 0);\n    let i = 0;\n\n    while (i < buffer.length) {\n        const start = i;\n        const end = Math.min(i + blockSize, buffer.length);\n        const block = buffer.slice(start, end);\n        const blockRms = rms(block);\n\n        if (blockRms >= threshold) {\n            // copy block into gated at position 'start'\n            for (let j = 0; j < block.length; j++) {\n                gated[start + j] = block[j];\n            }\n        }\n        // else: leave zeros (gate closed)\n\n        i += hopSize;\n    }\n\n    return gated;\n}\n\nexport const audio = {\n    loadAudioFile,\n    chirp,\n    computeFFT,\n    smoothFFT,\n    fftCorrelation,\n    fftConvolve,\n    twoChannelImpulseResponse,\n    computeFFTFromIR,\n    twoChannelFFT,\n    groupDelays,\n    applyAWeightingToBuffer,\n    gateBuffer,\n};\n\nexport default audio;","// windows.ts\r\n// Various window functions for signal processing.\r\n\r\nexport type WindowType = 'hanning' | 'hamming' | 'blackman' | 'rectangular' | 'gamma';\r\n\r\nfunction hanningWindow(length: number): Float32Array {\r\n    const window = new Float32Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n        window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (length - 1)));\r\n    }\r\n    return window;\r\n}\r\n\r\nfunction hammingWindow(length: number): Float32Array {\r\n    const window = new Float32Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n        window[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (length - 1));\r\n    }\r\n    return window;\r\n}\r\n\r\nfunction blackmanWindow(length: number): Float32Array {\r\n    const window = new Float32Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n        window[i] = (0.42 - 0.5 * Math.cos(2 * Math.PI * i / (length - 1)) + 0.08 * Math.cos(4 * Math.PI * i / (length - 1)));\r\n    }\r\n    return window;\r\n}\r\n\r\nfunction equirippleWindow(length: number, attenuation: number = 60): Float32Array {\r\n    // Dolph-Chebyshev window (approximate equiripple)\r\n    // attenuation: sidelobe attenuation in dB\r\n    // Reference: https://en.wikipedia.org/wiki/Chebyshev_window\r\n\r\n    if (length < 2) return new Float32Array([1]);\r\n\r\n    const M = length - 1;\r\n    const tg = Math.cosh(1 / M * Math.acosh(Math.pow(10, attenuation / 20)));\r\n    const window = new Float32Array(length);\r\n\r\n    // Precompute Chebyshev polynomial coefficients\r\n    for (let n = 0; n <= M; n++) {\r\n        let sum = 0;\r\n        for (let k = 0; k <= M; k++) {\r\n            const x = tg * Math.cos(Math.PI * k / M);\r\n            // Chebyshev polynomial of degree M\r\n            let Tm: number;\r\n            if (Math.abs(x) <= 1) {\r\n                Tm = Math.cos(M * Math.acos(x));\r\n            } else {\r\n                Tm = Math.cosh(M * Math.acosh(x));\r\n            }\r\n            const coeff = ((k === 0 || k === M) ? 0.5 : 1) * Tm * Math.cos(Math.PI * n * (k - M / 2) / M);\r\n            sum += coeff;\r\n        }\r\n        window[n] = sum;\r\n    }\r\n\r\n    return window;\r\n}\r\n\r\nfunction rectangularWindow(length: number): Float32Array {\r\n    const window = new Float32Array(length);\r\n    window.fill(1);\r\n    return window;\r\n}\r\n\r\nexport function getSelectedWindow(windowType: WindowType, length: number): Float32Array {\r\n    const type = windowType;\r\n    let window = new Float32Array(length);\r\n    let wcf = 1; // Window correction factor\r\n    if (type === 'hanning') { window = hanningWindow(length); wcf = 2.000; }\r\n    if (type === 'hamming') { window = hammingWindow(length); wcf = 1.852; }\r\n    if (type === 'blackman') { window = blackmanWindow(length); wcf = 2.381; }\r\n    if (type === 'rectangular') { window = rectangularWindow(length); wcf = 1.000; }\r\n    window = window.map(v => v / wcf); // Scale to max 2 for better visualization\r\n\r\n    return window;\r\n}\r\n\r\nexport function tukeyWindow(length: number, alpha: number = 0.5): Float32Array {\r\n    if (length < 1) return new Float32Array(0);\r\n    if (length === 1) return new Float32Array([1]);\r\n    const N = length;\r\n    const w = new Float32Array(N);\r\n\r\n    if (alpha <= 0) {\r\n        w.fill(1); // rectangular\r\n        return w;\r\n    }\r\n    if (alpha >= 1) {\r\n        // Equivalent to a Hann/Hanning window\r\n        for (let i = 0; i < N; i++) {\r\n            w[i] = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (N - 1)));\r\n        }\r\n        return w;\r\n    }\r\n\r\n    const edge = alpha * (N - 1) / 2;\r\n    const denom = alpha * (N - 1);\r\n\r\n    for (let n = 0; n < N; n++) {\r\n        if (n <= edge) {\r\n            w[n] = 0.5 * (1 + Math.cos(Math.PI * ((2 * n) / denom - 1)));\r\n        } else if (n >= (N - 1 - edge)) {\r\n            // symmetric tail\r\n            const m = N - 1 - n;\r\n            w[n] = 0.5 * (1 + Math.cos(Math.PI * ((2 * m) / denom - 1)));\r\n        } else {\r\n            w[n] = 1;\r\n        }\r\n    }\r\n\r\n    return w;\r\n}","import { closest, linspace, max } from './math';\nimport { getSelectedWindow } from './windows';\nimport { fftConvolve } from './audio';\nimport { ImpulseResponseResult } from './audio';\n\nexport class Farina {\n    /* Farina deconvolution implementation according to the Python implementation. */\n    constructor(stimulus: Float32Array, f_start: number = 50, f_stop: number = 22800, fs: number = 48000) {\n        this.f_start = f_start;\n        this.f_stop = f_stop;\n        this.fs = fs;\n        this.stimulus = stimulus;\n        this.duration = this.stimulus.length / this.fs;\n    }\n\n    f_start: number;\n    f_stop: number;\n    fs: number;\n    stimulus: Float32Array;\n    deconvolved: Float32Array = Float32Array.from([]);\n    duration: number;\n\n    lag_of_harmonic(n: number) {\n        return this.ell() * Math.log(n);\n    }\n\n    margin_of_harmonic(n: number) {\n        return this.ell() * Math.log(n + 1) - this.ell() * Math.log(n);\n    }\n\n    max_safe_harmonic(window_size: number): number {\n        const t: number[] = [];\n        for (let n = 1; n < 1000; n++) {\n            if (this.margin_of_harmonic(n) > window_size) {\n                t.push(this.margin_of_harmonic(n));\n            }\n        }\n        return t.length < 999 ? t.length : 0;\n    }\n\n    ell(): number {\n        return this.duration / Math.log(this.f_stop / this.f_start);\n    }\n\n    rate(length: number): number {\n        return 1 / this.f_start * Math.PI * Math.round(length * this.f_start / Math.log2(this.f_stop / this.f_start));\n    }\n\n    instant(): number {\n        // Lag between the start of the sweep and the stimulus.\n        return closest(100000000, this.deconvolved);\n    }\n\n    window(signal: Float32Array, at: number, length: number): Float32Array {\n        const size = Math.floor(length * this.fs);\n        const window: Float32Array = getSelectedWindow('hanning', size);\n        const sig = this.deconvolution(signal);\n        const si = sig.slice(at - size / 2, at + size / 2);\n        const w = Float32Array.from({ length: size }, () => 0);\n        return si;\n        if (si.length === window.length) {\n            for (let i = 0; i < window.length; i++) {\n                w[i] = window[i] * si[i];\n            }\n            return w;\n        } else {\n            return Float32Array.from({ length: window.length }, () => 0); // zeros\n        }        \n    }\n\n    deconvolution(signal: Float32Array, customLength: number = 5.5): Float32Array {\n        const n: Float32Array = linspace(0, this.stimulus.length - 1, this.stimulus.length);\n        const k: Float32Array = n.map(v => Math.exp(v / this.ell() / this.fs)); // simplified for first element\n\n        const inv_stimulus = this.stimulus.slice().reverse().map ((v, i) => v / k[i]);\n\n        const deconvolved: Float32Array = fftConvolve(signal, inv_stimulus, 'same').slice().reverse();\n        const norm = max(fftConvolve(this.stimulus, inv_stimulus, 'same').map(v => Math.abs(v)));\n\n        this.deconvolved = deconvolved;\n        return deconvolved.map(v => v / norm);\n    }\n    \n    \n}\n\nexport function FarinaImpulseResponse(y: Float32Array, x: Float32Array, customLength: number = 5.5): ImpulseResponseResult {\n    const farina = new Farina(x, 2, 20000, 48000);\n\n    const measurementResponse = farina.deconvolution(y, customLength);\n    console.log(farina.max_safe_harmonic(0.1));\n    \n    const peakAt = farina.instant();\n    console.log('peakAt', peakAt);\n    \n    const s: Float32Array = farina.window(y, (measurementResponse.length - 1) / 2, 0.1); // 250 ms windowed IR\n\n    const ir = Float32Array.from({ length: s.length }, () => 0);\n    for (let i = 0; i < s.length; i++) {\n        ir[i] = s[i];\n    }\n\n    const ir_complex = Float32Array.from({ length: s.length * 2 }, () => 0);\n    for (let i = 0; i < s.length; i++) {\n            ir_complex[2 * i] = s[i];\n            ir_complex[2 * i + 1] = 0;\n    }\n\n    return {\n        ir,\n        ir_complex,\n        t: linspace((-measurementResponse.length - 1) / 2 / 48000, (measurementResponse.length - 1) / 2 / 48000, measurementResponse.length),\n        peakAt,\n        sampleRate: 48000,\n        fftSize: measurementResponse.length,\n    };\n}","// IndexedDB-backed storage helpers\nfunction openIDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n        const req = indexedDB.open('dunkadunka-storage', 1);\n        req.onupgradeneeded = () => {\n            const db = req.result;\n            if (!db.objectStoreNames.contains('kv')) {\n                db.createObjectStore('kv', { keyPath: 'key' });\n            }\n        };\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n    });\n}\n\nasync function setItem(key: string, value: string): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.put({ key, value });\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n        // mirror to sessionStorage for synchronous reads elsewhere\n        try { setItem(key, value); } catch { /* ignore */ }\n    } catch (e) {\n        console.error('setItem(idb) failed', e);\n    }\n}\n\nasync function getItem(key: string): Promise<string | null> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readonly');\n        const store = tx.objectStore('kv');\n        const req = store.get(key);\n        const res = await new Promise<any>((resolve, reject) => {\n            req.onsuccess = () => resolve(req.result);\n            req.onerror = () => reject(req.error);\n        });\n        return res?.value ?? null;\n    } catch (e) {\n        console.error('getItem(idb) failed', e);\n        return null;\n    }\n}\n\nasync function removeItem(key: string): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.delete(key);\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n    } catch (e) {\n        console.error('removeItem(idb) failed', e);\n    }\n}\n\nasync function clearStorage(): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.clear();\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n        // also clear sessionStorage\n        try { sessionStorage.clear(); } catch { /* ignore */ }\n    } catch (e) {\n        console.error('clearStorage(idb) failed', e);\n    }\n}\n\nasync function dumpStorage(): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readonly');\n        const store = tx.objectStore('kv');\n        const req = store.openCursor();\n        req.onsuccess = (event) => {\n            const cursor = (event.target as IDBRequest).result;\n            if (cursor) {\n                console.log(`Key: ${cursor.key}, Value: ${cursor.value.value}`);\n                cursor.continue();\n            }\n        };\n        req.onerror = () => {\n            console.error('dumpStorage(idb) failed', req.error);\n        };\n    } catch (e) {\n        console.error('dumpStorage(idb) failed', e);\n    }\n}\n\nexport const storage = {\n    setItem,\n    getItem,\n    removeItem,\n    clearStorage,\n    dumpStorage\n};","// Device settings for audio input/output selection\n\nconst INPUT_KEY = 'preferredAudioInputId';\nconst OUTPUT_KEY = 'preferredAudioOutputId';\n\nexport function openDeviceSettings(): void {\n    const modal = document.getElementById('deviceSettingsModal');\n    if (modal) {\n        modal.style.display = 'flex';\n        initDeviceSettings();\n    }\n}\n\nexport function closeDeviceSettings(): void {\n    const modal = document.getElementById('deviceSettingsModal');\n    if (modal) {\n        modal.style.display = 'none';\n    }\n}\n\nasync function ensureDeviceAccess(): Promise<void> {\n    try {\n        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;\n        // Request permission so labels are revealed\n        await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n    } catch (_) {\n        // Permission may be denied; device labels may be blank\n    }\n}\n\nexport async function refreshAudioDeviceList(): Promise<void> {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n        console.warn('MediaDevices API not available');\n        return;\n    }\n\n    await ensureDeviceAccess();\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const inputSel = document.getElementById('inputDeviceSelect') as HTMLSelectElement | null;\n    const outputSel = document.getElementById('outputDeviceSelect') as HTMLSelectElement | null;\n\n    if (!inputSel || !outputSel) return;\n\n    inputSel.innerHTML = '<option value=\"\">Default input</option>';\n    outputSel.innerHTML = '<option value=\"\">Default output</option>';\n\n    const inputId = localStorage.getItem(INPUT_KEY) || '';\n    const outputId = localStorage.getItem(OUTPUT_KEY) || '';\n\n    devices.forEach(d => {\n        if (d.kind === 'audioinput') {\n            const opt = document.createElement('option');\n            opt.value = d.deviceId;\n            opt.textContent = d.label || `Microphone (${d.deviceId.slice(0, 8)})`;\n            if (d.deviceId === inputId) opt.selected = true;\n            inputSel.appendChild(opt);\n        } else if (d.kind === 'audiooutput') {\n            const opt = document.createElement('option');\n            opt.value = d.deviceId;\n            opt.textContent = d.label || `Speaker (${d.deviceId.slice(0, 8)})`;\n            if (d.deviceId === outputId) opt.selected = true;\n            outputSel.appendChild(opt);\n        }\n    });\n\n    const note = document.getElementById('sinkSupportNote');\n    if (note) {\n        const sinkSupported = typeof HTMLMediaElement !== 'undefined' && 'setSinkId' in HTMLMediaElement.prototype;\n        note.textContent = sinkSupported\n            ? 'Output routing supported on this browser.'\n            : 'Output routing (setSinkId) not supported by this browser.';\n    }\n}\n\nasync function applyOutputDevice(deviceId: string): Promise<void> {\n    const router = document.getElementById('appOutputRouter') as HTMLAudioElement | null;\n    if (!router) return;\n\n    if ('setSinkId' in HTMLMediaElement.prototype) {\n        try {\n            await (router as any).setSinkId(deviceId || '');\n        } catch (e) {\n            console.warn('Failed to set sinkId:', e);\n        }\n    }\n}\n\nexport function saveDeviceSelections(): void {\n    const inputSel = document.getElementById('inputDeviceSelect') as HTMLSelectElement | null;\n    const outputSel = document.getElementById('outputDeviceSelect') as HTMLSelectElement | null;\n\n    if (!inputSel || !outputSel) return;\n\n    localStorage.setItem(INPUT_KEY, inputSel.value || '');\n    localStorage.setItem(OUTPUT_KEY, outputSel.value || '');\n\n    applyOutputDevice(outputSel.value || '');\n    closeDeviceSettings();\n}\n\nasync function initDeviceSettings(): Promise<void> {\n    await refreshAudioDeviceList();\n\n    // Persist immediately when changed\n    const inputSel = document.getElementById('inputDeviceSelect') as HTMLSelectElement | null;\n    const outputSel = document.getElementById('outputDeviceSelect') as HTMLSelectElement | null;\n\n    if (!inputSel || !outputSel) return;\n\n    inputSel.onchange = () => {\n        localStorage.setItem(INPUT_KEY, inputSel.value || '');\n    };\n    outputSel.onchange = () => {\n        localStorage.setItem(OUTPUT_KEY, outputSel.value || '');\n        applyOutputDevice(outputSel.value || '');\n    };\n}\n\n// Update list if devices change while modal is open\nif (navigator.mediaDevices && 'ondevicechange' in navigator.mediaDevices) {\n    navigator.mediaDevices.addEventListener('devicechange', () => {\n        const modal = document.getElementById('deviceSettingsModal');\n        if (modal && modal.style.display === 'flex') {\n            refreshAudioDeviceList();\n        }\n    });\n}\n\n// Apply preferred output on load (best-effort)\ndocument.addEventListener('DOMContentLoaded', () => {\n    const outId = localStorage.getItem(OUTPUT_KEY);\n    if (outId) applyOutputDevice(outId);\n});\n\n// Export functions to global scope for inline onclick handlers\n(window as any).openDeviceSettings = openDeviceSettings;\n(window as any).closeDeviceSettings = closeDeviceSettings;\n(window as any).refreshAudioDeviceList = refreshAudioDeviceList;\n(window as any).saveDeviceSelections = saveDeviceSelections;\n","import { Audio, computeFFT, computeFFTFromIR, db, FFTResult, groupDelays, ImpulseResponseResult, rms, smoothFFT, twoChannelImpulseResponse } from \"./audio\";\nimport { FarinaImpulseResponse } from \"./farina\";\nimport { storage } from \"./storage\";\nimport { audio } from \"./audio\";\nimport { createWaveformEditor, WaveformEditor } from \"./waveform_editor\";\nimport \"./device-settings\";\n\nconsole.debug(\"App module loaded\");\n\nconst root = document.documentElement;\nconst uiColor = \"#0366d6\";\nroot.style.setProperty('--color', uiColor);\n\nlet tabCounter = 0;\nconst tabsContainer = document.getElementById('tabs-outer') as HTMLElement;\nconst tabsInnerContainer = document.getElementById('tabs') as HTMLElement;\nconst tabContents = document.getElementById('tab-contents') as HTMLElement;\nconst responseFileInput = document.getElementById('responseFile') as HTMLInputElement;\nconst referenceFileInput = document.getElementById('referenceFile') as HTMLInputElement;\nconst analyzeBtn = document.getElementById('analyzeBtn') as HTMLButtonElement;\n\n// Enable analyze button when response file is selected\nresponseFileInput.addEventListener('change', () => {\n    analyzeBtn.disabled = !responseFileInput.files?.length;\n});\n\n// ============================================================================\n// Acquisition Tab Functionality\n// ============================================================================\n\ninterface AcquisitionState {\n    audioContext: AudioContext | null;\n    mediaRecorder: MediaRecorder | null;\n    recordedChunks: Blob[];\n    oscillatorNode: OscillatorNode | null;\n    playbackSource: AudioBufferSourceNode | null;\n    isRecording: boolean;\n}\n\nconst acquisitionState: AcquisitionState = {\n    audioContext: null,\n    mediaRecorder: null,\n    recordedChunks: [],\n    oscillatorNode: null,\n    playbackSource: null,\n    isRecording: false\n};\n\nconst startBtn = document.getElementById('startBtn') as HTMLButtonElement;\nconst stopBtn = document.getElementById('stopBtn') as HTMLButtonElement;\nconst playBtn = document.getElementById('playBtn') as HTMLButtonElement;\nconst stopPlayBtn = document.getElementById('stopPlayBtn') as HTMLButtonElement;\nconst sweepStartFreqInput = document.getElementById('sweepStartFreq') as HTMLInputElement;\nconst sweepEndFreqInput = document.getElementById('sweepEndFreq') as HTMLInputElement;\nconst sweepDurationInput = document.getElementById('sweepDuration') as HTMLInputElement;\nconst recordingStatusEl = document.getElementById('recordingStatus') as HTMLElement;\nconst recordingMeterEl = document.getElementById('recordingMeter') as HTMLElement;\nconst recordingVisualizationEl = document.getElementById('recordingVisualization') as HTMLElement;\nconst recordedAudioContainer = document.getElementById('recordedAudioContainer') as HTMLElement;\nconst recordedAudioEl = document.getElementById('recordedAudio') as HTMLAudioElement;\nconst analyzeRecordingBtn = document.getElementById('analyzeRecordingBtn') as HTMLButtonElement;\nconst viewWaveformBtn = document.getElementById('viewWaveformBtn') as HTMLButtonElement;\nconst channelSelectionContainer = document.getElementById('channelSelectionContainer') as HTMLElement;\nconst channelSelect = document.getElementById('channelSelect') as HTMLSelectElement;\n\nasync function initializeAudioContext(): Promise<AudioContext> {\n    if (!acquisitionState.audioContext) {\n        acquisitionState.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n    }\n    if (acquisitionState.audioContext.state === 'suspended') {\n        await acquisitionState.audioContext.resume();\n    }\n    return acquisitionState.audioContext;\n}\n\nasync function detectAndSetupChannels(): Promise<void> {\n    try {\n        // Request audio input to check channel count\n        const stream = await navigator.mediaDevices.getUserMedia({ \n            audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } \n        });\n        \n        const audioContext = await initializeAudioContext();\n        const analyser = audioContext.createAnalyser();\n        const source = audioContext.createMediaStreamSource(stream);\n        source.connect(analyser);\n\n        // Get channel count from the stream\n        const channelCount = source.mediaStream.getAudioTracks()[0].getSettings()?.channelCount || 1;\n        \n        // Stop the stream as we only need it for channel detection\n        stream.getTracks().forEach(track => track.stop());\n\n        // Populate channel selection\n        channelSelect.innerHTML = '';\n        for (let i = 0; i < channelCount; i++) {\n            const option = document.createElement('option');\n            option.value = i.toString();\n            const channelNames = ['Left', 'Right', 'Center', 'LFE', 'Back Left', 'Back Right'];\n            option.textContent = `Channel ${i + 1}${channelNames[i] ? ` (${channelNames[i]})` : ''}`;\n            channelSelect.appendChild(option);\n        }\n\n        // Show channel selection only if more than 1 channel\n        if (channelCount > 1) {\n            channelSelectionContainer.style.display = 'flex';\n        } else {\n            channelSelectionContainer.style.display = 'none';\n        }\n    } catch (error) {\n        console.error('Error detecting channels:', error);\n        channelSelectionContainer.style.display = 'none';\n    }\n}\n\n// Detect channels when the acquisition tab is opened\ntabsContainer.addEventListener('click', (e: MouseEvent) => {\n    const target = e.target as HTMLElement;\n    if (target.classList.contains('tab') && target.dataset.tab === 'acquisition') {\n        detectAndSetupChannels();\n    }\n});\n\nasync function startRecordingAndPlayback(): Promise<void> {\n    try {\n        // Initialize audio context and get microphone stream\n        const audioContext = await initializeAudioContext();\n        const stream = await navigator.mediaDevices.getUserMedia({ \n            audio: { \n                echoCancellation: false, \n                noiseSuppression: false, \n                autoGainControl: false \n            } \n        });\n        \n        // Create media recorder\n        acquisitionState.recordedChunks = [];\n        acquisitionState.mediaRecorder = new MediaRecorder(stream);\n        acquisitionState.isRecording = true;\n\n        acquisitionState.mediaRecorder.ondataavailable = (e: BlobEvent) => {\n            acquisitionState.recordedChunks.push(e.data);\n        };\n\n        acquisitionState.mediaRecorder.onstop = async () => {\n            const recordedBlob = new Blob(acquisitionState.recordedChunks, { type: 'audio/wav' });\n            const url = URL.createObjectURL(recordedBlob);\n            recordedAudioEl.src = url;\n            recordedAudioContainer.style.display = 'block';\n            recordingVisualizationEl.style.display = 'none';\n        };\n\n        // Generate and play sweep\n        const startFreq = parseFloat(sweepStartFreqInput.value);\n        const endFreq = parseFloat(sweepEndFreqInput.value);\n        const duration = parseFloat(sweepDurationInput.value);\n        \n        // Pre and post recording buffers (in seconds)\n        const preRecordTime = 0.5;  // Start recording 0.5s before playback\n        const postRecordTime = 1.0; // Continue recording 1s after playback ends\n        const totalRecordTime = preRecordTime + duration + postRecordTime;\n\n        const [sweepSignal, , ] = audio.chirp(startFreq, endFreq, duration);\n\n        // Create audio buffer from sweep signal\n        const audioBuffer = audioContext.createBuffer(1, sweepSignal.length, audioContext.sampleRate);\n        const channelData = audioBuffer.getChannelData(0);\n        channelData.set(sweepSignal);\n\n        // Create gain nodes for monitoring\n        const sourceGain = audioContext.createGain();\n        sourceGain.gain.value = 0.5;\n\n        // Start recording\n        recordingStatusEl.textContent = `Recording for ${totalRecordTime.toFixed(1)}s...`;\n        recordingVisualizationEl.style.display = 'block';\n        acquisitionState.mediaRecorder.start();\n\n        // Update UI\n        startBtn.disabled = true;\n        stopBtn.disabled = false;\n        playBtn.disabled = true;\n        sweepStartFreqInput.disabled = true;\n        sweepEndFreqInput.disabled = true;\n        sweepDurationInput.disabled = true;\n\n        // Start playback after pre-record time\n        setTimeout(() => {\n            acquisitionState.playbackSource = audioContext.createBufferSource();\n            acquisitionState.playbackSource.buffer = audioBuffer;\n            acquisitionState.playbackSource.connect(sourceGain);\n            sourceGain.connect(audioContext.destination);\n            acquisitionState.playbackSource.start();\n        }, preRecordTime * 1000);\n\n        // Stop recording after total time (pre + sweep + post)\n        setTimeout(() => {\n            stopRecording();\n        }, totalRecordTime * 1000);\n\n    } catch (error) {\n        console.error('Error starting recording:', error);\n        recordingStatusEl.textContent = `Error: ${(error as Error).message}`;\n        recordingStatusEl.style.color = '#d73a49';\n    }\n}\n\nasync function playbackOnly(): Promise<void> {\n    try {\n        const audioContext = await initializeAudioContext();\n        \n        const startFreq = parseFloat(sweepStartFreqInput.value);\n        const endFreq = parseFloat(sweepEndFreqInput.value);\n        const duration = parseFloat(sweepDurationInput.value);\n\n        const [sweepSignal] = audio.chirp(startFreq, endFreq, duration);\n\n        // Create audio buffer from sweep signal\n        const audioBuffer = audioContext.createBuffer(1, sweepSignal.length, audioContext.sampleRate);\n        const channelData = audioBuffer.getChannelData(0);\n        channelData.set(sweepSignal);\n\n        // Create gain node\n        const sourceGain = audioContext.createGain();\n        sourceGain.gain.value = 0.5;\n\n        // Connect and start playback\n        acquisitionState.playbackSource = audioContext.createBufferSource();\n        acquisitionState.playbackSource.buffer = audioBuffer;\n        acquisitionState.playbackSource.connect(sourceGain);\n        sourceGain.connect(audioContext.destination);\n        acquisitionState.playbackSource.start();\n\n        recordingStatusEl.textContent = `Playing sweep...`;\n        recordingStatusEl.style.color = '#0366d6';\n\n        playBtn.disabled = true;\n        stopPlayBtn.disabled = false;\n\n        setTimeout(() => {\n            stopPlayback();\n        }, (duration + 0.5) * 1000);\n\n    } catch (error) {\n        console.error('Error during playback:', error);\n        recordingStatusEl.textContent = `Error: ${(error as Error).message}`;\n        recordingStatusEl.style.color = '#d73a49';\n    }\n}\n\nfunction stopRecording(): void {\n    if (acquisitionState.mediaRecorder && acquisitionState.isRecording) {\n        acquisitionState.mediaRecorder.stop();\n        acquisitionState.isRecording = false;\n\n        // Stop microphone stream\n        acquisitionState.mediaRecorder.stream.getTracks().forEach(track => track.stop());\n\n        recordingStatusEl.textContent = 'Recording complete. Ready to analyze.';\n        recordingStatusEl.style.color = '#28a745';\n    }\n\n    if (acquisitionState.playbackSource) {\n        acquisitionState.playbackSource.stop();\n    }\n\n    // Update UI\n    startBtn.disabled = false;\n    stopBtn.disabled = true;\n    playBtn.disabled = false;\n    sweepStartFreqInput.disabled = false;\n    sweepEndFreqInput.disabled = false;\n    sweepDurationInput.disabled = false;\n}\n\nfunction stopPlayback(): void {\n    if (acquisitionState.playbackSource) {\n        try {\n            acquisitionState.playbackSource.stop();\n        } catch (e) {\n            // Already stopped\n        }\n    }\n\n    recordingStatusEl.textContent = 'Playback stopped.';\n    playBtn.disabled = false;\n    stopPlayBtn.disabled = true;\n}\n\n// Event listeners for acquisition controls\nstartBtn.addEventListener('click', startRecordingAndPlayback);\nstopBtn.addEventListener('click', stopRecording);\nplayBtn.addEventListener('click', playbackOnly);\nstopPlayBtn.addEventListener('click', stopPlayback);\n\nanalyzeRecordingBtn.addEventListener('click', async () => {\n    if (!recordedAudioEl.src) return;\n\n    try {\n        const audioContext = await initializeAudioContext();\n        const response = await fetch(recordedAudioEl.src);\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        \n        // Extract the selected channel\n        const selectedChannel = parseInt(channelSelect.value, 10);\n        let recordedAudio: Audio;\n        \n        if (audioBuffer.numberOfChannels > 1 && selectedChannel < audioBuffer.numberOfChannels) {\n            // Multi-channel recording: extract selected channel\n            const channelData = audioBuffer.getChannelData(selectedChannel);\n            recordedAudio = Audio.fromSamples(channelData, audioBuffer.sampleRate);\n        } else {\n            // Single channel or default to first channel\n            recordedAudio = Audio.fromAudioBuffer(audioBuffer);\n        }\n\n        // Generate the chirp sweep as reference data\n        const startFreq = parseFloat(sweepStartFreqInput.value);\n        const endFreq = parseFloat(sweepEndFreqInput.value);\n        const duration = parseFloat(sweepDurationInput.value);\n\n        const [sweepSignal] = audio.chirp(startFreq, endFreq, duration);\n        const referenceAudio = Audio.fromSamples(sweepSignal, audioContext.sampleRate);\n\n        // Add timestamp to recording name\n        const now = new Date();\n        const dateTime = now.toLocaleString('sv-SE', { \n            year: '2-digit', \n            month: '2-digit', \n            day: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit',\n            second: '2-digit',\n            hour12: false\n        }).replace(',', '');\n        const recordingName = `${dateTime}`;\n\n        createAnalysisTab(\n            recordedAudio.applyGain(1 / 16384),\n            referenceAudio.applyGain(1 / 16384),\n            recordingName,\n            `${startFreq}-${endFreq}Hz`\n        );\n    } catch (error) {\n        console.error('Error analyzing recording:', error);\n        alert('Error analyzing recording: ' + (error as Error).message);\n    }\n});\n\nviewWaveformBtn.addEventListener('click', async () => {\n    if (!recordedAudioEl.src) return;\n\n    try {\n        const audioContext = await initializeAudioContext();\n        const response = await fetch(recordedAudioEl.src);\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        \n        // Extract the selected channel\n        const selectedChannel = parseInt(channelSelect.value, 10);\n        let recordedAudio: Audio;\n        \n        if (audioBuffer.numberOfChannels > 1 && selectedChannel < audioBuffer.numberOfChannels) {\n            // Multi-channel recording: extract selected channel\n            const channelData = audioBuffer.getChannelData(selectedChannel);\n            recordedAudio = Audio.fromSamples(channelData, audioBuffer.sampleRate);\n        } else {\n            // Single channel or default to first channel\n            recordedAudio = Audio.fromAudioBuffer(audioBuffer);\n        }\n\n        // Add timestamp to tab name\n        const now = new Date();\n        const dateTime = now.toLocaleString('sv-SE', { \n            year: '2-digit', \n            month: '2-digit', \n            day: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit',\n            second: '2-digit',\n            hour12: false\n        }).replace(',', '');\n        const recordingName = `${dateTime}`;\n\n        // Create analysis tab with only the recorded audio (no reference)\n        createAnalysisTab(\n            recordedAudio.applyGain(1 / 16384),\n            null,\n            recordingName,\n            'Waveform View'\n        );\n    } catch (error) {\n        console.error('Error viewing waveform:', error);\n        alert('Error viewing waveform: ' + (error as Error).message);\n    }\n});\n\n// Save state when the user attempts to close or reload the window\nwindow.addEventListener('beforeunload', (e: BeforeUnloadEvent) => {\n    try {\n        saveState();\n    } catch (err) {\n        console.error('Failed to save state on beforeunload:', err);\n    }\n    // If you want to prompt the user to confirm leaving (browser-dependent), uncomment:\n    // e.preventDefault();\n    // e.returnValue = '';\n});\n\n// Tab switching\ntabsContainer.addEventListener('click', (e: MouseEvent) => {\n    const target = e.target as HTMLElement;\n    \n    if (target.classList.contains('tab-close')) {\n        const tab = target.parentElement as HTMLElement;\n        const tabId = tab.dataset.tab;\n        if (tabId == 'upload') return;\n\n        console.debug('Closing tab', tabId);\n        tab.remove();\n        document.querySelector(`[data-content=\"${tabId}\"]`)?.remove();\n        storage.removeItem(`analysis-${tabId}`).catch(err => console.error('Failed to remove analysis from storage:', err));\n        \n        // Activate upload tab if current was closed\n        if (tab.classList.contains('active')) {\n            switchTab('upload');\n        }\n        saveState();\n        e.stopPropagation();\n    } else if (target.classList.contains('tab')) {\n        const tabId = target.dataset.tab;\n        if (tabId) {\n            switchTab(tabId);\n        }\n    }\n});\n\nfunction switchTab(tabId: string): void {\n    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));\n    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));\n    \n    document.querySelector(`[data-tab=\"${tabId}\"]`)?.classList.add('active');\n    document.querySelector(`[data-content=\"${tabId}\"]`)?.classList.add('active');\n}\n\nanalyzeBtn.addEventListener('click', async () => {\n    const responseFile = responseFileInput.files?.[0];\n    const referenceFile = referenceFileInput.files?.[0];\n\n    if (!responseFile) return;\n\n    analyzeBtn.disabled = true;\n    analyzeBtn.textContent = 'Analyzing...';\n\n    try {\n        const responseData = await audio.loadAudioFile(responseFile);\n        const referenceData = referenceFile ? await audio.loadAudioFile(referenceFile) : null;\n\n       createAnalysisTab(responseData.applyGain(1 / 16384), referenceData ? referenceData.applyGain(1 / 16384) : null, responseFile.name, referenceFile?.name || null);\n    } catch (error) {\n        alert('Error analyzing files: ' + (error as Error).message);\n    } finally {\n        analyzeBtn.disabled = false;\n        analyzeBtn.textContent = 'Analyze Frequency Response';\n    }\n});\n\n\n/**\n * Creates a new analysis tab in the UI and renders magnitude, phase and impulse-response plots for the provided audio.\n *\n * Description:\n * - Performs spectral and time-domain analysis: computes the FFT of the response, computes an impulse response (two-channel) and derives an FFT from that IR for reference comparison.\n * - Plots: Magnitude (dB) with raw and smoothed reference traces, Phase (degrees) with raw and smoothed traces, and the time-domain impulse response.\n * - Smoothing: applies smoothFFT to the reference frequency response using the smoothing parameters 1/6 and 1/48 (producing \"Magnitude (Smoothed)\" and \"Phase (Smoothed)\").\n *\n * Side effects:\n * - Mutates DOM by adding a closable tab button and corresponding tab content elements.\n * - Renders plots using Plotly into the created tab content.\n * - Persists analysis state to storage (IndexedDB/sessionStorage mirror).\n *\n * @param responseData - Audio buffer for the response file to analyze (Float32Array samples in Audio.data).\n * @param referenceData - Optional Audio buffer for the reference file; when provided, reference magnitude/phase and smoothed curves are computed and plotted.\n * @param filename - Display name for the response file (used in tab title and header).\n * @param referenceFilename - Optional display name for the reference file (appended to tab title when present).\n * @returns void\n */\nfunction createAnalysisTab(responseData: Audio, referenceData: Audio | null, filename: string, referenceFilename: string | null): void {\n    tabCounter++;\n    const tabId = `analysis-${tabCounter}`;\n    let shortName = filename.length > 20 ? filename.substring(0, 17) + '...' : filename;\n    if (referenceFilename != null) {\n        const shortReferenceName = referenceFilename?.length > 20 ? referenceFilename.substring(0, 17) + '...' : referenceFilename;\n        shortName += ' / ' + shortReferenceName;\n    }\n    // Create tab button\n    const tab = document.createElement('button');\n    tab.className = 'tab tab-closable';\n    tab.dataset.tab = tabId;\n    tab.innerHTML = `<span class=\"tab-icon-analysis\"></span>${shortName} <span class=\"tab-close\"></span>`;\n    tabsInnerContainer.appendChild(tab);\n    \n    // Create tab content\n    const content = document.createElement('div');\n    content.className = 'tab-content';\n    content.dataset.content = tabId;\n    content.innerHTML = `\n    <!-- nav class=\"tab-menu-bar\">\n                <div>\n                    <label for=\"smoothing-${tabId}\">Smoothing</label>\n                    <select id=\"smoothing-${tabId}\" class=\"smoothing-select\" aria-label=\"Smoothing factor\">\n                        <option value=\"0\">None</option>\n                        <option value=\"1/3\">1/3 octave</option>\n                        <option value=\"1/6\" selected>1/6 octave</option>\n                        <option value=\"1/12\">1/12 octave</option>\n                        <option value=\"1/24\">1/24 octave</option>\n                        <option value=\"1/48\">1/48 octave</option>\n                    </select>\n                </div>\n            </nav> <h5 class=\"text-xs italic text-gray-600\">Frequency Response Analysis of ${filename}${referenceFilename ? ' / ' + referenceFilename : ''}</h5 -->\n        <button class=\"sidecar-toggle\" id=\"sidebar-toggle-${tabId}\" title=\"Toggle Sidecar\">Open settings pane</button>\n        <div class=\"flex h-full\">\n            <div class=\"flex-none w-86 border-r border-[#ddd] p-2 relative sidecar\" style=\"transition:50ms linear;\">\n                <div class=\"section\">\n                    <div class=\"title\">Settings</div>\n                    <p><i>There are no settings for this analysis.</i></p>\n                </div>\n                <div class=\"section\">\n                    <div class=\"title\">Plots</div>\n                    <ul class=\"list\">\n                        <li><input type=\"checkbox\" id=\"checkbox-magnitude-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-magnitude-${tabId}\">Magnitude</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-phase-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-phase-${tabId}\">Phase</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-ir-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-ir-${tabId}\">Impulse Response</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-ir-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-ir-${tabId}\">Fundamental + Harmonic Distortion</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-distortion-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-distortion-${tabId}\">Distortion</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-distortion-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-distortion-${tabId}\">Sound Pressure Level</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-deconvoluted-ir-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-deconvoluted-ir-${tabId}\">Deconvoluted Impulse Response</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-stimulus-waveform-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-stimulus-waveform-${tabId}\">Stimulus Waveform</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-recorded-waveform-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-recorded-waveform-${tabId}\">Recorded Waveform</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-target-curve-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-target-curve-${tabId}\">Target Curve<button class=\"float-right text-xs cursor-pointer\" style=\"color: #bbb; padding-top: 3px\">Set</button></label></li>\n                    </ul>\n                </div>\n                <div class=\"section\">\n                    <div class=\"title\">Properties</div>\n                    <p><i>There are no properties for this analysis.</i></p>\n                </div>\n                <div id=\"resize-handle\" class=\"resize-handle\"></div>\n            </div>\n            <div class=\"flex-1 main-content\">\n                <div class=\"grid grid-cols-6 gap-[1px] bg-[#ddd] border-b border-[#ddd]\">\n                    <div class=\"plot-box\">\n                        <div id=\"plot-${tabId}-magnitude\" class=\"plot-medium\"></div>\n                        <div class=\"button-bar\">\n                            <button>Customize...</button>\n                            <button>Export as...</button>\n                            <label for=\"checkbox-magnitude-${tabId}\">Hide</label>\n                        </div>\n                    </div>\n                    <div class=\"plot-box\">\n                        <div id=\"plot-${tabId}-phase\" class=\"plot-medium\"></div>\n                        <div class=\"button-bar\">\n                            <button>Customize...</button>\n                            <button>Export as...</button>\n                            <label for=\"checkbox-phase-${tabId}\">Hide</label>\n                        </div>\n                    </div>\n                    <div class=\"plot-box\">\n                        <div id=\"plot-${tabId}-ir\" class=\"plot-medium\"></div>\n                        <div class=\"button-bar\">\n                            <button>Customize...</button>\n                            <button>Export as...</button>\n                            <label for=\"checkbox-ir-${tabId}\">Hide</label>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n       \n        \n    `;\n    tabContents.appendChild(content);\n\n    // Switch to new tab\n    switchTab(tabId);\n\n    // Compute and plot FFTs\n    console.log('Analyzing response file:', filename);\n    console.log('Response audio data:', responseData);\n    const responseSamples = responseData.getChannelData(0);\n    \n    console.log(responseData.getChannelData(0));\n    const responseFFT = computeFFT(responseSamples);\n\n    const smoothedResponseFFT = smoothFFT(responseFFT, 1/6, 1/48);\n    const tracesMagnitude: any[] = [{\n        x: responseFFT.frequency,\n        y: db(responseFFT.magnitude),\n        type: 'scatter',\n        mode: 'lines',\n        name: 'Measurement signal',\n        line: { color: '#0366d633', width: 1 }\n    }];\n    tracesMagnitude.push({\n        x: smoothedResponseFFT.frequency,\n        y: smoothedResponseFFT.magnitude,\n        type: 'scatter',\n        mode: 'lines',\n        name: 'Measurement signal (Smoothed)',\n        line: { color: '#0366d6', width: 2 }\n    });\n    const tracesPhase: any[] = [];\n    const tracesPhaseSecondary: any[] = [];\n    const tracesIR: any[] = [];\n\n    let irPeakAt = 0;\n\n    let referenceSamples = Float32Array.from([]);\n\n    if (referenceData) {\n        referenceSamples = referenceData.getChannelData(0);\n        const referenceFFT: FFTResult = computeFFT(referenceSamples);\n        tracesMagnitude.push({\n            x: referenceFFT.frequency,\n            y: db(referenceFFT.magnitude),\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Reference signal',\n            line: { color: '#0366d6', width: 2 }\n        });\n        const ir: ImpulseResponseResult = twoChannelImpulseResponse(responseSamples, referenceSamples);\n        const farina_ir: ImpulseResponseResult = FarinaImpulseResponse(responseSamples, referenceSamples);\n\n        console.log('Impulse response peak at', ir.peakAt);\n        irPeakAt = ir.peakAt;\n\n        tracesIR.push({\n            x: ir.t,\n            y:ir.ir,        \n            type: 'scatter',\n            mode: 'lines',\n            name: 'Dual-FFT Impulse Response',\n            line: { color: '#d73a49', width: 1 }\n        });\n        /* tracesIR.push({\n            x: farina_ir.t,\n            y: db(farina_ir.ir.map(v => Math.abs(v))),        \n            type: 'scatter',\n            mode: 'lines',\n            name: 'Farina Impulse Response',\n            line: { color: '#d73a49', width: 1 }\n        }); */\n        const transferFunction = computeFFTFromIR(ir);\n        const transferFunctionFarina = computeFFTFromIR(farina_ir);\n        // const dreferenceFFT = twoChannelFFT(responseData.data, referenceSamples, nextPow2(referenceSamples.length), -5627);\n        const smoothedFreqResponse = smoothFFT(transferFunction, 1/6, 1/48);\n        const smoothedFreqResponseFarina = smoothFFT(transferFunctionFarina, 1/6, 1/48);\n        \n        const rmsValue = 1;  // rms(referenceSamples);\n        console.log('Reference RMS:', db(rmsValue));\n\n        tracesMagnitude.push({\n            x: transferFunction.frequency,\n            y: db(transferFunction.magnitude.map(v => v * rmsValue)),\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Dual-FFT Transfer Function (Raw)',\n            line: { color: '#d73a4933', width: 1 }\n        });\n        tracesMagnitude.push({\n            x: smoothedFreqResponse.frequency,\n            y: smoothedFreqResponse.magnitude.map(v => v + db(rmsValue)),\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Dual-FFT Transfer Function (Smoothed)',\n            line: { color: '#d73a49', width: 2 }\n        });\n        tracesMagnitude.push({\n            x: transferFunctionFarina.frequency.map(v => v),\n            y: db(transferFunctionFarina.magnitude.map(v => v * rmsValue)),\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Farina Transfer Function',\n            line: { color: '#341fad33', width: 1 }\n        });\n        tracesMagnitude.push({\n            x: smoothedFreqResponseFarina.frequency.map(v => v),\n            y: smoothedFreqResponseFarina.magnitude.map(v => v + db(rmsValue)),\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Farina Transfer Function (Smoothed)',\n            line: { color: '#341fadff', width: 2 }\n        });\n\n\n        tracesPhase.push({\n            x: transferFunction.frequency,\n            y: transferFunction.phase,\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Dual-FFT Transfer Function (Raw)',\n            line: { color: '#d73a4933', width: 1 }\n        });\n        tracesPhase.push({\n            x: smoothedFreqResponse.frequency,\n            y: smoothedFreqResponse.phase,\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Dual-FFT Transfer Function (Smoothed)',\n            line: { color: '#d73a49', width: 2 }\n        });\n        const gd = groupDelays(transferFunction, 1000);\n        tracesPhase.push({\n            x: transferFunction.frequency,\n            y: gd,\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Group Delay (Calculated on a reduced set of points)',\n            line: { color: '#d73a49', width: 2, dash: 'dot' },\n            yaxis: 'y2'\n        });\n    }\n\n    const plotSettings: {[key: string]: any} = {\n        plotGlPixelRatio: 2, // For better clarity on high-DPI screens\n        legend: {\"orientation\": \"h\", \"y\": -0.2, \"yanchor\": \"top\"},\n        plot_bgcolor: '#fafbfc',\n        paper_bgcolor: '#fff',\n        staticPlot: false, // Enable interactivity\n        dragmode: 'pan',\n        showAxisDragHandles: true,\n        showAxisRangeEntryBoxes: true,\n        axisDragOnHover: true,\n        tightenLats: true,\n        font: {\n            family: \"'Newsreader', Georgia, 'Times New Roman', Times, serif\",\n        },\n        margin: { t: 80, r: 65, b: 70, l: 65 }\n    };\n\n    const layoutPhase = {\n        title: 'Phase Analysis',\n        xaxis: { \n            title: 'Frequency (Hz)', \n            type: 'log',\n            gridcolor: '#e1e4e8',\n            range: [Math.log10(20), Math.log10(20000)],\n            tickformat: '.0f',\n        },\n        yaxis: { \n            title: 'Phase (degrees)',\n            gridcolor: '#e1e4e8',\n            automargin: true,\n            range: [-720, 720],\n        },\n        yaxis2: { \n            title: 'Group Delay (ms)',\n            gridcolor: '#e1e4e8',\n            automargin: true,\n            anchor: 'x', \n            overlaying: 'y', \n            side: 'right',\n            range: [-20, 20],\n        },\n        ...plotSettings\n    };\n\n    (window as any).Plotly.newPlot(`plot-${tabId}-phase`, tracesPhase, layoutPhase, { responsive: true });\n\n\n    const layoutMagnitude = {\n        title: 'Magnitude Analysis',    \n        xaxis: { \n            title: 'Frequency (Hz)', \n            type: 'log',\n            gridcolor: '#e1e4e8',\n            range: [Math.log10(20), Math.log10(20000)],\n            tickformat: '.0f',\n\n        },\n        yaxis: { \n            title: 'Magnitude (dB)',\n            gridcolor: '#e1e4e8',\n            rangemode: 'tozero',\n            range: [-85, 5],\n        },\n        ...plotSettings\n    };\n\n    (window as any).Plotly.newPlot(`plot-${tabId}-magnitude`, tracesMagnitude, layoutMagnitude, { responsive: true });\n\n    \n    const layoutIR = {\n        title: 'Impulse response',\n        xaxis: { \n            title: 'Amplitude', \n            gridcolor: '#e1e4e8',\n            range: [-0.05 + irPeakAt / responseData.sampleRate, 0.05 + irPeakAt / responseData.sampleRate],\n        },\n        yaxis: { \n            title: 'Amplitude (gain)',\n            gridcolor: '#e1e4e8',\n            automargin: true,\n        },\n        ...plotSettings\n    };\n\n    (window as any).Plotly.newPlot(`plot-${tabId}-ir`, tracesIR, layoutIR, { responsive: true });\n    saveState();\n\n    // Persist analysis using IndexedDB (mirrored to sessionStorage for compatibility)\n    storage.setItem(`${tabId}`, JSON.stringify({\n        filename,\n        referenceFilename,\n        responseSamples: Array.from(responseSamples),\n        referenceSamples: referenceSamples.length > 0 ? Array.from(referenceSamples) : null,\n    })).catch(err => console.error('Failed to persist analysis:', err));\n\nfunction initResize(e: MouseEvent): void {\n    e.preventDefault();\n    window.addEventListener('mousemove', resize, false);\n    window.addEventListener('mouseup', stopResize, false);\n    console.log('Init resize');\n    document.body.style.cursor = 'col-resize';\n}\n\nfunction resize(e: MouseEvent): void {\n    const container = content.querySelector<HTMLElement>('.flex')!;\n    const handle = document.getElementById('resize-handle')?.parentElement!;\n    const rect = container.getBoundingClientRect();\n    const newWidth = e.clientX - rect.left;\n    if (newWidth > 150 && newWidth < rect.width - 150) {\n        handle.style.width = `${newWidth}px`;\n    }\n}\n\nfunction stopResize(): void {\n    window.removeEventListener('mousemove', resize, false);\n    window.removeEventListener('mouseup', stopResize, false);\n    window.dispatchEvent(new Event('resize'));\n    document.body.style.cursor = 'default';\n}       \n\n    document.getElementById('resize-handle')?.addEventListener('mousedown', initResize, false);\n\n        // Add event listeners for checkbox visibility toggles\n    document.getElementById(`checkbox-magnitude-${tabId}`)?.addEventListener('change', (e) => {\n        console.log('Toggling magnitude plot visibility');\n        const box = document.getElementById(`plot-${tabId}-magnitude`)!.parentElement!;\n        box.setAttribute('style', (e.target as HTMLInputElement).checked ? 'display: block;' : 'display: none;');\n    });\n\n    document.getElementById(`checkbox-phase-${tabId}`)?.addEventListener('change', (e) => {\n        const box = document.getElementById(`plot-${tabId}-phase`)!.parentElement!;\n        box.setAttribute('style', (e.target as HTMLInputElement).checked ? 'display: block;' : 'display: none;');\n    });\n\n    document.getElementById(`checkbox-ir-${tabId}`)?.addEventListener('change', (e) => {\n        const box = document.getElementById(`plot-${tabId}-ir`)!.parentElement!;\n        box.setAttribute('style', (e.target as HTMLInputElement).checked ? 'display: block;' : 'display: none;');\n    });\n}\n\n// Save and load state from sessionStorage\nfunction saveState(): void {\n    const tabs = Array.from(document.querySelectorAll('.tab[data-tab]')).map(tab => ({\n        id: (tab as HTMLElement).dataset.tab,\n        name: (tab as HTMLElement).textContent?.replace('', '').trim()\n    }));\n    \n    storage.setItem('tabs', JSON.stringify(tabs));\n    console.log('Saved state with tabs:', tabs);\n}\n\nasync function loadState(): Promise<void> {\n    try {\n        const savedTabs = await storage.getItem('tabs');\n        if (!savedTabs) return;\n        const tabs = JSON.parse(savedTabs);\n        console.log('Loading saved tabs:', tabs);\n\n        for (const tab of tabs as { id: string; name: string }[]) {\n            // Call createAnalysisTab for each tab\n            const raw = await storage.getItem(`${tab.id}`);\n            const analysisData = raw ? JSON.parse(raw) : null;\n            console.log('Restoring analysis data for tab', tab.id, analysisData);\n            if (analysisData) {\n                createAnalysisTab(Audio.fromSamples(Float32Array.from(analysisData.responseSamples)), analysisData.referenceSamples ? Audio.fromSamples(Float32Array.from(analysisData.referenceSamples)) : null, analysisData.filename, analysisData.referenceFilename);\n            }\n        }\n        // Tabs will be recreated when user analyzes files again\n    } catch (e) {\n        console.error('Failed to load saved state:', e);\n    }\n}\n\n// Load state on page load\nloadState();\n\nfunction max(arg0: Float32Array<ArrayBuffer>): any {\n    throw new Error(\"Function not implemented.\");\n}\n"]}