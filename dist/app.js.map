{"version":3,"sources":["/workspaces/dunkadunka.se/dist/app.js","../src/math.ts","../src/fft.ts","../src/fractional_octave_smoothing.ts","../src/audio.ts","../src/windows.ts","../src/plotting.ts","../src/farina.ts","../src/storage.ts","../src/device-settings.ts","../src/recorder.ts","../src/wave.ts","../src/app.ts"],"names":["console","debug","logspace","start","end","num","logStart","Math","log10","logEnd","logStep","Float32Array","from","length","_","i","pow","linspace","step","closest","arr","curr","diff","abs","index","val","newDiff","average","array","reduce","a","b","re","im","sqrt","mod","n","m","nextPow2","v","p","max","maxVal","Infinity","FFT","size","Error","_csize","table","Array","angle","PI","cos","sin","power","t","_width","_bitrev","j","shift","revShift","_out","_data","_inv","fromComplexArray","complex","storage","res","createComplexArray","toComplexArray","input","completeSpectrum","spectrum","half","transform","out","data","_transform4","realTransform","_realTransform4","inverseTransform","width","len","outOff","bitrev","off","_singleTransform2","_singleTransform4","inv","quarterLen","limit","k","A","B","C","D","Ar","Ai","Br","Bi","Cr","Ci","Dr","Di","MAr","MAi","tableBr","tableBi","MBr","MBi","tableCr","tableCi","MCr","MCi","tableDr","tableDi","MDr","MDi","T0r","T0i","T1r","T1i","T2r","T2i","T3r","T3i","FAr","FAi","FCr","FCi","FBr","FBi","FDr","FDi","evenR","evenI","oddR","oddI","leftR","leftI","rightR","rightI","step2","step3","_singleRealTransform2","_singleRealTransform4","halfLen","hquarterLen","ST0r","ST0i","ST1r","ST1i","ST2r","ST2i","ST3r","ST3i","SFAr","SFAi","SFBr","SFBi","SA","SB","getFractionalOctaveFrequencies","fraction","f_low","f_high","fftSize","num_points","round","frequencies","frequency_resolution","Set","fractionalOctaveSmoothing","frequencyData","frequenciesAll","smoothedData","factor","sum","as","slice","min","window","buffer","rms","db","value","map","dbToLinear","loadAudioFile","file","headerBuffer","ext","mime","metadata","wavInfo","mp3Info","arrayBuffer","audioContext","audioBuffer","getExt","name","split","pop","toLowerCase","parseWav","buf","dv","DataView","readStr","s","String","fromCharCode","getUint8","offset","info","byteLength","id","getUint32","audioFormat","getUint16","numChannels","sampleRate","byteRate","blockAlign","bitsPerSample","dataChunkSize","duration","parseMp3","sampleRates","bytes","Uint8Array","headerIndex","b1","b2","b3","versionBits","layerBits","bitrateBits","sampleRateBits","channelMode","versions","layers","versionKey","layerKey","bitrateTable","versionStr","layerStr","bitrateKbps","tbKey","channels","version","layer","type","format","Object","assign","log","AudioContext","webkitAudioContext","decodeAudioData","Audio","fromAudioBuffer","_Audio","applyGain","gain","numberOfChannels","ch","getChannelData","copyToChannel","getChannel","channel","channelData","newBuffer","AudioBuffer","audio","fromSamples","samples","chirp","f_start","f_stop","rate","fade","fs","c","L","samples_count","fade_in","floor","fade_out","pre","post","phi","baseIdx","exp","last","sweep","envMain","startZeros","endZeros","envelope","w","sweepWindowed","smoothFFT","fftData","resolution","frequency","magnitude","phase","smoothedMagnitude","fractionalFrequencies","smoothed","smoothedPhase","computeFFT","ceil","log2","fft","frame","SQRT2","atan2","frequencyResolution","fftCorrelation","x","y","lenX","lenY","fullLen","xP","yP","set","ar","ai","br","bi","corr","Float64Array","sumX2","sumY2","denom","normalized","lags","Int32Array","peakIdx","peakVal","estimatedLag","estimatedLagSamples","estimatedLagIndex","peakCorrelation","raw","nfft","fftConvolve","mode","result","twoChannelImpulseResponse","N","epsilon","ir","peakAt","ir_complex","mean","twoChannelFFT","dataArray","reference","dataPadded","referencePadded","refLen","dataLen","reference_","signal_","signalMags","referenceMags","h","i_50","phase_signal","phase_reference","sphase","unwrapPhase","correction","phases","theta","delta","computeFFTFromIR","f_phase_wrap","frequency_multiplier","i_norm","unwraped_phase","corrected_unwraped_phase","groupDelays","normalizeAt","groupDelay","dPhase","dFreq","normIdx","delayAtNorm","A_WEIGHTING_COEFFICIENTS","K_WEIGHTING_COEFFICIENTS_PRE","K_WEIGHTING_COEFFICIENTS_RLB","applyAWeightingToBuffer","zi","output","gateBuffer","thresholdDb","blockMs","overlap","blockSize","hopSize","threshold","gated","block","blockRms","hanningWindow","hammingWindow","blackmanWindow","rectangularWindow","fill","getSelectedWindow","windowType","correct","wcf","COLORS","addPlotToList","tabId","plotId","plotName","hidden","plotList","document","getElementById","listItem","createElement","innerHTML","appendChild","addPlotElement","tabContent","querySelector","plotBox","className","style","display","plot","traces","title","xTitle","yTitle","xAxisExtras","yAxisExtras","layoutExtras","plotSettings","plotGlPixelRatio","legend","plot_bgcolor","paper_bgcolor","staticPlot","dragmode","showAxisDragHandles","showAxisRangeEntryBoxes","axisDragOnHover","tightenLats","font","family","margin","r","l","layout","xaxis","gridcolor","yaxis","automargin","replace","element","Plotly","newPlot","responsive","addEventListener","e","box","parentElement","setAttribute","target","checked","dispatchEvent","Event","Farina","stimulus","deconvolved","lag_of_harmonic","ell","margin_of_harmonic","max_safe_harmonic","window_size","push","instant","signal","at","si","deconvolution","inv_stimulus","reverse","norm","deconvolvedResponse","harmonics","windowSize","harmonicsCount","results","plotDistortion","farina","maxHarmonics","color","response","harmonicsFFT","smoothedResponse","smoothedHarmonicsFFT","f","line","showlegend","hf","range","plotTHD","fundamental","thd","sumSquares","openIDB","Promise","resolve","reject","req","indexedDB","open","onupgradeneeded","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","onerror","error","setItem","key","tx","store","transaction","objectStore","put","oncomplete","onabort","getItem","get","removeItem","delete","clearStorage","clear","sessionStorage","dumpStorage","openCursor","event","cursor","continue","INPUT_KEY","OUTPUT_KEY","openDeviceSettings","modal","initDeviceSettings","closeDeviceSettings","ensureDeviceAccess","navigator","mediaDevices","getUserMedia","video","refreshAudioDeviceList","devices","inputSel","outputSel","inputId","outputId","note","sinkSupported","enumerateDevices","warn","localStorage","forEach","d","kind","opt","deviceId","textContent","label","selected","HTMLMediaElement","prototype","applyOutputDevice","router","setSinkId","saveDeviceSelections","onchange","outId","AudioRecorder","record","durationSec","recording","pointer","stream","streamSource","worklet","audioWorklet","addModule","echoCancellation","noiseSuppression","autoGainControl","createMediaStreamSource","AudioWorkletNode","numberOfInputs","numberOfOutputs","processorOptions","connect","port","onmessage","disconnect","setTimeout","getTracks","track","stop","download","bytesPerSample","dataSize","ArrayBuffer","view","writeString","str","setUint8","charCodeAt","setUint32","setUint16","Number","setInt16","blob","Blob","url","URL","createObjectURL","href","body","click","remove","revokeObjectURL","root","documentElement","uiColor","setProperty","tabCounter","tabsContainer","tabsInnerContainer","tabContents","responseFileUploadInput","referenceFileUploadInput","analyzeUploadBtn","polarReferenceFileInput","polarMeasurementsEl","addPolarMeasurementBtn","analyzePolarBtn","polarStatusEl","disabled","files","normalizeAngleDeg","angleDeg","getPolarMeasurements","rows","querySelectorAll","row","fileInput","angleInput","parsed","parseFloat","isFinite","updatePolarAnalyzeEnabled","hasReference","hasAnyMeasurement","addPolarMeasurementRow","initialAngleDeg","classList","acquisitionState","mediaRecorder","recordedChunks","oscillatorNode","playbackSource","isRecording","startBtn","stopBtn","playBtn","stopPlayBtn","sweepStartFreqInput","sweepEndFreqInput","sweepDurationInput","recordingStatusEl","recordingMeterEl","recordingVisualizationEl","recordedAudioContainer","recordedAudioEl","analyzeRecordingBtn","viewWaveformBtn","channelSelectionContainer","channelSelect","initializeAudioContext","state","resume","detectAndSetupChannels","source","analyser","channelCount","option","channelNames","createAnalyser","mediaStream","getAudioTracks","getSettings","toString","dataset","tab","recorded","startRecordingAndPlayback","startFreq","endFreq","preRecordTime","postRecordTime","totalRecordTime","sweepSignal","sourceGain","recorder","createBuffer","createGain","toFixed","then","recordingData","stopRecording","createBufferSource","destination","message","playbackOnly","stopPlayback","recordedAudio","referenceAudio","now","dateTime","recordingName","Date","toLocaleString","year","month","day","hour","minute","second","hour12","createAnalysisTab","alert","saveState","err","catch","switchTab","stopPropagation","add","responseFile","referenceFile","responseData","referenceData","measurements","oldText","loaded","responseAudios","anglesDeg","all","sort","createDirectivityPlotTab","filename","referenceFilename","shortName","substring","shortReferenceName","content","responseSamples","responseFFT","smoothedResponseFFT","referenceSamples","referenceFFT","smoothedReferenceFFT","farina_ir","fillcolor","hoverinfo","transferFunction","smoothedFreqResponse","gd","dash","sr","targetFrames","minHop","rawFrames","hop","frames","win","firstFrame","subarray","firstFFT","freqs","bins","z","times","windowed","magDb","colorscale","zmin","zmax","colorbar","JSON","stringify","initResize","preventDefault","resize","stopResize","container","handle","rect","getBoundingClientRect","newWidth","clientX","left","removeEventListener","responseDatas","transfers","directivityTabId","useCustomAngles","angles","resp","baseFreq","normHz","best","POSITIVE_INFINITY","tf","ref","tabs","trim","loadState","savedTabs","analysisData","parse"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// src/math.ts\nconsole.debug(\"Math module loaded\");\nfunction logspace(start, end, num) {\n  const logStart = Math.log10(start);\n  const logEnd = Math.log10(end);\n  const logStep = (logEnd - logStart) / (num - 1);\n  return Float32Array.from({ length: num }, (_, i) => Math.pow(10, logStart + i * logStep));\n}\nfunction linspace(start, end, num) {\n  if (num === 1) return Float32Array.from([start]);\n  const step = (end - start) / (num - 1);\n  return Float32Array.from({ length: num }, (_, i) => start + i * step);\n}\nfunction closest(num, arr) {\n  let curr = arr[0];\n  let diff = Math.abs(num - curr);\n  let index = 0;\n  for (let val = 0; val < arr.length; val++) {\n    const newDiff = Math.abs(num - arr[val]);\n    if (newDiff < diff) {\n      diff = newDiff;\n      curr = arr[val];\n      index = val;\n    }\n  }\n  return index;\n}\nvar average = (array) => array.reduce((a, b) => a + b) / array.length;\nvar abs = (re, im = 0) => Math.sqrt(re * re + im * im);\nvar mod = (n, m) => (n % m + m) % m;\nvar nextPow2 = (v) => {\n  let p = 1;\n  while (p < v) p <<= 1;\n  return p;\n};\nfunction max(arr) {\n  let maxVal = -Infinity;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > maxVal) maxVal = Math.abs(arr[i]);\n  }\n  return maxVal;\n}\n\n// src/fft.ts\nconsole.debug(\"FFT module loaded\");\nvar FFT = class {\n  constructor(size) {\n    this.size = size | 0;\n    if (this.size <= 1 || (this.size & this.size - 1) !== 0)\n      throw new Error(\"FFT size must be a power of two and bigger than 1\");\n    this._csize = size << 1;\n    const table = new Array(this.size * 2);\n    for (let i = 0; i < table.length; i += 2) {\n      const angle = Math.PI * i / this.size;\n      table[i] = Math.cos(angle);\n      table[i + 1] = -Math.sin(angle);\n    }\n    this.table = table;\n    let power = 0;\n    for (let t = 1; this.size > t; t <<= 1)\n      power++;\n    this._width = power % 2 === 0 ? power - 1 : power;\n    this._bitrev = new Array(1 << this._width);\n    for (let j = 0; j < this._bitrev.length; j++) {\n      this._bitrev[j] = 0;\n      for (let shift = 0; shift < this._width; shift += 2) {\n        const revShift = this._width - shift - 2;\n        this._bitrev[j] |= (j >>> shift & 3) << revShift;\n      }\n    }\n    this._out = null;\n    this._data = null;\n    this._inv = 0;\n  }\n  fromComplexArray(complex, storage2) {\n    const res = storage2 || new Array(complex.length >>> 1);\n    for (let i = 0; i < complex.length; i += 2)\n      res[i >>> 1] = complex[i];\n    return res;\n  }\n  createComplexArray() {\n    const res = new Array(this._csize);\n    for (let i = 0; i < res.length; i++)\n      res[i] = 0;\n    return res;\n  }\n  toComplexArray(input, storage2) {\n    const res = storage2 || this.createComplexArray();\n    for (let i = 0; i < res.length; i += 2) {\n      res[i] = input[i >>> 1];\n      res[i + 1] = 0;\n    }\n    return res;\n  }\n  completeSpectrum(spectrum) {\n    const size = this._csize;\n    const half = size >>> 1;\n    for (let i = 2; i < half; i += 2) {\n      spectrum[size - i] = spectrum[i];\n      spectrum[size - i + 1] = -spectrum[i + 1];\n    }\n  }\n  transform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 0;\n    this._transform4();\n    this._out = null;\n    this._data = null;\n  }\n  realTransform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 0;\n    this._realTransform4();\n    this._out = null;\n    this._data = null;\n  }\n  inverseTransform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 1;\n    this._transform4();\n    for (let i = 0; i < out.length; i++)\n      out[i] /= this.size;\n    this._out = null;\n    this._data = null;\n  }\n  // radix-4 implementation\n  //\n  // NOTE: Uses of `var` are intentional for older V8 version that do not\n  // support both `let compound assignments` and `const phi`\n  _transform4() {\n    const out = this._out;\n    const size = this._csize;\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    let outOff;\n    let t;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform2(outOff, off, step);\n      }\n    } else {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform4(outOff, off, step);\n      }\n    }\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      const quarterLen = len >>> 2;\n      for (outOff = 0; outOff < size; outOff += len) {\n        const limit = outOff + quarterLen;\n        for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n          const A = i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n          const MAr = Ar;\n          const MAi = Ai;\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n          const FCr = T0r - T2r;\n          const FCi = T0i - T2i;\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n          const FDr = T1r - T3i;\n          const FDi = T1i + T3r;\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          out[D] = FDr;\n          out[D + 1] = FDi;\n        }\n      }\n    }\n  }\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  _singleTransform2(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const evenR = data[off];\n    const evenI = data[off + 1];\n    const oddR = data[off + step];\n    const oddI = data[off + step + 1];\n    const leftR = evenR + oddR;\n    const leftI = evenI + oddI;\n    const rightR = evenR - oddR;\n    const rightI = evenI - oddI;\n    out[outOff] = leftR;\n    out[outOff + 1] = leftI;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = rightI;\n  }\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  _singleTransform4(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n    const Ar = data[off];\n    const Ai = data[off + 1];\n    const Br = data[off + step];\n    const Bi = data[off + step + 1];\n    const Cr = data[off + step2];\n    const Ci = data[off + step2 + 1];\n    const Dr = data[off + step3];\n    const Di = data[off + step3 + 1];\n    const T0r = Ar + Cr;\n    const T0i = Ai + Ci;\n    const T1r = Ar - Cr;\n    const T1i = Ai - Ci;\n    const T2r = Br + Dr;\n    const T2i = Bi + Di;\n    const T3r = inv * (Br - Dr);\n    const T3i = inv * (Bi - Di);\n    const FAr = T0r + T2r;\n    const FAi = T0i + T2i;\n    const FBr = T1r + T3i;\n    const FBi = T1i - T3r;\n    const FCr = T0r - T2r;\n    const FCi = T0i - T2i;\n    const FDr = T1r - T3i;\n    const FDi = T1i + T3r;\n    out[outOff] = FAr;\n    out[outOff + 1] = FAi;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = FCi;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n  // Real input radix-4 implementation\n  _realTransform4() {\n    const out = this._out;\n    const size = this._csize;\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    let outOff;\n    let t;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n      }\n    } else {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n      }\n    }\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      const halfLen = len >>> 1;\n      const quarterLen = halfLen >>> 1;\n      const hquarterLen = quarterLen >>> 1;\n      for (outOff = 0; outOff < size; outOff += len) {\n        for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n          const A = outOff + i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n          const MAr = Ar;\n          const MAi = Ai;\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          if (i === 0) {\n            const FCr = T0r - T2r;\n            const FCi = T0i - T2i;\n            out[C] = FCr;\n            out[C + 1] = FCi;\n            continue;\n          }\n          if (i === hquarterLen)\n            continue;\n          const ST0r = T1r;\n          const ST0i = -T1i;\n          const ST1r = T0r;\n          const ST1i = -T0i;\n          const ST2r = -inv * T3i;\n          const ST2i = -inv * T3r;\n          const ST3r = -inv * T2i;\n          const ST3i = -inv * T2r;\n          const SFAr = ST0r + ST2r;\n          const SFAi = ST0i + ST2i;\n          const SFBr = ST1r + ST3i;\n          const SFBi = ST1i - ST3r;\n          const SA = outOff + quarterLen - i;\n          const SB = outOff + halfLen - i;\n          out[SA] = SFAr;\n          out[SA + 1] = SFAi;\n          out[SB] = SFBr;\n          out[SB + 1] = SFBi;\n        }\n      }\n    }\n  }\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  _singleRealTransform2(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const evenR = data[off];\n    const oddR = data[off + step];\n    const leftR = evenR + oddR;\n    const rightR = evenR - oddR;\n    out[outOff] = leftR;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = 0;\n  }\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  _singleRealTransform4(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n    const Ar = data[off];\n    const Br = data[off + step];\n    const Cr = data[off + step2];\n    const Dr = data[off + step3];\n    const T0r = Ar + Cr;\n    const T1r = Ar - Cr;\n    const T2r = Br + Dr;\n    const T3r = inv * (Br - Dr);\n    const FAr = T0r + T2r;\n    const FBr = T1r;\n    const FBi = -T3r;\n    const FCr = T0r - T2r;\n    const FDr = T1r;\n    const FDi = T3r;\n    out[outOff] = FAr;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = 0;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n};\n\n// src/fractional_octave_smoothing.ts\nconsole.debug(\"Fractional Octave Smoothing module loaded\");\nfunction getFractionalOctaveFrequencies(fraction, f_low = 20, f_high = 24e3, fftSize) {\n  if (fraction <= 0) {\n    throw new Error(\"Fraction must be greater than 0\");\n  }\n  if (f_low <= 0 || f_high <= 0) {\n    throw new Error(\"Frequencies must be greater than 0\");\n  }\n  if (f_low >= f_high) {\n    throw new Error(\"f_low must be less than f_high\");\n  }\n  const num_points = Math.round((Math.log10(f_high) - Math.log10(f_low)) / fraction) + 1;\n  let frequencies = logspace(f_low, f_high, num_points);\n  const frequency_resolution = 48e3 / fftSize;\n  for (let i = 0; i < frequencies.length; i++) {\n    frequencies[i] = Math.round(frequencies[i] / frequency_resolution) * frequency_resolution;\n  }\n  frequencies = Float32Array.from(new Set(frequencies));\n  return frequencies;\n}\nfunction fractionalOctaveSmoothing(frequencyData, fraction, frequencies) {\n  const frequenciesAll = linspace(0, 48e3 / 2, frequencyData.length);\n  const smoothedData = new Float32Array(frequencies.length);\n  const n = frequencyData.length;\n  const factor = Math.pow(2, 0.5 * fraction) - Math.pow(0.5, 0.5 * fraction);\n  for (let p = 0; p < frequencies.length; p++) {\n    const i = closest(frequencies[p], frequenciesAll);\n    let sum2 = 0;\n    const width = Math.round(0.5 * factor * (n * 0.5 - Math.abs(n * 0.5 - i)));\n    if (width === 0) {\n      sum2 = frequencyData[i];\n    } else {\n      const as = frequencyData.slice(Math.round(i - width + 1), Math.min(Math.round(i + width), n - 1));\n      sum2 = average(as);\n    }\n    smoothedData[p] = sum2;\n  }\n  return smoothedData;\n}\n\n// src/audio.ts\nconsole.debug(\"Audio module loaded\");\nwindow.FFT = FFT;\nfunction sum(buffer) {\n  let sum2 = 0;\n  for (let i = 0; i < buffer.length; i++) {\n    sum2 += buffer[i] * buffer[i];\n  }\n  return sum2;\n}\nfunction rms(buffer) {\n  return Math.sqrt(sum(buffer) / buffer.length);\n}\nfunction db(value) {\n  if (value instanceof Float32Array) {\n    return value.map((v) => 20 * Math.log10(v + 1e-50));\n  } else {\n    return 20 * Math.log10(value + 1e-50);\n  }\n}\nfunction dbToLinear(value) {\n  if (value instanceof Float32Array) {\n    return value.map((v) => Math.pow(10, v / 20));\n  } else {\n    return Math.pow(10, value / 20);\n  }\n}\nasync function loadAudioFile(file) {\n  const headerBuffer = await file.slice(0, 256 * 1024).arrayBuffer();\n  function getExt(name) {\n    return (name.split(\".\").pop() || \"\").toLowerCase();\n  }\n  function parseWav(buf) {\n    const dv = new DataView(buf);\n    function readStr(off, len) {\n      let s = \"\";\n      for (let i = 0; i < len; i++) s += String.fromCharCode(dv.getUint8(off + i));\n      return s;\n    }\n    if (readStr(0, 4) !== \"RIFF\" || readStr(8, 4) !== \"WAVE\") return null;\n    let offset = 12;\n    const info = {};\n    while (offset + 8 <= dv.byteLength) {\n      const id = readStr(offset, 4);\n      const size = dv.getUint32(offset + 4, true);\n      if (id === \"fmt \") {\n        info.audioFormat = dv.getUint16(offset + 8, true);\n        info.numChannels = dv.getUint16(offset + 10, true);\n        info.sampleRate = dv.getUint32(offset + 12, true);\n        info.byteRate = dv.getUint32(offset + 16, true);\n        info.blockAlign = dv.getUint16(offset + 20, true);\n        info.bitsPerSample = dv.getUint16(offset + 22, true);\n      } else if (id === \"data\") {\n        info.dataChunkSize = size;\n      }\n      offset += 8 + size + size % 2;\n    }\n    if (info.sampleRate && info.byteRate && info.dataChunkSize) {\n      info.duration = info.dataChunkSize / info.byteRate;\n    }\n    return info;\n  }\n  function parseMp3(buf) {\n    const bytes = new Uint8Array(buf);\n    let offset = 0;\n    if (bytes[0] === 73 && bytes[1] === 68 && bytes[2] === 51) {\n      const size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n      offset = 10 + size;\n    }\n    let headerIndex = -1;\n    for (let i = offset; i < bytes.length - 4; i++) {\n      if (bytes[i] === 255 && (bytes[i + 1] & 224) === 224) {\n        headerIndex = i;\n        break;\n      }\n    }\n    if (headerIndex < 0) return null;\n    const b1 = bytes[headerIndex + 1];\n    const b2 = bytes[headerIndex + 2];\n    const b3 = bytes[headerIndex + 3];\n    const versionBits = b1 >> 3 & 3;\n    const layerBits = b1 >> 1 & 3;\n    const bitrateBits = b2 >> 4 & 15;\n    const sampleRateBits = b2 >> 2 & 3;\n    const channelMode = b3 >> 6 & 3;\n    const versions = {\n      0: \"MPEG Version 2.5\",\n      1: \"reserved\",\n      2: \"MPEG Version 2 (ISO/IEC 13818-3)\",\n      3: \"MPEG Version 1 (ISO/IEC 11172-3)\"\n    };\n    const layers = {\n      0: \"reserved\",\n      1: \"Layer III\",\n      2: \"Layer II\",\n      3: \"Layer I\"\n    };\n    const sampleRates = {\n      3: [44100, 48e3, 32e3],\n      2: [22050, 24e3, 16e3],\n      0: [11025, 12e3, 8e3]\n    };\n    const versionKey = versionBits;\n    const layerKey = layerBits;\n    const bitrateTable = {\n      // MPEG1 Layer III\n      \"3_1\": [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 0],\n      // MPEG2/2.5 Layer III\n      \"0_1\": [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0],\n      \"2_1\": [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0],\n      // fallback generic table for other layers/versions (best-effort)\n      \"3_2\": [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 0],\n      \"3_3\": [0, 32, 64, 96, 128, 160, 192, 224, 256, 320, 384, 448, 512, 576, 640, 0]\n    };\n    const versionStr = versions[versionKey] || \"unknown\";\n    const layerStr = layers[layerKey] || \"unknown\";\n    let sampleRate = sampleRates[versionKey]?.[sampleRateBits] || null;\n    let bitrateKbps = 0;\n    const tbKey = `${versionKey}_${layerKey}`;\n    if (bitrateTable[tbKey]) {\n      bitrateKbps = bitrateTable[tbKey][bitrateBits] || 0;\n    } else if (bitrateTable[\"3_1\"] && versionKey === 3 && layerKey === 1) {\n      bitrateKbps = bitrateTable[\"3_1\"][bitrateBits] || 0;\n    }\n    const channels = channelMode === 3 ? 1 : 2;\n    let duration = null;\n    if (bitrateKbps > 0) {\n      duration = bytes.length * 8 / (bitrateKbps * 1e3);\n    }\n    return {\n      version: versionStr,\n      layer: layerStr,\n      bitrateKbps: bitrateKbps || null,\n      sampleRate,\n      channels,\n      duration\n    };\n  }\n  const ext = getExt(file.name);\n  const mime = file.type || \"unknown\";\n  let metadata = {};\n  const wavInfo = parseWav(headerBuffer);\n  if (wavInfo) {\n    metadata.format = \"wav\";\n    metadata = Object.assign(metadata, wavInfo || {});\n  } else if (mime === \"audio/mpeg\" || ext === \"mp3\") {\n    const mp3Info = parseMp3(headerBuffer);\n    metadata.format = \"mp3\";\n    metadata = Object.assign(metadata, mp3Info || {});\n  } else {\n    metadata.format = mime || ext || \"unknown\";\n  }\n  console.log(\"Extracted file metadata:\", metadata);\n  const arrayBuffer = await file.arrayBuffer();\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n  return Audio.fromAudioBuffer(audioBuffer, metadata);\n}\nvar Audio = class _Audio extends AudioBuffer {\n  static fromAudioBuffer(buffer, metadata) {\n    const audio2 = new _Audio({\n      length: buffer.length,\n      numberOfChannels: buffer.numberOfChannels,\n      sampleRate: buffer.sampleRate\n    });\n    for (let ch = 0; ch < buffer.numberOfChannels; ch++) {\n      audio2.copyToChannel(buffer.getChannelData(ch), ch);\n    }\n    audio2.metadata = metadata;\n    return audio2;\n  }\n  static fromSamples(samples, sampleRate = 48e3, metadata) {\n    if (!samples || samples.length == 0) return new _Audio({ length: 0, numberOfChannels: 1, sampleRate });\n    const audio2 = new _Audio({\n      length: samples.length,\n      numberOfChannels: 1,\n      sampleRate\n    });\n    audio2.copyToChannel(samples, 0);\n    audio2.metadata = metadata;\n    return audio2;\n  }\n  applyGain(gain) {\n    const numChannels = this.numberOfChannels;\n    for (let ch = 0; ch < numChannels; ch++) {\n      const data = this.getChannelData(ch).map((v) => v * gain);\n      this.copyToChannel(data, ch, 0);\n    }\n    return this;\n  }\n  getChannel(channel) {\n    if (channel < 0 || channel >= this.numberOfChannels) {\n      throw new Error(\"Invalid channel number\");\n    }\n    const channelData = this.getChannelData(channel);\n    const newBuffer = new AudioBuffer({\n      length: channelData.length,\n      numberOfChannels: 1,\n      sampleRate: this.sampleRate\n    });\n    newBuffer.copyToChannel(channelData, 0, 0);\n    return new _Audio(newBuffer);\n  }\n  rms(channel = 0) {\n    if (channel < 0 || channel >= this.numberOfChannels) {\n      throw new Error(\"Invalid channel number\");\n    }\n    const data = this.getChannelData(channel);\n    return rms(data);\n  }\n};\nfunction chirp(f_start, f_stop, duration = null, rate = null, fade = 0.01, fs = 48e3) {\n  const c = Math.log(f_stop / f_start);\n  let L;\n  let samples_count;\n  if (duration == null && rate == null) {\n    rate = 1;\n  }\n  if (duration == null) {\n    L = rate / Math.log(10);\n    samples_count = Math.round(L * c * fs);\n    duration = samples_count / fs;\n  } else {\n    L = duration / c;\n    rate = Math.log(10) * L;\n    samples_count = Math.round(L * c * fs);\n  }\n  samples_count = Math.max(1, samples_count);\n  const fade_in = Math.max(0, Math.floor(fade * fs));\n  const fade_out = Math.max(0, Math.floor(fade / 10 * fs));\n  const pre = Math.max(0, fade_in);\n  const post = Math.max(0, fade_out);\n  const phi = Float32Array.from({ length: pre + samples_count + post }, () => 0);\n  const offset = f_start * ((fade_in + 1) / fs);\n  for (let i = 0; i < pre; i++) phi[i] = f_start * (i / fs);\n  const baseIdx = pre;\n  for (let i = 0; i < samples_count; i++) {\n    let t2 = i / fs;\n    phi[baseIdx + i] = L * f_start * (Math.exp(t2 / L) - 1) + offset;\n  }\n  const last = phi[baseIdx + samples_count - 1] || 0;\n  for (let i = 0; i < post; i++) {\n    phi[baseIdx + samples_count + i] = last + f_stop * ((i + 1) / fs);\n  }\n  const sweep = Float32Array.from({ length: phi.length }, () => 0);\n  for (let i = 0; i < phi.length; i++) sweep[i] = Math.sin(2 * Math.PI * phi[i]);\n  const t = Float32Array.from({ length: sweep.length }, () => 0);\n  for (let i = 0; i < sweep.length; i++) t[i] = i / fs;\n  const envMain = Float32Array.from({ length: t.length }, () => 0);\n  const factor = f_stop * duration * duration;\n  for (let i = 0; i < t.length; i++) envMain[i] = Math.exp(-t[i] / L) / L * factor;\n  const startZeros = Math.floor(0.01 * fs);\n  const endZeros = Math.floor(1e-3 * fs);\n  const envelope = Float32Array.from({ length: startZeros + envMain.length + endZeros }, () => 0);\n  for (let i = 0; i < envMain.length; i++) {\n    envelope[startZeros + i] = envMain[i];\n  }\n  const window2 = Float32Array.from({ length: sweep.length }, () => 0);\n  for (let i = 0; i < sweep.length; i++) {\n    let w = 1;\n    if (fade_in > 0 && i < fade_in) {\n      w = i / Math.max(1, fade_in);\n    }\n    if (fade_out > 0 && i >= sweep.length - fade_out) {\n      const k = i - (sweep.length - fade_out);\n      w *= 1 - k / Math.max(1, fade_out);\n    }\n    window2[i] = w;\n  }\n  const sweepWindowed = Float32Array.from({ length: sweep.length }, () => 0);\n  for (let i = 0; i < sweep.length; i++) sweepWindowed[i] = sweep[i] * window2[i];\n  return [sweepWindowed, t, envelope];\n}\nfunction smoothFFT(fftData, fraction, resolution) {\n  const { frequency, magnitude, phase, fftSize } = fftData;\n  const smoothedMagnitude = Float32Array.from({ length: magnitude.length }, () => 0);\n  const fractionalFrequencies = getFractionalOctaveFrequencies(resolution, 20, 24e3, fftSize);\n  const smoothed = dbToLinear(fractionalOctaveSmoothing(db(magnitude), fraction, fractionalFrequencies));\n  const smoothedPhase = fractionalOctaveSmoothing(phase, fraction, fractionalFrequencies);\n  return {\n    frequency: fractionalFrequencies,\n    magnitude: smoothed,\n    phase: smoothedPhase,\n    fftSize\n  };\n}\nfunction computeFFT(data, fftSize = null) {\n  fftSize ?? (fftSize = 2 ** Math.ceil(Math.log2(data.length)));\n  console.log(`Computing FFT with ${fftSize} bins for data length ${data.length}`);\n  const fft = new FFT(fftSize);\n  const out = fft.createComplexArray();\n  const frame = Float32Array.from({ length: fftSize }, () => 0);\n  for (let i = 0; i < fftSize; i++) {\n    frame[i] = (data[i] || 0) * 1;\n  }\n  fft.realTransform(out, frame);\n  const frequency = Float32Array.from({ length: fftSize / 2 }, () => 0);\n  const magnitude = Float32Array.from({ length: fftSize / 2 }, () => 0);\n  const phase = Float32Array.from({ length: fftSize / 2 }, () => 0);\n  for (let i = 0; i < fftSize / 2; i++) {\n    const re = out[2 * i];\n    const im = out[2 * i + 1];\n    magnitude[i] = abs(re, im) * Math.SQRT2;\n    phase[i] = Math.atan2(im, re);\n  }\n  const frequencyResolution = 48e3 / fftSize;\n  for (let i = 0; i < fftSize / 2; i++) {\n    frequency[i] = i * frequencyResolution;\n  }\n  return {\n    frequency,\n    magnitude,\n    phase,\n    fftSize\n  };\n}\nfunction fftCorrelation(x, y) {\n  const lenX = x.length;\n  const lenY = y.length;\n  const fullLen = lenX + lenY - 1;\n  const nextPow22 = (v) => {\n    let p = 1;\n    while (p < v) p <<= 1;\n    return p;\n  };\n  const n = nextPow22(fullLen);\n  const xP = Float32Array.from({ length: n }, () => 0);\n  const yP = Float32Array.from({ length: n }, () => 0);\n  xP.set(x, 0);\n  yP.set(y, 0);\n  const fft = new FFT(n);\n  const A = fft.createComplexArray();\n  const B = fft.createComplexArray();\n  fft.realTransform(A, xP);\n  fft.realTransform(B, yP);\n  if (typeof fft.completeSpectrum === \"function\") {\n    fft.completeSpectrum(A);\n    fft.completeSpectrum(B);\n  }\n  const C = fft.createComplexArray();\n  for (let k = 0; k < n; k++) {\n    const ar = A[2 * k], ai = A[2 * k + 1];\n    const br = B[2 * k], bi = B[2 * k + 1];\n    C[2 * k] = ar * br + ai * bi;\n    C[2 * k + 1] = ai * br - ar * bi;\n  }\n  const out = fft.createComplexArray();\n  fft.inverseTransform(out, C);\n  const corr = Float64Array.from({ length: fullLen }, () => 0);\n  for (let i = 0; i < fullLen; i++) {\n    corr[i] = out[2 * i] / n;\n  }\n  let sumX2 = 0, sumY2 = 0;\n  for (let i = 0; i < lenX; i++) sumX2 += x[i] * x[i];\n  for (let i = 0; i < lenY; i++) sumY2 += y[i] * y[i];\n  const denom = Math.sqrt(sumX2 * sumY2);\n  const normalized = Float64Array.from({ length: fullLen }, () => 0);\n  if (denom > 0) {\n    for (let i = 0; i < fullLen; i++) normalized[i] = corr[i] / denom;\n  } else {\n    for (let i = 0; i < fullLen; i++) normalized[i] = 0;\n  }\n  const lags = new Int32Array(fullLen);\n  for (let i = 0; i < fullLen; i++) lags[i] = i - (lenY - 1);\n  let peakIdx = 0;\n  let peakVal = -Infinity;\n  for (let i = 0; i < fullLen; i++) {\n    if (normalized[i] > peakVal) {\n      peakVal = normalized[i];\n      peakIdx = i;\n    }\n  }\n  const estimatedLag = lags[peakIdx];\n  return {\n    corr: normalized,\n    lags,\n    estimatedLagSamples: estimatedLag,\n    estimatedLagIndex: peakIdx,\n    peakCorrelation: peakVal,\n    raw: corr,\n    nfft: n\n  };\n}\nfunction fftConvolve(x, y, mode = \"same\") {\n  const lenX = x.length;\n  const lenY = y.length;\n  const fullLen = lenX + lenY - 1;\n  const n = nextPow2(fullLen);\n  const xP = Float32Array.from({ length: n }, () => 0);\n  const yP = Float32Array.from({ length: n }, () => 0);\n  xP.set(x, 0);\n  yP.set(y, 0);\n  const fft = new FFT(n);\n  const A = fft.createComplexArray();\n  const B = fft.createComplexArray();\n  fft.realTransform(A, xP);\n  fft.realTransform(B, yP);\n  if (typeof fft.completeSpectrum === \"function\") {\n    fft.completeSpectrum(A);\n    fft.completeSpectrum(B);\n  }\n  const C = fft.createComplexArray();\n  for (let k = 0; k < n; k++) {\n    const ar = A[2 * k], ai = A[2 * k + 1];\n    const br = B[2 * k], bi = B[2 * k + 1];\n    C[2 * k] = ar * br - ai * bi;\n    C[2 * k + 1] = ai * br + ar * bi;\n  }\n  const out = fft.createComplexArray();\n  fft.inverseTransform(out, C);\n  const result = Float32Array.from({ length: fullLen }, () => 0);\n  for (let i = 0; i < fullLen; i++) {\n    result[i] = out[2 * i];\n  }\n  if (mode === \"same\") {\n    const start = Math.floor((fullLen - lenX) / 2);\n    return result.slice(start, start + lenX);\n  }\n  return result;\n}\nfunction twoChannelImpulseResponse(y, x) {\n  const fullLen = y.length + x.length - 1;\n  const N = nextPow2(fullLen);\n  const xP = Float32Array.from({ length: N }, () => 0);\n  const yP = Float32Array.from({ length: N }, () => 0);\n  xP.set(y, 0);\n  yP.set(x, 0);\n  const fft = new FFT(N);\n  const A = fft.createComplexArray();\n  const B = fft.createComplexArray();\n  fft.realTransform(A, xP);\n  fft.realTransform(B, yP);\n  const C = fft.createComplexArray();\n  const epsilon = 1e-20;\n  for (let k = 0; k < N; k++) {\n    const ar = A[2 * k], ai = A[2 * k + 1];\n    const br = B[2 * k], bi = B[2 * k + 1];\n    const denom = br * br + bi * bi + epsilon;\n    C[2 * k] = (ar * br + ai * bi) / denom;\n    C[2 * k + 1] = (ai * br - ar * bi) / denom;\n  }\n  const out = Float32Array.from(fft.createComplexArray());\n  fft.inverseTransform(out, C);\n  const ir = Float32Array.from({ length: N }, () => 0);\n  for (let i = 0; i < N; i++) {\n    ir[i] = out[2 * ((i + N / 2) % N)];\n  }\n  const peakAt = closest(1e8, ir) + -N / 2;\n  const ir_complex = out.slice();\n  for (let i = 0; i < N; i++) {\n    ir_complex[2 * i] = out[2 * mod(i + peakAt, N)];\n    ir_complex[2 * i + 1] = out[2 * mod(i + peakAt, N) + 1];\n  }\n  const mean = average(ir);\n  for (let i = 0; i < N; i++) {\n    ir[i] = ir[i] - mean;\n  }\n  return {\n    ir,\n    ir_complex,\n    t: linspace((-N - 1) / 2 / 48e3, (N - 1) / 2 / 48e3, N),\n    // assuming 48kHz\n    peakAt,\n    sampleRate: 48e3,\n    fftSize: N\n  };\n}\nfunction twoChannelFFT(dataArray, reference, fftSize, offset) {\n  const dataPadded = Float32Array.from({ length: fftSize }, () => 0);\n  const referencePadded = Float32Array.from({ length: fftSize }, () => 0);\n  if (offset >= 0) {\n    const refLen = Math.min(reference.length, Math.max(0, fftSize - offset));\n    for (let i = 0; i < refLen; i++) {\n      referencePadded[offset + i] = reference[i];\n    }\n    const dataLen = Math.min(dataArray.length, fftSize);\n    for (let i = 0; i < dataLen; i++) {\n      dataPadded[i] = dataArray[i];\n    }\n  } else {\n    const refLen = Math.min(reference.length, fftSize);\n    for (let i = 0; i < refLen; i++) {\n      referencePadded[i] = reference[i];\n    }\n    const start = -offset;\n    const dataLen = Math.min(dataArray.length, Math.max(0, fftSize - start));\n    for (let i = 0; i < dataLen; i++) {\n      dataPadded[start + i] = dataArray[i];\n    }\n  }\n  const reference_ = computeFFT(referencePadded);\n  const signal_ = computeFFT(dataPadded);\n  const signalMags = signal_.magnitude.map((v) => 20 * Math.log10(v === 0 ? 1e-20 : v));\n  const referenceMags = reference_.magnitude.map((v) => 20 * Math.log10(v === 0 ? 1e-20 : v));\n  const h = referenceMags.map((v, i) => signalMags[i] - v);\n  const frequency = linspace(0, 48e3 / 2, h.length);\n  const i_50 = closest(50, frequency);\n  const phase_signal = signal_.phase;\n  const phase_reference = reference_.phase;\n  const sphase = unwrapPhase(phase_signal.map((v, i) => v - phase_reference[i]));\n  const correction = Math.floor(sphase[i_50] / (2 * Math.PI) + 0.5) * (2 * Math.PI);\n  const phase = sphase.map((v) => v - correction);\n  function unwrapPhase(phases) {\n    const N = phases.length;\n    const out = Float32Array.from({ length: N }, () => 0);\n    if (N === 0) return out;\n    out[0] = phases[0];\n    let offset2 = 0;\n    const theta = Math.PI;\n    for (let i = 1; i < N; i++) {\n      let delta = phases[i] - phases[i - 1];\n      if (delta > theta) {\n        offset2 -= 2 * Math.PI;\n      } else if (delta < -theta) {\n        offset2 += 2 * Math.PI;\n      }\n      out[i] = phases[i] + offset2;\n    }\n    return out;\n  }\n  return {\n    frequency,\n    magnitude: h,\n    phase,\n    fftSize\n  };\n}\nfunction computeFFTFromIR(ir, f_phase_wrap = 1e3, frequency_multiplier = 1) {\n  const fftSize = nextPow2(ir.ir.length);\n  console.log(`Computing FFT from IR with size ${fftSize}`);\n  const fft = new FFT(fftSize);\n  const out = Float32Array.from(fft.createComplexArray());\n  if (ir.ir_complex[1] === 0) {\n    console.log(\"IR is in real format, converting to complex\");\n    const frame = Float32Array.from({ length: fftSize }, () => 0);\n    for (let i = 0; i < fftSize; i++) {\n      frame[i] = ir.ir_complex[2 * i] || 0;\n    }\n    fft.realTransform(out, frame);\n  } else {\n    fft.transform(out, ir.ir_complex);\n  }\n  const magnitude = Float32Array.from({ length: fftSize / 2 }, () => 0);\n  const phase = Float32Array.from({ length: fftSize / 2 }, () => 0);\n  for (let i = 0; i < fftSize / 2; i++) {\n    const re = out[2 * i];\n    const im = out[2 * i + 1];\n    magnitude[i] = abs(re, im);\n    phase[i] = Math.atan2(im, re);\n  }\n  const frequency = linspace(0, 48e3 / 2, magnitude.length);\n  const i_norm = closest(f_phase_wrap, frequency);\n  const unwraped_phase = unwrapPhase(phase);\n  const correction = Math.floor(unwraped_phase[i_norm] / (2 * Math.PI) + 0.5) * (2 * Math.PI);\n  const corrected_unwraped_phase = unwraped_phase.map((v) => v - correction);\n  function unwrapPhase(phases) {\n    const N = phases.length;\n    const out2 = Float32Array.from({ length: N }, () => 0);\n    if (N === 0) return out2;\n    out2[0] = phases[0];\n    let offset = 0;\n    for (let i = 1; i < N; i++) {\n      let delta = phases[i] - phases[i - 1];\n      if (delta > Math.PI) {\n        offset -= 2 * Math.PI;\n      } else if (delta < -Math.PI) {\n        offset += 2 * Math.PI;\n      }\n      out2[i] = phases[i] + offset;\n    }\n    return out2;\n  }\n  return {\n    frequency,\n    magnitude,\n    phase: corrected_unwraped_phase.map((v) => v / Math.PI * 180),\n    peakAt: ir.peakAt,\n    sampleRate: ir.sampleRate,\n    fftSize\n  };\n}\nfunction groupDelays(fftData, normalizeAt = 1e3) {\n  const { frequency, phase, peakAt } = fftData;\n  const N = frequency.length;\n  const groupDelay = Float32Array.from({ length: N }, () => 0);\n  for (let i = 1; i < N - 1; i++) {\n    const dPhase = phase[i] - phase[i - 1];\n    const dFreq = frequency[i] - frequency[i - 1];\n    groupDelay[i] = -dPhase / dFreq / 360;\n  }\n  groupDelay[0] = groupDelay[1];\n  groupDelay[N - 1] = groupDelay[N - 2];\n  const normIdx = closest(normalizeAt, frequency);\n  const delayAtNorm = groupDelay[normIdx];\n  for (let i = 0; i < N; i++) {\n    groupDelay[i] = groupDelay[i] - delayAtNorm;\n  }\n  return groupDelay;\n}\nvar A_WEIGHTING_COEFFICIENTS = [\n  Float32Array.from([0.234301792299513, -0.468603584599026, -0.234301792299513, 0.937207169198054, -0.234301792299515, -0.468603584599025, 0.234301792299513]),\n  Float32Array.from([1, -4.113043408775871, 6.553121752655047, -4.990849294163381, 1.785737302937573, -0.246190595319487, 0.011224250033231])\n];\nvar K_WEIGHTING_COEFFICIENTS_PRE = [\n  Float32Array.from([1.53512485958697, -2.69169618940638, 1.19839281085285]),\n  Float32Array.from([1, -1.69065929318241, 0.73248077421585])\n];\nvar K_WEIGHTING_COEFFICIENTS_RLB = [\n  Float32Array.from([1, -2, 1]),\n  Float32Array.from([1, -1.99004745483398, 0.99007225036621])\n];\nfunction applyAWeightingToBuffer(buffer, zi) {\n  const b = A_WEIGHTING_COEFFICIENTS[0];\n  const a = A_WEIGHTING_COEFFICIENTS[1];\n  const output = Float32Array.from({ length: buffer.length }, () => 0);\n  for (let n = 0; n < buffer.length; n++) {\n    output[n] = b[0] * buffer[n] + zi[0];\n    for (let i = 1; i < b.length; i++) {\n      zi[i - 1] = b[i] * buffer[n] + zi[i] - a[i] * output[n];\n    }\n  }\n  return output;\n}\nfunction gateBuffer(buffer, sampleRate, thresholdDb = -70, blockMs = 400, overlap = 0.75) {\n  const blockSize = Math.floor(blockMs / 1e3 * sampleRate);\n  const hopSize = Math.floor(blockSize * (1 - overlap));\n  const threshold = dbToLinear(thresholdDb);\n  const gated = Float32Array.from({ length: buffer.length }, () => 0);\n  let i = 0;\n  while (i < buffer.length) {\n    const start = i;\n    const end = Math.min(i + blockSize, buffer.length);\n    const block = buffer.slice(start, end);\n    const blockRms = rms(block);\n    if (blockRms >= threshold) {\n      for (let j = 0; j < block.length; j++) {\n        gated[start + j] = block[j];\n      }\n    }\n    i += hopSize;\n  }\n  return gated;\n}\nvar audio = {\n  loadAudioFile,\n  chirp,\n  computeFFT,\n  smoothFFT,\n  fftCorrelation,\n  fftConvolve,\n  twoChannelImpulseResponse,\n  computeFFTFromIR,\n  twoChannelFFT,\n  groupDelays,\n  applyAWeightingToBuffer,\n  gateBuffer\n};\n\n// src/windows.ts\nfunction hanningWindow(length) {\n  const window2 = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    window2[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (length - 1)));\n  }\n  return window2;\n}\nfunction hammingWindow(length) {\n  const window2 = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    window2[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (length - 1));\n  }\n  return window2;\n}\nfunction blackmanWindow(length) {\n  const window2 = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    window2[i] = 0.42 - 0.5 * Math.cos(2 * Math.PI * i / (length - 1)) + 0.08 * Math.cos(4 * Math.PI * i / (length - 1));\n  }\n  return window2;\n}\nfunction rectangularWindow(length) {\n  const window2 = new Float32Array(length);\n  window2.fill(1);\n  return window2;\n}\nfunction getSelectedWindow(windowType, length, correct = true) {\n  const type = windowType;\n  let window2 = new Float32Array(length);\n  let wcf = 1;\n  if (type === \"hanning\") {\n    window2 = hanningWindow(length);\n    wcf = 2;\n  }\n  if (type === \"hamming\") {\n    window2 = hammingWindow(length);\n    wcf = 1.852;\n  }\n  if (type === \"blackman\") {\n    window2 = blackmanWindow(length);\n    wcf = 2.381;\n  }\n  if (type === \"rectangular\") {\n    window2 = rectangularWindow(length);\n    wcf = 1;\n  }\n  if (correct) {\n    window2 = window2.map((v) => v / wcf);\n  }\n  return window2;\n}\n\n// src/plotting.ts\nvar COLORS = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"];\nfunction addPlotToList(tabId, plotId, plotName, hidden = false) {\n  const plotList = document.getElementById(`plot-list-${tabId}`);\n  const listItem = document.createElement(\"li\");\n  listItem.innerHTML = `<input type=\"checkbox\" id=\"checkbox-${plotId}\" alt=\"show/hide\" ${hidden ? \"\" : \"checked\"}><label for=\"checkbox-${plotId}\">${plotName}</label>`;\n  plotList.appendChild(listItem);\n}\nfunction addPlotElement(tabId, plotId, hidden = false) {\n  const tabContent = document.querySelector(`[data-content=\"${tabId}\"]`);\n  const plotBox = document.createElement(\"div\");\n  plotBox.className = \"plot-box\";\n  plotBox.innerHTML = `\n        <div id=\"${plotId}\" class=\"plot-medium\"></div>\n        <div class=\"button-bar\">\n            <button>Customize...</button>\n            <button>Export as...</button>   \n            <label for=\"checkbox-${plotId}\">Hide</label>\n        </div>\n    `;\n  tabContent.querySelector(\".plot-outer\")?.appendChild(plotBox);\n  if (hidden) {\n    plotBox.style.display = \"none\";\n  }\n  return plotBox.querySelector(`#${plotId}`);\n}\nfunction plot(traces, tabId, title, xTitle, yTitle, xAxisExtras = {}, yAxisExtras = {}, layoutExtras = {}, hidden = false) {\n  const plotSettings = {\n    plotGlPixelRatio: 2,\n    // For better clarity on high-DPI screens\n    legend: { \"orientation\": \"h\", \"y\": -0.2, \"yanchor\": \"top\" },\n    plot_bgcolor: \"#fafbfc\",\n    paper_bgcolor: \"#fff\",\n    staticPlot: false,\n    // Enable interactivity\n    dragmode: \"pan\",\n    showAxisDragHandles: true,\n    showAxisRangeEntryBoxes: true,\n    axisDragOnHover: true,\n    tightenLats: true,\n    font: {\n      family: \"'Newsreader', Georgia, 'Times New Roman', Times, serif\"\n    },\n    margin: { t: 80, r: 65, b: 70, l: 65 }\n  };\n  const layout = {\n    title,\n    xaxis: {\n      title: xTitle,\n      gridcolor: \"#e1e4e8\",\n      //tickformat: '.0f',\n      ...xAxisExtras\n    },\n    yaxis: {\n      title: yTitle,\n      gridcolor: \"#e1e4e8\",\n      automargin: true,\n      ...yAxisExtras\n    },\n    ...layoutExtras,\n    ...plotSettings\n  };\n  const plotId = `plot-${tabId}-${title.toLowerCase().replace(/\\s+/g, \"-\")}`;\n  const element = addPlotElement(tabId, plotId, hidden);\n  window.Plotly.newPlot(element, traces, layout, { responsive: true });\n  addPlotToList(tabId, plotId, title, hidden);\n  document.getElementById(`checkbox-${plotId}`)?.addEventListener(\"change\", (e) => {\n    const box = document.getElementById(`${plotId}`).parentElement;\n    box.setAttribute(\"style\", e.target.checked ? \"display: block;\" : \"display: none;\");\n    window.dispatchEvent(new Event(\"resize\"));\n  });\n  console.log(`Plotted ${title} in tab ${tabId}`);\n}\n\n// src/farina.ts\nvar Farina = class {\n  /* Farina deconvolution implementation according to the Python implementation. */\n  constructor(stimulus, f_start = 50, f_stop = 22800, fs = 48e3) {\n    this.deconvolved = Float32Array.from([]);\n    this.f_start = f_start;\n    this.f_stop = f_stop;\n    this.fs = fs;\n    this.stimulus = stimulus;\n    this.duration = this.stimulus.length / this.fs;\n  }\n  lag_of_harmonic(n) {\n    return this.ell() * Math.log(n);\n  }\n  margin_of_harmonic(n) {\n    return this.ell() * Math.log(n + 1) - this.ell() * Math.log(n);\n  }\n  max_safe_harmonic(window_size) {\n    const t = [];\n    for (let n = 1; n < 1e3; n++) {\n      if (this.margin_of_harmonic(n) > window_size) {\n        t.push(this.margin_of_harmonic(n));\n      }\n    }\n    return t.length < 999 ? t.length : 0;\n  }\n  ell() {\n    return this.duration / Math.log(this.f_stop / this.f_start);\n  }\n  rate(length) {\n    return 1 / this.f_start * Math.PI * Math.round(length * this.f_start / Math.log2(this.f_stop / this.f_start));\n  }\n  instant() {\n    return closest(1e8, this.deconvolved);\n  }\n  window(signal, at, length) {\n    const size = Math.floor(length * this.fs);\n    const window2 = getSelectedWindow(\"rectangular\", size, false);\n    const si = signal.ir.slice(at - size / 2, at + size / 2);\n    const w = Float32Array.from({ length: size }, () => 0);\n    if (si.length === window2.length) {\n      for (let i = 0; i < window2.length; i++) {\n        w[i] = window2[i] * si[i];\n      }\n    }\n    const ir_complex = Float32Array.from({ length: w.length * 2 }, () => 0);\n    for (let i = 0; i < w.length; i++) {\n      ir_complex[2 * i] = w[i];\n      ir_complex[2 * i + 1] = 0;\n    }\n    return {\n      ir: w,\n      ir_complex,\n      t: linspace((-size - 1) / 2 / this.fs, (size - 1) / 2 / this.fs, size),\n      peakAt: at,\n      sampleRate: this.fs,\n      fftSize: w.length\n    };\n  }\n  deconvolution(signal) {\n    const n = linspace(0, this.stimulus.length - 1, this.stimulus.length);\n    const ell = this.ell();\n    const k = n.map((v) => Math.exp(v / ell / this.fs));\n    const inv_stimulus = this.stimulus.slice().reverse().map((v, i) => v / k[i]);\n    const deconvolved = fftConvolve(signal, inv_stimulus, \"same\").slice();\n    const norm = max(fftConvolve(this.stimulus, inv_stimulus, \"same\").map((v) => Math.abs(v)));\n    this.deconvolved = deconvolved.map((v) => v / norm);\n    return this.deconvolved;\n  }\n  deconvolvedResponse(signal) {\n    const ir = this.deconvolution(signal);\n    const peakAt = this.instant();\n    const ir_complex = Float32Array.from({ length: ir.length * 2 }, () => 0);\n    for (let i = 0; i < ir.length; i++) {\n      ir_complex[2 * i] = ir[i];\n      ir_complex[2 * i + 1] = 0;\n    }\n    return {\n      ir,\n      ir_complex,\n      t: linspace(-peakAt / this.fs, (-peakAt + ir.length - 1) / this.fs, ir.length),\n      peakAt,\n      sampleRate: this.fs,\n      fftSize: ir.length\n    };\n  }\n  harmonics(windowSize, harmonicsCount) {\n    const results = [];\n    for (let n = 0; n <= harmonicsCount; n++) {\n      const at = Math.round(this.instant() - this.lag_of_harmonic(n + 1) * this.fs);\n      const w = this.window({\n        ir: this.deconvolved,\n        ir_complex: Float32Array.from([]),\n        t: Float32Array.from([]),\n        peakAt: at,\n        sampleRate: this.fs,\n        fftSize: this.deconvolved.length\n      }, at, windowSize);\n      results.push(w);\n    }\n    return results;\n  }\n};\nfunction plotDistortion(farina, windowSize, maxHarmonics, tabId) {\n  const harmonics = farina.harmonics(windowSize, maxHarmonics);\n  const harmonicsFFT = harmonics.map((h, n) => computeFFTFromIR(h, 1e3, 1 / (n + 1)));\n  const smoothedHarmonicsFFT = harmonicsFFT.map((hf) => smoothFFT(hf, 1 / 6, 1 / 96));\n  const traces = [];\n  for (let n = 0; n < smoothedHarmonicsFFT.length; n++) {\n    const color = COLORS[n % COLORS.length];\n    const response = harmonicsFFT[n];\n    const smoothedResponse = smoothedHarmonicsFFT[n];\n    if (n === 0) {\n      traces.push({\n        x: response.frequency.map((f) => f / (n + 1)),\n        y: db(response.magnitude),\n        type: \"scatter\",\n        mode: \"lines\",\n        name: n === 0 ? \"Fundamental\" : `Harmonic ${n + 1}`,\n        line: {\n          width: 0.75,\n          color: color + \"33\"\n          // Lighter color for raw\n        },\n        showlegend: n === 0\n      });\n    }\n    traces.push({\n      x: smoothedResponse.frequency.map((f) => f / (n + 1)),\n      y: db(smoothedResponse.magnitude),\n      type: \"scatter\",\n      mode: \"lines\",\n      name: (n === 0 ? \"Fundamental\" : `Harmonic ${n + 1}`) + \" (Smoothed)\",\n      line: {\n        width: 1.5,\n        color\n      }\n    });\n  }\n  plot(\n    traces,\n    tabId,\n    \"Fundamental and Harmonic Distortion\",\n    \"Frequency (Hz)\",\n    \"Amplitude (dBFS)\",\n    { type: \"log\", range: [Math.log10(20), Math.log10(2e4)] },\n    { range: [-85, 5] },\n    {},\n    false\n  );\n}\nfunction plotTHD(farina, windowSize, maxHarmonics, tabId) {\n  const harmonics = farina.harmonics(windowSize, maxHarmonics);\n  const harmonicsFFT = harmonics.map((h, n) => computeFFTFromIR(h, 1e3, 1 / (n + 1)));\n  const smoothedHarmonicsFFT = harmonicsFFT.map((hf) => smoothFFT(hf, 1 / 6, 1 / 96));\n  const fundamental = smoothedHarmonicsFFT[0];\n  const traces = [];\n  const thd = Float32Array.from({ length: fundamental.magnitude.length }, () => 0);\n  for (let i = 0; i < fundamental.magnitude.length; i++) {\n    let sumSquares = 0;\n    for (let n = 1; n < smoothedHarmonicsFFT.length; n++) {\n      sumSquares += Math.pow(smoothedHarmonicsFFT[n].magnitude[i], 2);\n    }\n    thd[i] = Math.sqrt(sumSquares) / fundamental.magnitude[i];\n  }\n  traces.push({\n    x: fundamental.frequency,\n    y: thd.map((v) => v * 100),\n    // Convert to percentage\n    type: \"scatter\",\n    mode: \"lines\",\n    name: \"Total Harmonic Distortion (THD)\",\n    line: {\n      width: 1.5,\n      color: COLORS[0]\n    }\n  });\n  plot(\n    traces,\n    tabId,\n    \"Total Harmonic Distortion\",\n    \"Frequency (Hz)\",\n    \"THD (%)\",\n    { type: \"log\", range: [Math.log10(20), Math.log10(2e4)] },\n    { range: [0, 5] },\n    {},\n    false\n  );\n}\n\n// src/storage.ts\nfunction openIDB() {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.open(\"dunkadunka-storage\", 1);\n    req.onupgradeneeded = () => {\n      const db2 = req.result;\n      if (!db2.objectStoreNames.contains(\"kv\")) {\n        db2.createObjectStore(\"kv\", { keyPath: \"key\" });\n      }\n    };\n    req.onsuccess = () => resolve(req.result);\n    req.onerror = () => reject(req.error);\n  });\n}\nasync function setItem(key, value) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.put({ key, value });\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n    try {\n      setItem(key, value);\n    } catch {\n    }\n  } catch (e) {\n    console.error(\"setItem(idb) failed\", e);\n  }\n}\nasync function getItem(key) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readonly\");\n    const store = tx.objectStore(\"kv\");\n    const req = store.get(key);\n    const res = await new Promise((resolve, reject) => {\n      req.onsuccess = () => resolve(req.result);\n      req.onerror = () => reject(req.error);\n    });\n    return res?.value ?? null;\n  } catch (e) {\n    console.error(\"getItem(idb) failed\", e);\n    return null;\n  }\n}\nasync function removeItem(key) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.delete(key);\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n  } catch (e) {\n    console.error(\"removeItem(idb) failed\", e);\n  }\n}\nasync function clearStorage() {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.clear();\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n    try {\n      sessionStorage.clear();\n    } catch {\n    }\n  } catch (e) {\n    console.error(\"clearStorage(idb) failed\", e);\n  }\n}\nasync function dumpStorage() {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readonly\");\n    const store = tx.objectStore(\"kv\");\n    const req = store.openCursor();\n    req.onsuccess = (event) => {\n      const cursor = event.target.result;\n      if (cursor) {\n        console.log(`Key: ${cursor.key}, Value: ${cursor.value.value}`);\n        cursor.continue();\n      }\n    };\n    req.onerror = () => {\n      console.error(\"dumpStorage(idb) failed\", req.error);\n    };\n  } catch (e) {\n    console.error(\"dumpStorage(idb) failed\", e);\n  }\n}\nvar storage = {\n  setItem,\n  getItem,\n  removeItem,\n  clearStorage,\n  dumpStorage\n};\n\n// src/device-settings.ts\nvar INPUT_KEY = \"preferredAudioInputId\";\nvar OUTPUT_KEY = \"preferredAudioOutputId\";\nfunction openDeviceSettings() {\n  const modal = document.getElementById(\"deviceSettingsModal\");\n  if (modal) {\n    modal.style.display = \"flex\";\n    initDeviceSettings();\n  }\n}\nfunction closeDeviceSettings() {\n  const modal = document.getElementById(\"deviceSettingsModal\");\n  if (modal) {\n    modal.style.display = \"none\";\n  }\n}\nasync function ensureDeviceAccess() {\n  try {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;\n    await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n  } catch (_) {\n  }\n}\nasync function refreshAudioDeviceList() {\n  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n    console.warn(\"MediaDevices API not available\");\n    return;\n  }\n  await ensureDeviceAccess();\n  const devices = await navigator.mediaDevices.enumerateDevices();\n  const inputSel = document.getElementById(\"inputDeviceSelect\");\n  const outputSel = document.getElementById(\"outputDeviceSelect\");\n  if (!inputSel || !outputSel) return;\n  inputSel.innerHTML = '<option value=\"\">Default input</option>';\n  outputSel.innerHTML = '<option value=\"\">Default output</option>';\n  const inputId = localStorage.getItem(INPUT_KEY) || \"\";\n  const outputId = localStorage.getItem(OUTPUT_KEY) || \"\";\n  devices.forEach((d) => {\n    if (d.kind === \"audioinput\") {\n      const opt = document.createElement(\"option\");\n      opt.value = d.deviceId;\n      opt.textContent = d.label || `Microphone (${d.deviceId.slice(0, 8)}\\u2026)`;\n      if (d.deviceId === inputId) opt.selected = true;\n      inputSel.appendChild(opt);\n    } else if (d.kind === \"audiooutput\") {\n      const opt = document.createElement(\"option\");\n      opt.value = d.deviceId;\n      opt.textContent = d.label || `Speaker (${d.deviceId.slice(0, 8)}\\u2026)`;\n      if (d.deviceId === outputId) opt.selected = true;\n      outputSel.appendChild(opt);\n    }\n  });\n  const note = document.getElementById(\"sinkSupportNote\");\n  if (note) {\n    const sinkSupported = typeof HTMLMediaElement !== \"undefined\" && \"setSinkId\" in HTMLMediaElement.prototype;\n    note.textContent = sinkSupported ? \"Output routing supported on this browser.\" : \"Output routing (setSinkId) not supported by this browser.\";\n  }\n}\nasync function applyOutputDevice(deviceId) {\n  const router = document.getElementById(\"appOutputRouter\");\n  if (!router) return;\n  if (\"setSinkId\" in HTMLMediaElement.prototype) {\n    try {\n      await router.setSinkId(deviceId || \"\");\n    } catch (e) {\n      console.warn(\"Failed to set sinkId:\", e);\n    }\n  }\n}\nfunction saveDeviceSelections() {\n  const inputSel = document.getElementById(\"inputDeviceSelect\");\n  const outputSel = document.getElementById(\"outputDeviceSelect\");\n  if (!inputSel || !outputSel) return;\n  localStorage.setItem(INPUT_KEY, inputSel.value || \"\");\n  localStorage.setItem(OUTPUT_KEY, outputSel.value || \"\");\n  applyOutputDevice(outputSel.value || \"\");\n  closeDeviceSettings();\n}\nasync function initDeviceSettings() {\n  await refreshAudioDeviceList();\n  const inputSel = document.getElementById(\"inputDeviceSelect\");\n  const outputSel = document.getElementById(\"outputDeviceSelect\");\n  if (!inputSel || !outputSel) return;\n  inputSel.onchange = () => {\n    localStorage.setItem(INPUT_KEY, inputSel.value || \"\");\n  };\n  outputSel.onchange = () => {\n    localStorage.setItem(OUTPUT_KEY, outputSel.value || \"\");\n    applyOutputDevice(outputSel.value || \"\");\n  };\n}\nif (navigator.mediaDevices && \"ondevicechange\" in navigator.mediaDevices) {\n  navigator.mediaDevices.addEventListener(\"devicechange\", () => {\n    const modal = document.getElementById(\"deviceSettingsModal\");\n    if (modal && modal.style.display === \"flex\") {\n      refreshAudioDeviceList();\n    }\n  });\n}\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const outId = localStorage.getItem(OUTPUT_KEY);\n  if (outId) applyOutputDevice(outId);\n});\nwindow.openDeviceSettings = openDeviceSettings;\nwindow.closeDeviceSettings = closeDeviceSettings;\nwindow.refreshAudioDeviceList = refreshAudioDeviceList;\nwindow.saveDeviceSelections = saveDeviceSelections;\n\n// src/recorder.ts\nvar AudioRecorder = class {\n  constructor(audioContext) {\n    this.audioContext = audioContext;\n  }\n  async record(durationSec) {\n    const recording = [\n      new Float32Array(durationSec * this.audioContext.sampleRate),\n      new Float32Array(durationSec * this.audioContext.sampleRate)\n    ];\n    let pointer = 0;\n    await this.audioContext.audioWorklet.addModule(\"static/buffering-processor.worklet.js\");\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: {\n        echoCancellation: false,\n        noiseSuppression: false,\n        autoGainControl: false\n      }\n    });\n    const streamSource = this.audioContext.createMediaStreamSource(stream);\n    const worklet = new AudioWorkletNode(\n      this.audioContext,\n      \"buffering-processor\",\n      {\n        numberOfInputs: 1,\n        numberOfOutputs: 0,\n        processorOptions: {\n          buffer: null\n        }\n      }\n    );\n    streamSource.connect(worklet);\n    worklet.port.onmessage = (event) => {\n      if (pointer + event.data.buffer[0].length > recording[0].length) {\n        worklet.disconnect();\n        streamSource.disconnect();\n        return new Promise((resolve) => {\n          resolve(recording);\n        });\n      }\n      recording[0].set(event.data.buffer[0], pointer);\n      recording[1].set(event.data.buffer[1], pointer);\n      pointer += event.data.buffer[0].length;\n    };\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        worklet.disconnect();\n        streamSource.disconnect();\n        stream.getTracks().forEach((track) => track.stop());\n        resolve(recording);\n      }, durationSec * 1500);\n    });\n  }\n};\n\n// src/wave.ts\nfunction download(samples, sampleRate = 48e3, name = \"output\") {\n  const channels = 1;\n  const bytesPerSample = 2;\n  const blockAlign = channels * bytesPerSample;\n  const byteRate = sampleRate * blockAlign;\n  const dataSize = samples.length * bytesPerSample;\n  const buffer = new ArrayBuffer(44 + dataSize);\n  const view = new DataView(buffer);\n  function writeString(offset2, str) {\n    for (let i = 0; i < str.length; i++) view.setUint8(offset2 + i, str.charCodeAt(i));\n  }\n  writeString(0, \"RIFF\");\n  view.setUint32(4, 36 + dataSize, true);\n  writeString(8, \"WAVE\");\n  writeString(12, \"fmt \");\n  view.setUint32(16, 16, true);\n  view.setUint16(20, 1, true);\n  view.setUint16(22, channels, true);\n  view.setUint32(24, sampleRate, true);\n  view.setUint32(28, byteRate, true);\n  view.setUint16(32, blockAlign, true);\n  view.setUint16(34, 16, true);\n  writeString(36, \"data\");\n  view.setUint32(40, dataSize, true);\n  let offset = 44;\n  for (let i = 0; i < samples.length; i++, offset += 2) {\n    const s = Math.max(-1, Math.min(1, Number(samples[i])));\n    view.setInt16(offset, s < 0 ? s * 32768 : s * 32767, true);\n  }\n  const blob = new Blob([buffer], { type: \"audio/wav\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = name + `.wav`;\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n  URL.revokeObjectURL(url);\n}\n\n// src/app.ts\nconsole.debug(\"App module loaded\");\nvar root = document.documentElement;\nvar uiColor = \"#0366d6\";\nroot.style.setProperty(\"--color\", uiColor);\nvar tabCounter = 0;\nvar tabsContainer = document.getElementById(\"tabs-outer\");\nvar tabsInnerContainer = document.getElementById(\"tabs\");\nvar tabContents = document.getElementById(\"tab-contents\");\nvar responseFileUploadInput = document.getElementById(\"responseFileUpload\");\nvar referenceFileUploadInput = document.getElementById(\"referenceFileUpload\");\nvar analyzeUploadBtn = document.getElementById(\"analyzeUploadBtn\");\nvar polarReferenceFileInput = document.getElementById(\"polarReferenceFile\");\nvar polarMeasurementsEl = document.getElementById(\"polarMeasurements\");\nvar addPolarMeasurementBtn = document.getElementById(\"addPolarMeasurementBtn\");\nvar analyzePolarBtn = document.getElementById(\"analyzePolarBtn\");\nvar polarStatusEl = document.getElementById(\"polarStatus\");\nresponseFileUploadInput.addEventListener(\"change\", () => {\n  analyzeUploadBtn.disabled = !responseFileUploadInput.files?.length;\n});\nfunction normalizeAngleDeg(angleDeg) {\n  let a = angleDeg % 360;\n  if (a < 0) a += 360;\n  return a;\n}\nfunction getPolarMeasurements() {\n  const rows = Array.from(polarMeasurementsEl.querySelectorAll(\".polar-measurement-row\"));\n  const out = [];\n  for (const row of rows) {\n    const angleInput = row.querySelector(\".polar-angle\");\n    const fileInput = row.querySelector(\".polar-response-file\");\n    if (!angleInput || !fileInput) continue;\n    const file = fileInput.files?.[0];\n    if (!file) continue;\n    const parsed = parseFloat(angleInput.value);\n    const angleDeg = Number.isFinite(parsed) ? normalizeAngleDeg(parsed) : 0;\n    out.push({ angleDeg, file });\n  }\n  return out;\n}\nfunction updatePolarAnalyzeEnabled() {\n  const hasReference = !!polarReferenceFileInput.files?.length;\n  const hasAnyMeasurement = getPolarMeasurements().length > 0;\n  analyzePolarBtn.disabled = !(hasReference && hasAnyMeasurement);\n  if (!hasReference) {\n    polarStatusEl.textContent = \"Select a reference/stimulus file.\";\n  } else if (!hasAnyMeasurement) {\n    polarStatusEl.textContent = \"Add at least one measurement (angle + file).\";\n  } else {\n    polarStatusEl.textContent = \"\";\n  }\n}\nfunction addPolarMeasurementRow(initialAngleDeg = 0) {\n  const row = document.createElement(\"div\");\n  row.className = \"param-row polar-measurement-row\";\n  row.innerHTML = `\n        <label>Angle (deg):</label>\n        <input type=\"number\" class=\"param-input polar-angle\" value=\"${initialAngleDeg}\" step=\"1\" min=\"0\" max=\"360\">\n        <input type=\"file\" class=\"polar-response-file\" accept=\"audio/*,.wav,.mp3,.flac,.ogg\">\n        <button class=\"button-custom button-custom-secondary polar-remove\" type=\"button\">Remove</button>\n    `;\n  polarMeasurementsEl.appendChild(row);\n}\npolarReferenceFileInput.addEventListener(\"change\", updatePolarAnalyzeEnabled);\naddPolarMeasurementBtn.addEventListener(\"click\", () => {\n  addPolarMeasurementRow(0);\n  updatePolarAnalyzeEnabled();\n});\npolarMeasurementsEl.addEventListener(\"input\", (e) => {\n  const t = e.target;\n  if (t.classList.contains(\"polar-angle\")) updatePolarAnalyzeEnabled();\n});\npolarMeasurementsEl.addEventListener(\"change\", (e) => {\n  const t = e.target;\n  if (t.classList.contains(\"polar-response-file\")) updatePolarAnalyzeEnabled();\n});\npolarMeasurementsEl.addEventListener(\"click\", (e) => {\n  const t = e.target;\n  if (!t.classList.contains(\"polar-remove\")) return;\n  const row = t.closest(\".polar-measurement-row\");\n  row?.remove();\n  if (polarMeasurementsEl.querySelectorAll(\".polar-measurement-row\").length === 0) {\n    addPolarMeasurementRow(0);\n  }\n  updatePolarAnalyzeEnabled();\n});\nupdatePolarAnalyzeEnabled();\nvar acquisitionState = {\n  audioContext: null,\n  mediaRecorder: null,\n  recordedChunks: [],\n  oscillatorNode: null,\n  playbackSource: null,\n  isRecording: false\n};\nvar startBtn = document.getElementById(\"startBtn\");\nvar stopBtn = document.getElementById(\"stopBtn\");\nvar playBtn = document.getElementById(\"playBtn\");\nvar stopPlayBtn = document.getElementById(\"stopPlayBtn\");\nvar sweepStartFreqInput = document.getElementById(\"sweepStartFreq\");\nvar sweepEndFreqInput = document.getElementById(\"sweepEndFreq\");\nvar sweepDurationInput = document.getElementById(\"sweepDuration\");\nvar recordingStatusEl = document.getElementById(\"recordingStatus\");\nvar recordingMeterEl = document.getElementById(\"recordingMeter\");\nvar recordingVisualizationEl = document.getElementById(\"recordingVisualization\");\nvar recordedAudioContainer = document.getElementById(\"recordedAudioContainer\");\nvar recordedAudioEl = document.getElementById(\"recordedAudio\");\nvar analyzeRecordingBtn = document.getElementById(\"analyzeRecordingBtn\");\nvar viewWaveformBtn = document.getElementById(\"viewWaveformBtn\");\nvar channelSelectionContainer = document.getElementById(\"channelSelectionContainer\");\nvar channelSelect = document.getElementById(\"channelSelect\");\nasync function initializeAudioContext() {\n  if (!acquisitionState.audioContext) {\n    acquisitionState.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  }\n  if (acquisitionState.audioContext.state === \"suspended\") {\n    await acquisitionState.audioContext.resume();\n  }\n  return acquisitionState.audioContext;\n}\nasync function detectAndSetupChannels() {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }\n    });\n    const audioContext = await initializeAudioContext();\n    const analyser = audioContext.createAnalyser();\n    const source = audioContext.createMediaStreamSource(stream);\n    source.connect(analyser);\n    const channelCount = source.mediaStream.getAudioTracks()[0].getSettings()?.channelCount || 1;\n    stream.getTracks().forEach((track) => track.stop());\n    channelSelect.innerHTML = \"\";\n    for (let i = 0; i < channelCount; i++) {\n      const option = document.createElement(\"option\");\n      option.value = i.toString();\n      const channelNames = [\"Left\", \"Right\", \"Center\", \"LFE\", \"Back Left\", \"Back Right\"];\n      option.textContent = `Channel ${i + 1}${channelNames[i] ? ` (${channelNames[i]})` : \"\"}`;\n      channelSelect.appendChild(option);\n    }\n    if (channelCount > 1) {\n      channelSelectionContainer.style.display = \"flex\";\n    } else {\n      channelSelectionContainer.style.display = \"none\";\n    }\n  } catch (error) {\n    console.error(\"Error detecting channels:\", error);\n    channelSelectionContainer.style.display = \"none\";\n  }\n}\ntabsContainer.addEventListener(\"click\", (e) => {\n  const target = e.target;\n  if (target.classList.contains(\"tab\") && target.dataset.tab === \"acquisition\") {\n    detectAndSetupChannels();\n  }\n});\nvar recorded = [Float32Array.from([]), Float32Array.from([])];\nasync function startRecordingAndPlayback() {\n  try {\n    const audioContext = await initializeAudioContext();\n    const startFreq = parseFloat(sweepStartFreqInput.value);\n    const endFreq = parseFloat(sweepEndFreqInput.value);\n    const duration = parseFloat(sweepDurationInput.value);\n    const preRecordTime = 0.5;\n    const postRecordTime = 1;\n    const totalRecordTime = preRecordTime + duration + postRecordTime;\n    const [sweepSignal, ,] = audio.chirp(startFreq, endFreq, duration);\n    const audioBuffer = audioContext.createBuffer(1, sweepSignal.length, audioContext.sampleRate);\n    const channelData = audioBuffer.getChannelData(0);\n    channelData.set(sweepSignal);\n    const sourceGain = audioContext.createGain();\n    sourceGain.gain.value = 0.5;\n    recordingStatusEl.textContent = `Recording for ${totalRecordTime.toFixed(1)}s...`;\n    recordingVisualizationEl.style.display = \"block\";\n    const recorder = new AudioRecorder(audioContext);\n    recorder.record(totalRecordTime).then((recordingData) => {\n      recorded = recordingData;\n      stopRecording();\n    });\n    startBtn.disabled = true;\n    stopBtn.disabled = false;\n    playBtn.disabled = true;\n    sweepStartFreqInput.disabled = true;\n    sweepEndFreqInput.disabled = true;\n    sweepDurationInput.disabled = true;\n    setTimeout(() => {\n      acquisitionState.playbackSource = audioContext.createBufferSource();\n      acquisitionState.playbackSource.buffer = audioBuffer;\n      acquisitionState.playbackSource.connect(sourceGain);\n      sourceGain.connect(audioContext.destination);\n      acquisitionState.playbackSource.start();\n    }, preRecordTime * 1e3);\n    setTimeout(() => {\n      stopRecording();\n    }, totalRecordTime * 1e3);\n  } catch (error) {\n    console.error(\"Error starting recording:\", error);\n    recordingStatusEl.textContent = `Error: ${error.message}`;\n    recordingStatusEl.style.color = \"#d73a49\";\n  }\n}\nasync function playbackOnly() {\n  try {\n    const audioContext = await initializeAudioContext();\n    const startFreq = parseFloat(sweepStartFreqInput.value);\n    const endFreq = parseFloat(sweepEndFreqInput.value);\n    const duration = parseFloat(sweepDurationInput.value);\n    const [sweepSignal] = audio.chirp(startFreq, endFreq, duration);\n    const audioBuffer = audioContext.createBuffer(1, sweepSignal.length, audioContext.sampleRate);\n    const channelData = audioBuffer.getChannelData(0);\n    channelData.set(sweepSignal);\n    const sourceGain = audioContext.createGain();\n    sourceGain.gain.value = 0.5;\n    acquisitionState.playbackSource = audioContext.createBufferSource();\n    acquisitionState.playbackSource.buffer = audioBuffer;\n    acquisitionState.playbackSource.connect(sourceGain);\n    sourceGain.connect(audioContext.destination);\n    acquisitionState.playbackSource.start();\n    recordingStatusEl.textContent = `Playing sweep...`;\n    recordingStatusEl.style.color = \"#0366d6\";\n    playBtn.disabled = true;\n    stopPlayBtn.disabled = false;\n    setTimeout(() => {\n      stopPlayback();\n    }, (duration + 0.5) * 1e3);\n  } catch (error) {\n    console.error(\"Error during playback:\", error);\n    recordingStatusEl.textContent = `Error: ${error.message}`;\n    recordingStatusEl.style.color = \"#d73a49\";\n  }\n}\nfunction stopRecording() {\n  recordingStatusEl.textContent = \"Recording complete. Ready to analyze.\";\n  recordingStatusEl.style.color = \"#28a745\";\n  startBtn.disabled = false;\n  stopBtn.disabled = true;\n  playBtn.disabled = false;\n  sweepStartFreqInput.disabled = false;\n  sweepEndFreqInput.disabled = false;\n  sweepDurationInput.disabled = false;\n  recordedAudioContainer.style.display = \"block\";\n}\nfunction stopPlayback() {\n  if (acquisitionState.playbackSource) {\n    try {\n      acquisitionState.playbackSource.stop();\n    } catch (e) {\n    }\n  }\n  recordingStatusEl.textContent = \"Playback stopped.\";\n  playBtn.disabled = false;\n  stopPlayBtn.disabled = true;\n}\nstartBtn.addEventListener(\"click\", startRecordingAndPlayback);\nstopBtn.addEventListener(\"click\", stopRecording);\nplayBtn.addEventListener(\"click\", playbackOnly);\nstopPlayBtn.addEventListener(\"click\", stopPlayback);\nanalyzeRecordingBtn.addEventListener(\"click\", async () => {\n  console.log(\"Analyzing recording...\");\n  try {\n    const recordedAudio = Audio.fromSamples(recorded[0], 48e3);\n    download(recorded[0], 48e3, \"recorded_audio.wav\");\n    const startFreq = parseFloat(sweepStartFreqInput.value);\n    const endFreq = parseFloat(sweepEndFreqInput.value);\n    const duration = parseFloat(sweepDurationInput.value);\n    const [sweepSignal] = audio.chirp(startFreq, endFreq, duration);\n    const referenceAudio = Audio.fromSamples(sweepSignal, 48e3);\n    const now = /* @__PURE__ */ new Date();\n    const dateTime = now.toLocaleString(\"sv-SE\", {\n      year: \"2-digit\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      hour12: false\n    }).replace(\",\", \"\");\n    const recordingName = `${dateTime}`;\n    createAnalysisTab(\n      recordedAudio.applyGain(1 / 16384),\n      referenceAudio.applyGain(1 / 16384),\n      recordingName,\n      `${startFreq}-${endFreq}Hz`\n    );\n  } catch (error) {\n    console.error(\"Error analyzing recording:\", error);\n    alert(\"Error analyzing recording: \" + error.message);\n  }\n});\nwindow.addEventListener(\"beforeunload\", (e) => {\n  try {\n    saveState();\n  } catch (err) {\n    console.error(\"Failed to save state on beforeunload:\", err);\n  }\n});\ntabsContainer.addEventListener(\"click\", (e) => {\n  const target = e.target;\n  if (target.classList.contains(\"tab-close\")) {\n    const tab = target.parentElement;\n    const tabId = tab.dataset.tab;\n    if (tabId == \"upload\") return;\n    console.debug(\"Closing tab\", tabId);\n    tab.remove();\n    document.querySelector(`[data-content=\"${tabId}\"]`)?.remove();\n    storage.removeItem(`analysis-${tabId}`).catch((err) => console.error(\"Failed to remove analysis from storage:\", err));\n    if (tab.classList.contains(\"active\")) {\n      switchTab(\"upload\");\n    }\n    saveState();\n    e.stopPropagation();\n  } else if (target.classList.contains(\"tab\")) {\n    const tabId = target.dataset.tab;\n    if (tabId) {\n      switchTab(tabId);\n    }\n  }\n});\nfunction switchTab(tabId) {\n  document.querySelectorAll(\".tab\").forEach((t) => t.classList.remove(\"active\"));\n  document.querySelectorAll(\".tab-content\").forEach((c) => c.classList.remove(\"active\"));\n  document.querySelector(`[data-tab=\"${tabId}\"]`)?.classList.add(\"active\");\n  document.querySelector(`[data-content=\"${tabId}\"]`)?.classList.add(\"active\");\n}\nanalyzeUploadBtn.addEventListener(\"click\", async () => {\n  const responseFile = responseFileUploadInput.files?.[0];\n  const referenceFile = referenceFileUploadInput.files?.[0];\n  if (!responseFile) return;\n  analyzeUploadBtn.disabled = true;\n  analyzeUploadBtn.textContent = \"Analyzing...\";\n  try {\n    const responseData = await audio.loadAudioFile(responseFile);\n    const referenceData = referenceFile ? await audio.loadAudioFile(referenceFile) : null;\n    createAnalysisTab(\n      responseData.applyGain(1 / 16384),\n      referenceData ? referenceData.applyGain(1 / 16384) : null,\n      responseFile.name,\n      referenceFile?.name || null\n    );\n  } catch (error) {\n    alert(\"Error analyzing files: \" + error.message);\n  } finally {\n    analyzeUploadBtn.disabled = false;\n    analyzeUploadBtn.textContent = \"Analyze Frequency Response\";\n  }\n});\nanalyzePolarBtn.addEventListener(\"click\", async () => {\n  const referenceFile = polarReferenceFileInput.files?.[0];\n  if (!referenceFile) return;\n  const measurements = getPolarMeasurements();\n  if (measurements.length === 0) {\n    alert(\"Please add at least one measurement (angle + file).\");\n    return;\n  }\n  const oldText = analyzePolarBtn.textContent || \"Analyze Polar Directivity\";\n  analyzePolarBtn.disabled = true;\n  analyzePolarBtn.textContent = \"Analyzing...\";\n  try {\n    const referenceData = (await audio.loadAudioFile(referenceFile)).applyGain(1 / 16384);\n    const loaded = await Promise.all(\n      measurements.map(async (m) => ({\n        angleDeg: m.angleDeg,\n        audio: (await audio.loadAudioFile(m.file)).applyGain(1 / 16384)\n      }))\n    );\n    loaded.sort((a, b) => a.angleDeg - b.angleDeg);\n    const responseAudios = loaded.map((x) => x.audio);\n    const anglesDeg = loaded.map((x) => x.angleDeg);\n    createDirectivityPlotTab(responseAudios, referenceData, anglesDeg);\n  } catch (error) {\n    alert(\"Error analyzing polar files: \" + error.message);\n  } finally {\n    analyzePolarBtn.textContent = oldText;\n    updatePolarAnalyzeEnabled();\n  }\n});\nfunction createAnalysisTab(responseData, referenceData, filename, referenceFilename) {\n  tabCounter++;\n  const tabId = `analysis-${tabCounter}`;\n  let shortName = filename.length > 20 ? filename.substring(0, 17) + \"...\" : filename;\n  if (referenceFilename != null) {\n    const shortReferenceName = referenceFilename?.length > 20 ? referenceFilename.substring(0, 17) + \"...\" : referenceFilename;\n    shortName += \" / \" + shortReferenceName;\n  }\n  const tab = document.createElement(\"button\");\n  tab.className = \"tab tab-closable\";\n  tab.dataset.tab = tabId;\n  tab.innerHTML = `<span class=\"tab-icon-analysis\"></span>${shortName} <span class=\"tab-close\">\\u2715</span>`;\n  tabsInnerContainer.appendChild(tab);\n  const content = document.createElement(\"div\");\n  content.className = \"tab-content\";\n  content.dataset.content = tabId;\n  content.innerHTML = `\n    <!-- nav class=\"tab-menu-bar\">\n                <div>\n                    <label for=\"smoothing-${tabId}\">Smoothing</label>\n                    <select id=\"smoothing-${tabId}\" class=\"smoothing-select\" aria-label=\"Smoothing factor\">\n                        <option value=\"0\">None</option>\n                        <option value=\"1/3\">1/3 octave</option>\n                        <option value=\"1/6\" selected>1/6 octave</option>\n                        <option value=\"1/12\">1/12 octave</option>\n                        <option value=\"1/24\">1/24 octave</option>\n                        <option value=\"1/48\">1/48 octave</option>\n                    </select>\n                </div>\n            </nav> <h5 class=\"text-xs italic text-gray-600\">Frequency Response Analysis of ${filename}${referenceFilename ? \" / \" + referenceFilename : \"\"}</h5 -->\n        <button class=\"sidecar-toggle\" id=\"sidebar-toggle-${tabId}\" title=\"Toggle Sidecar\">Open settings pane</button>\n        <div class=\"flex h-full\">\n            <div class=\"flex-none w-86 border-r border-[#ddd] p-2 relative sidecar\" style=\"transition:50ms linear;\">\n                <div class=\"section\">\n                    <div class=\"title\">Settings</div>\n                    <p><i>There are no settings for this analysis.</i></p>\n                </div>\n                <div class=\"section\">\n                    <div class=\"title\">Plots</div>\n                    <ul class=\"list\" id=\"plot-list-${tabId}\">\n                        <!--li><input type=\"checkbox\" id=\"checkbox-magnitude-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-magnitude-${tabId}\">Magnitude</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-phase-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-phase-${tabId}\">Phase</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-ir-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-ir-${tabId}\">Impulse Response</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-ir-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-ir-${tabId}\">Fundamental + Harmonic Distortion</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-distortion-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-distortion-${tabId}\">Distortion</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-distortion-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-distortion-${tabId}\">Sound Pressure Level</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-deconvoluted-ir-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-deconvoluted-ir-${tabId}\">Deconvoluted Impulse Response</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-stimulus-waveform-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-stimulus-waveform-${tabId}\">Stimulus Waveform</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-recorded-waveform-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-recorded-waveform-${tabId}\">Recorded Waveform</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-recorded-noise-floor-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-recorded-noise-floor-${tabId}\">Recorded Noise Floor</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-target-curve-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-target-curve-${tabId}\">Target Curve<button class=\"float-right text-xs cursor-pointer\" style=\"color: #bbb; padding-top: 3px\">Set</button></label></li-->\n                    </ul>\n                </div>\n                <div class=\"section\">\n                    <div class=\"title\">Properties</div>\n                    <p><i>There are no properties for this analysis.</i></p>\n                </div>\n                <div id=\"resize-handle\" class=\"resize-handle\"></div>\n            </div>\n            <div class=\"flex-1 main-content\">\n                <div class=\"grid grid-cols-6 gap-[1px] bg-[#ddd] border-b border-[#ddd] plot-outer\">\n                </div>\n            </div>\n        </div>\n       \n        \n    `;\n  tabContents.appendChild(content);\n  switchTab(tabId);\n  const responseSamples = responseData.getChannelData(0);\n  const responseFFT = computeFFT(responseSamples);\n  const smoothedResponseFFT = smoothFFT(responseFFT, 1 / 6, 1 / 48);\n  let referenceSamples = Float32Array.from([]);\n  plot(\n    [\n      { x: responseFFT.frequency, y: db(responseFFT.magnitude), name: \"Recorded signal\", line: { color: \"#0366d666\", width: 0.75 } },\n      { x: smoothedResponseFFT.frequency, y: db(smoothedResponseFFT.magnitude), name: \"Recorded signal (Smoothed)\", line: { color: \"#0366d6\", width: 1.5 } }\n    ],\n    tabId,\n    \"Recorded Spectrum\",\n    \"Frequency (Hz)\",\n    \"Amplitude (dBFS)\",\n    { type: \"log\", range: [Math.log10(20), Math.log10(2e4)] },\n    { range: [-85, 5] },\n    {},\n    true\n  );\n  plot(\n    [\n      { x: linspace(0, responseSamples.length / 48e3, responseSamples.length), y: responseSamples, name: \"Recorded signal\", line: { color: \"#0366d6ff\", width: 0.75 } }\n    ],\n    tabId,\n    \"Recorded Waveform\",\n    \"Time (s)\",\n    \"Amplitude\",\n    {},\n    {},\n    {},\n    true\n  );\n  if (referenceData) {\n    referenceSamples = referenceData.getChannelData(0);\n    const referenceFFT = computeFFT(referenceSamples);\n    const smoothedReferenceFFT = smoothFFT(referenceFFT, 1 / 6, 1 / 48);\n    plot(\n      [\n        { x: referenceFFT.frequency, y: db(referenceFFT.magnitude), name: \"Stimulus signal\", line: { color: \"#0366d666\", width: 0.75 } },\n        { x: smoothedReferenceFFT.frequency, y: db(smoothedReferenceFFT.magnitude), name: \"Stimulus signal (Smoothed)\", line: { color: \"#0366d6\", width: 1.5 } }\n      ],\n      tabId,\n      \"Stimulus Spectrum\",\n      \"Frequency (Hz)\",\n      \"Amplitude (dBFS)\",\n      { type: \"log\", range: [Math.log10(20), Math.log10(2e4)] },\n      { range: [-85, 5] },\n      {},\n      true\n    );\n    plot(\n      [\n        { x: linspace(0, referenceSamples.length / 48e3, referenceSamples.length), y: referenceSamples, name: \"Stimulus signal\", line: { color: \"#0366d6ff\", width: 0.75 } }\n      ],\n      tabId,\n      \"Stimulus Waveform\",\n      \"Time (s)\",\n      \"Amplitude\",\n      {},\n      {},\n      {},\n      true\n    );\n    const ir = twoChannelImpulseResponse(responseSamples, referenceSamples);\n    const farina = new Farina(referenceSamples, 20, 2e4, 48e3);\n    const farina_ir = farina.deconvolvedResponse(responseSamples);\n    plotDistortion(farina, 0.1, 5, tabId);\n    plotTHD(farina, 0.1, 5, tabId);\n    console.log(\"Impulse response peak at\", farina.lag_of_harmonic(2));\n    plot(\n      [\n        { x: ir.t, y: ir.ir, type: \"scatter\", mode: \"lines\", name: \"Dual-FFT Impulse Response\", line: { color: COLORS[0], width: 0.75 } }\n      ],\n      tabId,\n      \"Impulse Response\",\n      \"Time (s)\",\n      \"Amplitude\",\n      {},\n      {},\n      {},\n      false\n    );\n    plot(\n      [\n        { x: [-max(farina_ir.t), max(farina_ir.t)], y: [-200, -200], showlegend: false },\n        { x: farina_ir.t, y: db(farina_ir.ir.map((x) => Math.abs(x))), type: \"scatter\", mode: \"lines\", fill: \"tonexty\", name: \"Farina Impulse Response\", line: { color: COLORS[0], width: 0.75 }, fillcolor: COLORS[0] },\n        { x: [-0.05, -0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"Fundamental window start\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [0.05, 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"Fundamental window end\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(2) - 0.05, -farina.lag_of_harmonic(2) - 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H2 window start\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(2) + 0.05, -farina.lag_of_harmonic(2) + 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H2 window end\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(3) - 0.05, -farina.lag_of_harmonic(3) - 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H3 window start\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(3) + 0.05, -farina.lag_of_harmonic(3) + 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H3 window end\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(4) - 0.05, -farina.lag_of_harmonic(4) - 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H4 window start\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(4) + 0.05, -farina.lag_of_harmonic(4) + 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H4 window end\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(5) - 0.05, -farina.lag_of_harmonic(5) - 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H5 window start\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(5) + 0.05, -farina.lag_of_harmonic(5) + 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H5 window end\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(6) - 0.05, -farina.lag_of_harmonic(6) - 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H6 window start\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(6) + 0.05, -farina.lag_of_harmonic(6) + 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H6 window end\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(7) - 0.05, -farina.lag_of_harmonic(7) - 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H7 window start\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false },\n        { x: [-farina.lag_of_harmonic(7) + 0.05, -farina.lag_of_harmonic(7) + 0.05], y: [-999, 999], type: \"scatter\", mode: \"lines\", name: \"H7 window end\", line: { color: \"#00000033\", width: 0.75 }, hoverinfo: \"skip\", showlegend: false }\n      ],\n      tabId,\n      \"Deconvolved Response\",\n      \"Time (s)\",\n      \"Amplitude\",\n      { range: [-1, 1] },\n      { range: [-150, 10] },\n      {},\n      false\n    );\n    const transferFunction = computeFFTFromIR(ir);\n    const smoothedFreqResponse = smoothFFT(transferFunction, 1 / 6, 1 / 48);\n    const gd = groupDelays(transferFunction, 1e3);\n    plot(\n      [\n        { x: transferFunction.frequency, y: db(transferFunction.magnitude), name: \"Magnitude\", line: { color: \"#0366d666\", width: 0.75 } },\n        { x: smoothedFreqResponse.frequency, y: db(smoothedFreqResponse.magnitude), name: \"Magnitude (Smoothed)\", line: { color: \"#0366d6\", width: 1.5 } }\n      ],\n      tabId,\n      \"Transfer Function\",\n      \"Frequency (Hz)\",\n      \"Amplitude (dBFS)\",\n      { type: \"log\", range: [Math.log10(20), Math.log10(2e4)] },\n      { range: [-85, 5] },\n      {},\n      false\n    );\n    plot(\n      [\n        { x: transferFunction.frequency, y: transferFunction.phase, name: \"Phase\", line: { color: \"#0366d666\", width: 0.75 } },\n        { x: smoothedFreqResponse.frequency, y: smoothedFreqResponse.phase, name: \"Phase (Smoothed)\", line: { color: \"#0366d6\", width: 1.5 } }\n      ],\n      tabId,\n      \"Phase\",\n      \"Frequency (Hz)\",\n      \"Amplitude (dBFS)\",\n      { type: \"log\", range: [Math.log10(20), Math.log10(2e4)] },\n      { range: [-720, 720] },\n      {},\n      false\n    );\n    plot(\n      [\n        { x: transferFunction.frequency, y: gd, name: \"Group Delay\", line: { color: COLORS[0], width: 1.5, dash: \"dot\" } }\n      ],\n      tabId,\n      \"Group Delay\",\n      \"Frequency (Hz)\",\n      \"Group Delay (ms)\",\n      { type: \"log\", range: [Math.log10(20), Math.log10(2e4)] },\n      { range: [-20, 20] },\n      {},\n      false\n    );\n    (() => {\n      const sr = responseData.sampleRate ?? referenceData?.sampleRate ?? 48e3;\n      const n = responseSamples.length;\n      if (n < 4096) return;\n      const windowSize = 2048;\n      const targetFrames = 320;\n      const minHop = 256;\n      const rawFrames = Math.max(1, Math.floor((n - windowSize) / minHop) + 1);\n      const hop = rawFrames > targetFrames ? Math.max(minHop, Math.ceil((n - windowSize) / targetFrames)) : minHop;\n      const frames = Math.max(1, Math.floor((n - windowSize) / hop) + 1);\n      const win = new Float32Array(windowSize);\n      for (let i = 0; i < windowSize; i++) {\n        win[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (windowSize - 1)));\n      }\n      const firstFrame = new Float32Array(windowSize);\n      firstFrame.set(responseSamples.subarray(0, windowSize));\n      for (let i = 0; i < windowSize; i++) firstFrame[i] *= win[i];\n      const firstFFT = computeFFT(firstFrame);\n      const freqs = Array.from(firstFFT.frequency);\n      const bins = freqs.length;\n      const z = Array.from({ length: bins }, () => []);\n      const times = [];\n      for (let frame = 0; frame < frames; frame++) {\n        const start = frame * hop;\n        const slice = responseSamples.subarray(start, start + windowSize);\n        const windowed = new Float32Array(windowSize);\n        windowed.set(slice);\n        for (let i = 0; i < windowSize; i++) windowed[i] *= win[i];\n        const fft = computeFFT(windowed);\n        const magDb = db(fft.magnitude);\n        for (let k = 0; k < bins; k++) {\n          z[k].push(magDb[k]);\n        }\n        times.push((start + windowSize / 2) / sr);\n      }\n      plot(\n        [\n          {\n            type: \"heatmap\",\n            x: times,\n            y: freqs,\n            z,\n            colorscale: \"Electric\",\n            zmin: -120,\n            zmax: 0,\n            colorbar: { title: \"dBFS\" }\n          }\n        ],\n        tabId,\n        \"Recorded Spectrogram\",\n        \"Time (s)\",\n        \"Frequency (Hz)\",\n        {},\n        { type: \"log\", range: [Math.log10(20), Math.log10(2e4)] },\n        { margin: { l: 60, r: 20, t: 40, b: 50 } },\n        false\n      );\n    })();\n  }\n  saveState();\n  storage.setItem(`${tabId}`, JSON.stringify({\n    filename,\n    referenceFilename,\n    responseSamples: Array.from(responseSamples),\n    referenceSamples: referenceSamples.length > 0 ? Array.from(referenceSamples) : null\n  })).catch((err) => console.error(\"Failed to persist analysis:\", err));\n  function initResize(e) {\n    e.preventDefault();\n    window.addEventListener(\"mousemove\", resize, false);\n    window.addEventListener(\"mouseup\", stopResize, false);\n    console.log(\"Init resize\");\n    document.body.style.cursor = \"col-resize\";\n  }\n  function resize(e) {\n    const container = content.querySelector(\".flex\");\n    const handle = document.getElementById(\"resize-handle\")?.parentElement;\n    const rect = container.getBoundingClientRect();\n    const newWidth = e.clientX - rect.left;\n    if (newWidth > 150 && newWidth < rect.width - 150) {\n      handle.style.width = `${newWidth}px`;\n    }\n  }\n  function stopResize() {\n    window.removeEventListener(\"mousemove\", resize, false);\n    window.removeEventListener(\"mouseup\", stopResize, false);\n    window.dispatchEvent(new Event(\"resize\"));\n    document.body.style.cursor = \"default\";\n  }\n  document.getElementById(\"resize-handle\")?.addEventListener(\"mousedown\", initResize, false);\n}\nfunction createDirectivityPlotTab(responseDatas, referenceData, anglesDeg) {\n  if (responseDatas.length === 0 || referenceData.length === 0) return;\n  tabCounter++;\n  const directivityTabId = `directivity-${tabCounter}`;\n  const shortName = `Directivity (${responseDatas.length})`;\n  const tab = document.createElement(\"button\");\n  tab.className = \"tab tab-closable\";\n  tab.dataset.tab = directivityTabId;\n  tab.innerHTML = `<span class=\"tab-icon-analysis\"></span>${shortName} <span class=\"tab-close\">\\u2715</span>`;\n  tabsInnerContainer.appendChild(tab);\n  const content = document.createElement(\"div\");\n  content.className = \"tab-content\";\n  content.dataset.content = directivityTabId;\n  content.innerHTML = `\n        <div class=\"flex h-full\">\n        <div class=\"flex-1 main-content\">\n            <div class=\"grid grid-cols-6 gap-[1px] bg-[#ddd] border-b border-[#ddd] plot-outer\"></div>\n        </div>\n        </div>\n    `;\n  tabContents.appendChild(content);\n  switchTab(directivityTabId);\n  const useCustomAngles = !!anglesDeg && anglesDeg.length === responseDatas.length;\n  const angles = useCustomAngles ? anglesDeg.map(normalizeAngleDeg) : responseDatas.map((_, i) => 360 * i / responseDatas.length);\n  const referenceSamples = Float32Array.from(referenceData.getChannelData(0));\n  const transfers = responseDatas.map((resp) => {\n    const len = Math.min(resp.getChannelData(0).length, referenceSamples.length);\n    const ir = twoChannelImpulseResponse(\n      resp.getChannelData(0).subarray(0, len),\n      referenceSamples.subarray(0, len)\n    );\n    return smoothFFT(computeFFTFromIR(ir), 1 / 3, 1 / 48);\n  });\n  const baseFreq = transfers[0]?.frequency;\n  if (!baseFreq || baseFreq.length === 0) return;\n  const normHz = 1e3;\n  let normIdx = 0;\n  let best = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < baseFreq.length; i++) {\n    const d = Math.abs(baseFreq[i] - normHz);\n    if (d < best) {\n      best = d;\n      normIdx = i;\n    }\n  }\n  transfers.push(transfers[0]);\n  angles.push(360);\n  const z = transfers.map((tf) => {\n    const magDb = db(tf.magnitude);\n    const ref = magDb[normIdx] ?? 0;\n    return magDb.map((v) => v - ref);\n  });\n  plot(\n    [\n      {\n        type: \"heatmap\",\n        x: Array.from(baseFreq),\n        y: angles,\n        z,\n        colorscale: \"Jet\",\n        zmin: -50,\n        zmax: 0,\n        colorbar: { title: \"dB (norm @ 1 kHz)\" }\n      }\n    ],\n    directivityTabId,\n    \"Directivity Map\",\n    \"Frequency (Hz)\",\n    \"Angle (deg)\",\n    { type: \"log\", range: [Math.log10(20), Math.log10(2e4)] },\n    { range: [0, 360] },\n    { margin: { l: 60, r: 20, t: 40, b: 50 } },\n    false\n  );\n}\nfunction saveState() {\n  const tabs = Array.from(document.querySelectorAll(\".tab[data-tab]\")).map((tab) => ({\n    id: tab.dataset.tab,\n    name: tab.textContent?.replace(\"\\xD7\", \"\").trim()\n  }));\n  storage.setItem(\"tabs\", JSON.stringify(tabs));\n  console.log(\"Saved state with tabs:\", tabs);\n}\nasync function loadState() {\n  try {\n    const savedTabs = await storage.getItem(\"tabs\");\n    if (!savedTabs) return;\n    const tabs = JSON.parse(savedTabs);\n    console.log(\"Loading saved tabs:\", tabs);\n    for (const tab of tabs) {\n      const raw = await storage.getItem(`${tab.id}`);\n      const analysisData = raw ? JSON.parse(raw) : null;\n      console.log(\"Restoring analysis data for tab\", tab.id, analysisData);\n      if (analysisData) {\n        createAnalysisTab(Audio.fromSamples(Float32Array.from(analysisData.responseSamples)), analysisData.referenceSamples ? Audio.fromSamples(Float32Array.from(analysisData.referenceSamples)) : null, analysisData.filename, analysisData.referenceFilename);\n      }\n    }\n  } catch (e) {\n    console.error(\"Failed to load saved state:\", e);\n  }\n}\nloadState();\n","console.debug(\"Math module loaded\");\n\nexport function logspace(start: number, end: number, num: number): Float32Array {\n    const logStart = Math.log10(start);\n    const logEnd = Math.log10(end);\n    const logStep = (logEnd - logStart) / (num - 1);\n    return Float32Array.from({ length: num }, (_, i) => Math.pow(10, logStart + i * logStep));\n}\n\nexport function linspace(start: number, end: number, num: number): Float32Array {\n    if (num === 1) return Float32Array.from([start]);\n    const step = (end - start) / (num - 1);\n    return Float32Array.from({ length: num }, (_, i) => start + i * step);\n}\n\nexport function closest(num: number, arr: Float32Array): number {\n    let curr = arr[0];\n    let diff = Math.abs(num - curr);\n    let index = 0;\n    for (let val = 0; val < arr.length; val++) {\n        const newDiff = Math.abs(num - arr[val]);\n        if (newDiff < diff) {\n            diff = newDiff;\n            curr = arr[val];\n            index = val;\n        }\n    }\n    return index;\n}\n\nexport function clamp(v: number, lower: number, upper: number): number {\n    return Math.max(lower, Math.min(upper, v));\n}\n\nexport const average = (array: Float32Array): number => array.reduce((a, b) => a + b) / array.length;\n\nexport const abs = (re: number, im: number = 0): number => Math.sqrt(re * re + im * im);\n\nexport const mod = (n: number, m: number): number => ((n % m) + m) % m;\n\nexport const nextPow2 = (v: number): number => {\n        let p = 1;\n        while (p < v) p <<= 1;\n        return p;\n    };\n\nexport function max(arr: Float32Array): number {\n    let maxVal = -Infinity;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] > maxVal) maxVal = Math.abs(arr[i]);\n    }\n    return maxVal;\n}","/* This software is licensed under the MIT License.\n\nCopyright Fedor Indutny, 2017.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\nconsole.debug(\"FFT module loaded\");\n\nexport class FFT {\n  size: number;\n  private _csize: number;\n  table: number[];\n  private _width: number;\n  private _bitrev: number[];\n  private _out: number[] | null;\n  private _data: number[] | null;\n  private _inv: number;\n\n  constructor(size: number) {\n    this.size = size | 0;\n    if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n      throw new Error('FFT size must be a power of two and bigger than 1');\n\n    this._csize = size << 1;\n\n    // NOTE: Use of `var` is intentional for old V8 versions\n    const table = new Array<number>(this.size * 2);\n    for (let i = 0; i < table.length; i += 2) {\n      const angle = Math.PI * i / this.size;\n      table[i] = Math.cos(angle);\n      table[i + 1] = -Math.sin(angle);\n    }\n    this.table = table;\n\n    // Find size's power of two\n    let power = 0;\n    for (let t = 1; this.size > t; t <<= 1)\n      power++;\n\n    // Calculate initial step's width:\n    //   * If we are full radix-4 - it is 2x smaller to give inital len=8\n    //   * Otherwise it is the same as `power` to give len=4\n    this._width = power % 2 === 0 ? power - 1 : power;\n\n    // Pre-compute bit-reversal patterns\n    this._bitrev = new Array<number>(1 << this._width);\n    for (let j = 0; j < this._bitrev.length; j++) {\n      this._bitrev[j] = 0;\n      for (let shift = 0; shift < this._width; shift += 2) {\n        const revShift = this._width - shift - 2;\n        this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n      }\n    }\n\n    this._out = null;\n    this._data = null;\n    this._inv = 0;\n  }\n\n  fromComplexArray(complex: number[] | Float32Array, storage?: number[] | Float32Array): number[] | Float32Array {\n    const res = storage || new Array<number>(complex.length >>> 1);\n    for (let i = 0; i < complex.length; i += 2)\n      res[i >>> 1] = complex[i];\n    return res;\n  }\n\n  createComplexArray(): number[] {\n    const res = new Array<number>(this._csize);\n    for (let i = 0; i < res.length; i++)\n      res[i] = 0;\n    return res;\n  }\n\n  toComplexArray(input: number[] | Float32Array, storage?: number[] | Float32Array): number[] | Float32Array {\n    const res = storage || this.createComplexArray();\n    for (let i = 0; i < res.length; i += 2) {\n      res[i] = input[i >>> 1];\n      res[i + 1] = 0;\n    }\n    return res;\n  }\n\n  completeSpectrum(spectrum: number[] | Float32Array): void {\n    const size = this._csize;\n    const half = size >>> 1;\n    for (let i = 2; i < half; i += 2) {\n      spectrum[size - i] = spectrum[i];\n      spectrum[size - i + 1] = -spectrum[i + 1];\n    }\n  }\n\n  transform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 0;\n    this._transform4();\n    this._out = null;\n    this._data = null;\n  }\n\n  realTransform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 0;\n    this._realTransform4();\n    this._out = null;\n    this._data = null;\n  }\n\n  inverseTransform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 1;\n    this._transform4();\n    for (let i = 0; i < out.length; i++)\n      out[i] /= this.size;\n    this._out = null;\n    this._data = null;\n  }\n\n  // radix-4 implementation\n  //\n  // NOTE: Uses of `var` are intentional for older V8 version that do not\n  // support both `let compound assignments` and `const phi`\n  private _transform4(): void {\n    const out = this._out!;\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = (size / step) << 1;\n\n    let outOff: number;\n    let t: number;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform2(outOff, off, step);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform4(outOff, off, step);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = (size / step) << 1;\n      const quarterLen = len >>> 2;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        // Full case\n        const limit = outOff + quarterLen;\n        for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n          const A = i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n\n          // Middle values\n          const MAr = Ar;\n          const MAi = Ai;\n\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n\n          const FCr = T0r - T2r;\n          const FCi = T0i - T2i;\n\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n\n          const FDr = T1r - T3i;\n          const FDi = T1i + T3r;\n\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          out[D] = FDr;\n          out[D + 1] = FDi;\n        }\n      }\n    }\n  }\n\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  private _singleTransform2(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n\n    const evenR = data[off];\n    const evenI = data[off + 1];\n    const oddR = data[off + step];\n    const oddI = data[off + step + 1];\n\n    const leftR = evenR + oddR;\n    const leftI = evenI + oddI;\n    const rightR = evenR - oddR;\n    const rightI = evenI - oddI;\n\n    out[outOff] = leftR;\n    out[outOff + 1] = leftI;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = rightI;\n  }\n\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  private _singleTransform4(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Ai = data[off + 1];\n    const Br = data[off + step];\n    const Bi = data[off + step + 1];\n    const Cr = data[off + step2];\n    const Ci = data[off + step2 + 1];\n    const Dr = data[off + step3];\n    const Di = data[off + step3 + 1];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T0i = Ai + Ci;\n    const T1r = Ar - Cr;\n    const T1i = Ai - Ci;\n    const T2r = Br + Dr;\n    const T2i = Bi + Di;\n    const T3r = inv * (Br - Dr);\n    const T3i = inv * (Bi - Di);\n\n    // Final values\n    const FAr = T0r + T2r;\n    const FAi = T0i + T2i;\n\n    const FBr = T1r + T3i;\n    const FBi = T1i - T3r;\n\n    const FCr = T0r - T2r;\n    const FCi = T0i - T2i;\n\n    const FDr = T1r - T3i;\n    const FDi = T1i + T3r;\n\n    out[outOff] = FAr;\n    out[outOff + 1] = FAi;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = FCi;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n\n  // Real input radix-4 implementation\n  private _realTransform4(): void {\n    const out = this._out!;\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = (size / step) << 1;\n\n    let outOff: number;\n    let t: number;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = (size / step) << 1;\n      const halfLen = len >>> 1;\n      const quarterLen = halfLen >>> 1;\n      const hquarterLen = quarterLen >>> 1;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n          const A = outOff + i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n\n          // Middle values\n          const MAr = Ar;\n          const MAi = Ai;\n\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n\n          // Output final middle point\n          if (i === 0) {\n            const FCr = T0r - T2r;\n            const FCi = T0i - T2i;\n            out[C] = FCr;\n            out[C + 1] = FCi;\n            continue;\n          }\n\n          // Do not overwrite ourselves\n          if (i === hquarterLen)\n            continue;\n\n          // In the flipped case:\n          // MAi = -MAi\n          // MBr=-MBi, MBi=-MBr\n          // MCr=-MCr\n          // MDr=MDi, MDi=MDr\n          const ST0r = T1r;\n          const ST0i = -T1i;\n          const ST1r = T0r;\n          const ST1i = -T0i;\n          const ST2r = -inv * T3i;\n          const ST2i = -inv * T3r;\n          const ST3r = -inv * T2i;\n          const ST3i = -inv * T2r;\n\n          const SFAr = ST0r + ST2r;\n          const SFAi = ST0i + ST2i;\n\n          const SFBr = ST1r + ST3i;\n          const SFBi = ST1i - ST3r;\n\n          const SA = outOff + quarterLen - i;\n          const SB = outOff + halfLen - i;\n\n          out[SA] = SFAr;\n          out[SA + 1] = SFAi;\n          out[SB] = SFBr;\n          out[SB + 1] = SFBi;\n        }\n      }\n    }\n  }\n\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  private _singleRealTransform2(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n\n    const evenR = data[off];\n    const oddR = data[off + step];\n\n    const leftR = evenR + oddR;\n    const rightR = evenR - oddR;\n\n    out[outOff] = leftR;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = 0;\n  }\n\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  private _singleRealTransform4(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Br = data[off + step];\n    const Cr = data[off + step2];\n    const Dr = data[off + step3];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T1r = Ar - Cr;\n    const T2r = Br + Dr;\n    const T3r = inv * (Br - Dr);\n\n    // Final values\n    const FAr = T0r + T2r;\n\n    const FBr = T1r;\n    const FBi = -T3r;\n\n    const FCr = T0r - T2r;\n\n    const FDr = T1r;\n    const FDi = T3r;\n\n    out[outOff] = FAr;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = 0;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n}\n","import { average, closest, logspace, linspace } from './math';\n\nconsole.debug(\"Fractional Octave Smoothing module loaded\");\n\nexport function getFractionalOctaveFrequencies(fraction: number, f_low: number = 20, f_high: number = 24000, fftSize: number): Float32Array {\n    if (fraction <= 0) {\n        throw new Error(\"Fraction must be greater than 0\");\n    }\n    if (f_low <= 0 || f_high <= 0) {\n        throw new Error(\"Frequencies must be greater than 0\");\n    }\n    if (f_low >= f_high) {\n        throw new Error(\"f_low must be less than f_high\");\n    }\n    const num_points = Math.round((Math.log10(f_high) - Math.log10(f_low)) / fraction) + 1;\n\n    let frequencies = logspace(f_low, f_high, num_points);\n\n    const frequency_resolution = 48000 / fftSize; // Assuming a sample rate of 48000 Hz\n\n    for (let i = 0; i < frequencies.length; i++) {\n        frequencies[i] = Math.round(frequencies[i] / frequency_resolution) * frequency_resolution;\n    }\n    frequencies = Float32Array.from(new Set(frequencies)); // Remove duplicates\n\n    return frequencies;\n}\n\nexport function fractionalOctaveSmoothing(frequencyData: Float32Array, fraction: number, frequencies: Float32Array): Float32Array {\n    const frequenciesAll = linspace(0, 48000 / 2, frequencyData.length);\n    const smoothedData = new Float32Array(frequencies.length);\n    const n = frequencyData.length;\n    const factor = Math.pow(2, (0.5 * fraction)) - Math.pow(0.5, (0.5 * fraction));\n    for (let p = 0; p < frequencies.length; p++) {\n        const i = closest(frequencies[p], frequenciesAll);\n        // If the distance between this and previous frequency is less than frequency_resolution, pass direct value\n\n        let sum = 0;\n        const width = Math.round(0.5 * factor * (n * 0.5 - Math.abs(n * 0.5 - i)));\n        if (width === 0) {\n            sum = frequencyData[i];\n        } else {\n            const as = frequencyData.slice(Math.round(i - width + 1), Math.min(Math.round(i + width), n - 1));\n            sum = average(as);\n        }\n        smoothedData[p] = sum;\n    }\n    return smoothedData;\n}","import { abs, average, closest, linspace, mod, nextPow2 } from './math';\nimport { FFT } from './fft';\nimport { fractionalOctaveSmoothing, getFractionalOctaveFrequencies } from './fractional_octave_smoothing';;\n\nconsole.debug(\"Audio module loaded\");\n\n(window as any).FFT = FFT; // Make FFT globally available\n\nexport function sum(buffer: Float32Array): number {\n    let sum = 0;\n    for (let i = 0; i < buffer.length; i++) {\n        sum += buffer[i] * buffer[i];\n    }\n    return sum\n}\n\nexport function rms(buffer: Float32Array): number {\n    // Assuming mono channel for simplicity; extend as needed for multi-channel\n    return Math.sqrt(sum(buffer) / buffer.length);\n}\n\nexport function normalize(input: Float32Array, peak: boolean = false): Float32Array {\n    const rms_value = rms(input);\n    if (rms_value === 0) return input; // avoid division by zero, return original (silence)\n\n    const factor = (1 / rms_value) * (peak ? 1 : Math.SQRT2);\n\n    return input.map(v => v * factor);\n}\n\nexport function db(value: Float32Array): Float32Array;\nexport function db(value: number): number;\nexport function db(value: Float32Array | number): Float32Array | number {\n    if (value instanceof Float32Array) {\n        return value.map(v => 20 * Math.log10(v + 1e-50));\n    } else {\n        return 20 * Math.log10(value + 1e-50);\n    }\n}\n\nexport function exponentialMovingAverage(old: number, value: number, alpha: number): number {\n    return alpha * value + (1 - alpha) * old;\n}\n\nexport const smoothingFactor = (timeConstant: number, sampleRate: number): number => {\n    return 1 - Math.exp(-1 / (sampleRate * timeConstant));\n}\n\nexport function dbToLinear(value: Float32Array): Float32Array;\nexport function dbToLinear(value: number): number;\nexport function dbToLinear(value: Float32Array | number): Float32Array | number {\n    if (value instanceof Float32Array) {\n        return value.map(v => Math.pow(10, v / 20));\n    } else {\n        return Math.pow(10, value / 20);\n    }\n}\n\nexport function getExponentialSmoothingFactor(timeConstant: number, sampleRate: number): number {\n    return 1 - Math.exp(-1 / (timeConstant * sampleRate));\n}\n\nexport interface FFTResult {\n    frequency: Float32Array;\n    magnitude: Float32Array;\n    phase: Float32Array;\n    fftSize: number;\n    peakAt?: number;\n    sampleRate?: number;\n}\n\nasync function loadAudioFile(file: File): Promise<Audio> {\n    const headerBuffer = await file.slice(0, 256 * 1024).arrayBuffer();\n\n    function getExt(name: string) {\n        return (name.split('.').pop() || '').toLowerCase();\n    }\n\n    function parseWav(buf: ArrayBuffer) {\n        const dv = new DataView(buf);\n        function readStr(off: number, len: number) {\n            let s = '';\n            for (let i = 0; i < len; i++) s += String.fromCharCode(dv.getUint8(off + i));\n            return s;\n        }\n\n        if (readStr(0, 4) !== 'RIFF' || readStr(8, 4) !== 'WAVE') return null;\n\n        let offset = 12;\n        const info: any = {};\n        while (offset + 8 <= dv.byteLength) {\n            const id = readStr(offset, 4);\n            const size = dv.getUint32(offset + 4, true);\n            if (id === 'fmt ') {\n                info.audioFormat = dv.getUint16(offset + 8, true);\n                info.numChannels = dv.getUint16(offset + 10, true);\n                info.sampleRate = dv.getUint32(offset + 12, true);\n                info.byteRate = dv.getUint32(offset + 16, true);\n                info.blockAlign = dv.getUint16(offset + 20, true);\n                info.bitsPerSample = dv.getUint16(offset + 22, true);\n            } else if (id === 'data') {\n                info.dataChunkSize = size;\n            }\n            offset += 8 + size + (size % 2);\n        }\n        if (info.sampleRate && info.byteRate && info.dataChunkSize) {\n            info.duration = info.dataChunkSize / info.byteRate;\n        }\n        return info;\n    }\n\n    function parseMp3(buf: ArrayBuffer) {\n        const bytes = new Uint8Array(buf);\n        let offset = 0;\n        // Skip ID3v2 tag if present\n        if (bytes[0] === 0x49 && bytes[1] === 0x44 && bytes[2] === 0x33) {\n            const size = ((bytes[6] & 0x7f) << 21) | ((bytes[7] & 0x7f) << 14) | ((bytes[8] & 0x7f) << 7) | (bytes[9] & 0x7f);\n            offset = 10 + size;\n        }\n        // find first frame header\n        let headerIndex = -1;\n        for (let i = offset; i < bytes.length - 4; i++) {\n            if (bytes[i] === 0xFF && (bytes[i + 1] & 0xE0) === 0xE0) {\n                headerIndex = i;\n                break;\n            }\n        }\n        if (headerIndex < 0) return null;\n        const b1 = bytes[headerIndex + 1];\n        const b2 = bytes[headerIndex + 2];\n        const b3 = bytes[headerIndex + 3];\n\n        const versionBits = (b1 >> 3) & 0x03;\n        const layerBits = (b1 >> 1) & 0x03;\n        const bitrateBits = (b2 >> 4) & 0x0f;\n        const sampleRateBits = (b2 >> 2) & 0x03;\n        const channelMode = (b3 >> 6) & 0x03;\n\n        const versions: any = {\n            0: 'MPEG Version 2.5',\n            1: 'reserved',\n            2: 'MPEG Version 2 (ISO/IEC 13818-3)',\n            3: 'MPEG Version 1 (ISO/IEC 11172-3)'\n        };\n        const layers: any = {\n            0: 'reserved',\n            1: 'Layer III',\n            2: 'Layer II',\n            3: 'Layer I'\n        };\n\n        const sampleRates: any = {\n            3: [44100, 48000, 32000],\n            2: [22050, 24000, 16000],\n            0: [11025, 12000, 8000]\n        };\n        const versionKey = versionBits;\n        const layerKey = layerBits;\n\n        // bitrate tables (kbps)\n        const bitrateTable: any = {\n            // MPEG1 Layer III\n            '3_1': [0,32,40,48,56,64,80,96,112,128,160,192,224,256,320,0],\n            // MPEG2/2.5 Layer III\n            '0_1': [0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0],\n            '2_1': [0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0],\n            // fallback generic table for other layers/versions (best-effort)\n            '3_2': [0,32,48,56,64,80,96,112,128,160,192,224,256,320,384,0],\n            '3_3': [0,32,64,96,128,160,192,224,256,320,384,448,512,576,640,0]\n        };\n\n        const versionStr = versions[versionKey] || 'unknown';\n        const layerStr = layers[layerKey] || 'unknown';\n        let sampleRate = sampleRates[versionKey]?.[sampleRateBits] || null;\n\n        let bitrateKbps = 0;\n        const tbKey = `${versionKey}_${layerKey}`;\n        if (bitrateTable[tbKey]) {\n            bitrateKbps = bitrateTable[tbKey][bitrateBits] || 0;\n        } else if (bitrateTable['3_1'] && versionKey === 3 && layerKey === 1) {\n            bitrateKbps = bitrateTable['3_1'][bitrateBits] || 0;\n        }\n\n        const channels = channelMode === 3 ? 1 : 2;\n        let duration = null;\n        if (bitrateKbps > 0) {\n            duration = (bytes.length * 8) / (bitrateKbps * 1000);\n        }\n\n        return {\n            version: versionStr,\n            layer: layerStr,\n            bitrateKbps: bitrateKbps || null,\n            sampleRate,\n            channels,\n            duration\n        };\n    }\n\n    const ext = getExt(file.name);\n    const mime = file.type || 'unknown';\n    let metadata: {[Key: string]: string | number | null} = {};\n\n    const wavInfo = parseWav(headerBuffer);\n    if (wavInfo) {\n        metadata.format = 'wav';\n        metadata = Object.assign(metadata, wavInfo || {});\n    } else if (mime === 'audio/mpeg' || ext === 'mp3') {\n        const mp3Info = parseMp3(headerBuffer);\n        metadata.format = 'mp3';\n        metadata = Object.assign(metadata, mp3Info || {});\n    } else {\n        // best-effort: report file.type and extension and later rely on AudioContext decode\n        metadata.format = mime || ext || 'unknown';\n    }\n\n    console.log('Extracted file metadata:', metadata);\n    const arrayBuffer = await file.arrayBuffer();\n    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n    const audioBuffer: AudioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n\n    return Audio.fromAudioBuffer(audioBuffer, metadata);\n}\n\nexport class Audio extends AudioBuffer {\n    metadata?: {[Key: string]: string | number | null};\n\n    static fromAudioBuffer(buffer: AudioBuffer, metadata?: {[Key: string]: string | number | null}): Audio {\n        const audio = new Audio({\n            length: buffer.length,\n            numberOfChannels: buffer.numberOfChannels,\n            sampleRate: buffer.sampleRate\n        });\n        for (let ch = 0; ch < buffer.numberOfChannels; ch++) {\n            audio.copyToChannel(buffer.getChannelData(ch), ch);\n        }\n        audio.metadata = metadata;\n        return audio;\n    }\n\n    static fromSamples(samples: Float32Array, sampleRate: number = 48000, metadata?: {[Key: string]: string | number | null}): Audio {\n        if (!samples || samples.length == 0) return new Audio({ length: 0, numberOfChannels: 1, sampleRate: sampleRate });\n        const audio = new Audio({\n            length: samples.length,\n            numberOfChannels: 1,\n            sampleRate: sampleRate\n        });\n        audio.copyToChannel(samples, 0);\n        audio.metadata = metadata;\n        return audio;\n    }\n\n    applyGain(gain: number): Audio {\n        const numChannels = this.numberOfChannels;\n        for (let ch = 0; ch < numChannels; ch++) {\n            const data = this.getChannelData(ch).map(v => v * gain);\n            this.copyToChannel(data, ch, 0);\n        }\n        return this;\n    }\n\n    getChannel(channel: number): Audio {\n        if (channel < 0 || channel >= this.numberOfChannels) {\n            throw new Error(\"Invalid channel number\");\n        }\n        const channelData = this.getChannelData(channel);\n        const newBuffer = new AudioBuffer({\n            length: channelData.length,\n            numberOfChannels: 1,\n            sampleRate: this.sampleRate\n        });\n        // copy channel samples into the mono buffer\n        newBuffer.copyToChannel(channelData, 0, 0);\n        return new Audio(newBuffer);\n    }\n\n    rms(channel: number = 0): number {\n        if (channel < 0 || channel >= this.numberOfChannels) {\n            throw new Error(\"Invalid channel number\");\n        }\n        const data = this.getChannelData(channel);\n        return rms(data);\n    }\n}\n\nexport function chirp(f_start: number, f_stop: number, duration: number | null = null, rate: number | null = null, fade: number = 0.01, fs: number = 48000): [Float32Array, Float32Array, Float32Array] {\n    const c = Math.log(f_stop / f_start);\n\n    let L: number;\n    let samples_count: number;\n\n    if (duration == null && rate == null) {\n        // Default to one decade per second if nothing provided\n        rate = 1.0;\n    }\n\n    if (duration == null) {\n        // rate is seconds per decade -> L = rate / ln(10)\n        L = (rate as number) / Math.log(10);\n        samples_count = Math.round(L * c * fs);\n        duration = samples_count / fs;\n    } else {\n        L = duration / c;\n        rate = Math.log(10) * L;\n        samples_count = Math.round(L * c * fs);\n    }\n\n    samples_count = Math.max(1, samples_count);\n\n    const fade_in = Math.max(0, Math.floor(fade * fs));\n    const fade_out = Math.max(0, Math.floor((fade / 10) * fs));\n\n    // instantaneous phase\n    // phi = (L * f_start) * (exp(t/L) - 1)\n    // compact phi: pre-fade (fade_in samples), main sweep, post-fade (fade_out samples)\n    const pre = Math.max(0, fade_in);\n    const post = Math.max(0, fade_out);\n    const phi = Float32Array.from({ length: pre + samples_count + post }, () => 0);\n\n    // offset matches original phi_fade_in last value: f_start * ((fade_in+1)/fs)\n    const offset = f_start * ((fade_in + 1) / fs);\n\n    // pre-fade linear ramp\n    for (let i = 0; i < pre; i++) phi[i] = f_start * (i / fs);\n\n    // main sweep (adds offset)\n    const baseIdx = pre;\n    for (let i = 0; i < samples_count; i++) {\n        let t = i / fs;\n        phi[baseIdx + i] = L * f_start * (Math.exp(t / L) - 1) + offset;\n    }\n\n    // post-fade linear ramp starting from last sweep value\n    const last = phi[baseIdx + samples_count - 1] || 0;\n    for (let i = 0; i < post; i++) {\n        phi[baseIdx + samples_count + i] = last + f_stop * ((i + 1) / fs);\n    }\n\n    // sweep = sin(2 * PI * phi)\n    const sweep = Float32Array.from({ length: phi.length }, () => 0);\n    for (let i = 0; i < phi.length; i++) sweep[i] = Math.sin(2 * Math.PI * phi[i]);\n\n    // compute time vector t for sweep length\n    const t = Float32Array.from({ length: sweep.length }, () => 0);\n    for (let i = 0; i < sweep.length; i++) t[i] = i / fs;\n\n    // envelope main: (exp(-t/L) / L) * f_stop * duration^2\n    const envMain = Float32Array.from({ length: t.length }, () => 0);\n    const factor = f_stop * (duration as number) * (duration as number);\n    for (let i = 0; i < t.length; i++) envMain[i] = (Math.exp(-t[i] / L) / L) * factor;\n\n    // prepend and append small zero pads (approx. 10ms and 1ms at given fs)\n    const startZeros = Math.floor(0.01 * fs); // ~480 samples at 48k\n    const endZeros = Math.floor(0.001 * fs);  // ~48 samples at 48k\n    const envelope = Float32Array.from({ length: startZeros + envMain.length + endZeros }, () => 0);\n    // copy envMain into middle\n    for (let i = 0; i < envMain.length; i++) {\n        envelope[startZeros + i] = envMain[i];\n    }\n\n    // window: simple linear fade in/out over fade_in / fade_out samples\n    const window = Float32Array.from({ length: sweep.length }, () => 0);\n    for (let i = 0; i < sweep.length; i++) {\n        let w = 1.0;\n        if (fade_in > 0 && i < fade_in) {\n            w = i / Math.max(1, fade_in);\n        }\n        if (fade_out > 0 && i >= sweep.length - fade_out) {\n            const k = i - (sweep.length - fade_out);\n            w *= 1 - (k / Math.max(1, fade_out));\n        }\n        window[i] = w;\n    }\n\n    // apply window to sweep\n    const sweepWindowed = Float32Array.from({ length: sweep.length }, () => 0);\n    for (let i = 0; i < sweep.length; i++) sweepWindowed[i] = sweep[i] * window[i];\n\n    return [sweepWindowed, t, envelope];\n}\n\nexport function smoothFFT(fftData: FFTResult, fraction: number, resolution: number): FFTResult {\n    const { frequency, magnitude, phase, fftSize } = fftData;\n    const smoothedMagnitude = Float32Array.from({ length: magnitude.length }, () => 0);\n\n    // Get fractional octave frequencies\n    const fractionalFrequencies = getFractionalOctaveFrequencies(resolution, 20, 24000, fftSize);\n\n    // Apply fractional octave smoothing\n    const smoothed = dbToLinear(fractionalOctaveSmoothing(db(magnitude), fraction, fractionalFrequencies));\n    const smoothedPhase = fractionalOctaveSmoothing(phase, fraction, fractionalFrequencies);\n\n    return {\n        frequency: fractionalFrequencies,\n        magnitude: smoothed,\n        phase: smoothedPhase,\n        fftSize\n    };\n}\n\nexport function computeFFT(data: Float32Array | Float32Array, fftSize: number | null = null): FFTResult {\n    fftSize ??= 2 ** Math.ceil(Math.log2(data.length));\n    console.log(`Computing FFT with ${fftSize} bins for data length ${data.length}`);\n    const fft = new FFT(fftSize);\n    const out = fft.createComplexArray();\n\n    // Fix data length by zero-padding or truncating.\n    const frame = Float32Array.from({ length: fftSize }, () => 0);\n    for (let i = 0; i < fftSize; i++) {\n        frame[i] = (data[i] || 0) * 1;\n    }\n    fft.realTransform(out, frame);\n    \n    const frequency = Float32Array.from({ length: fftSize / 2 }, () => 0);\n    const magnitude = Float32Array.from({ length: fftSize / 2 }, () => 0);\n    const phase = Float32Array.from({ length: fftSize / 2 }, () => 0);\n\n    for (let i = 0; i < fftSize / 2; i++) {\n            const re = out[2 * i];\n            const im = out[2 * i + 1];\n            magnitude[i] = abs(re, im) * Math.SQRT2; // Scale by sqrt(2) for single-sided spectrum.\n            phase[i] = Math.atan2(im, re); // phase in radians, range [-PI, PI].\n    }\n    const frequencyResolution = 48000 / fftSize; // Assuming sample rate of 48000 Hz\n    for (let i = 0; i < fftSize / 2; i++) {\n        frequency[i] = i * frequencyResolution;\n    }\n\n    return {\n        frequency,\n        magnitude,\n        phase,\n        fftSize,\n    };\n}\n\nexport interface CorrelationResult {\n    corr: Float64Array;\n    lags: Int32Array;\n    estimatedLagSamples: number;\n    estimatedLagIndex: number;\n    peakCorrelation: number;\n    raw: Float64Array;\n    nfft: number;\n}\n\nexport function fftCorrelation(x: Float32Array | Float32Array, y: Float32Array | Float32Array): CorrelationResult {\n    // cross-correlate x with y using FFT (fft.js). Returns normalized cross-correlation,\n    // lags (samples), estimated lag (samples) and peak correlation value.\n    const lenX = x.length;\n    const lenY = y.length;\n    const fullLen = lenX + lenY - 1;\n\n    // next pow2 >= fullLen\n    const nextPow2 = (v: number): number => {\n        let p = 1;\n        while (p < v) p <<= 1;\n        return p;\n    };\n    const n = nextPow2(fullLen);\n\n    // zero-pad inputs to length n\n    const xP = Float32Array.from({ length: n }, () => 0);\n    const yP = Float32Array.from({ length: n }, () => 0);\n    xP.set(x, 0);\n    yP.set(y, 0);\n\n    const fft = new FFT(n);\n    const A = fft.createComplexArray();\n    const B = fft.createComplexArray();\n\n    // forward real FFTs\n    fft.realTransform(A, xP);\n    fft.realTransform(B, yP);\n    // complete the spectrum to full complex arrays (negative freqs)\n    if (typeof fft.completeSpectrum === 'function') {\n        fft.completeSpectrum(A);\n        fft.completeSpectrum(B);\n    }\n\n    // multiply A * conj(B) -> cross-spectrum\n    const C = fft.createComplexArray();\n    for (let k = 0; k < n; k++) {\n        const ar = A[2 * k], ai = A[2 * k + 1];\n        const br = B[2 * k], bi = B[2 * k + 1];\n        // A * conj(B) = (ar + i ai)*(br - i bi)\n        C[2 * k] = ar * br + ai * bi;\n        C[2 * k + 1] = ai * br - ar * bi;\n    }\n\n    // inverse FFT of cross-spectrum\n    const out = fft.createComplexArray();\n    fft.inverseTransform(out, C);\n\n    // real part / n gives linear cross-correlation (no circular wrap because padded)\n    const corr = Float64Array.from({ length: fullLen }, () => 0);\n    for (let i = 0; i < fullLen; i++) {\n        corr[i] = out[2 * i] / n;\n    }\n\n    // compute normalization factor (energy)\n    let sumX2 = 0, sumY2 = 0;\n    for (let i = 0; i < lenX; i++) sumX2 += x[i] * x[i];\n    for (let i = 0; i < lenY; i++) sumY2 += y[i] * y[i];\n    const denom = Math.sqrt(sumX2 * sumY2);\n\n    const normalized = Float64Array.from({ length: fullLen }, () => 0);\n    if (denom > 0) {\n        for (let i = 0; i < fullLen; i++) normalized[i] = corr[i] / denom;\n    } else {\n        // silence case -> zeros\n        for (let i = 0; i < fullLen; i++) normalized[i] = 0;\n    }\n\n    // lags: index i corresponds to lag = i - (lenY - 1)\n    const lags = new Int32Array(fullLen);\n    for (let i = 0; i < fullLen; i++) lags[i] = i - (lenY - 1);\n\n    // find peak\n    let peakIdx = 0;\n    let peakVal = -Infinity;\n    for (let i = 0; i < fullLen; i++) {\n        if (normalized[i] > peakVal) {\n            peakVal = normalized[i];\n            peakIdx = i;\n        }\n    }\n    const estimatedLag = lags[peakIdx];\n\n    return {\n        corr: normalized,\n        lags,\n        estimatedLagSamples: estimatedLag,\n        estimatedLagIndex: peakIdx,\n        peakCorrelation: peakVal,\n        raw: corr,\n        nfft: n\n    };\n}\n\n\nexport function fftConvolve(x: Float32Array | Float32Array, y: Float32Array | Float32Array, mode: 'same' | 'full' = 'same'): Float32Array {\n    const lenX = x.length;\n    const lenY = y.length;\n    const fullLen = lenX + lenY - 1;\n\n    // next pow2 >= fullLen\n    const n = nextPow2(fullLen);\n\n    // zero-pad inputs to length n\n    const xP = Float32Array.from({ length: n }, () => 0);\n    const yP = Float32Array.from({ length: n }, () => 0);\n    xP.set(x, 0);\n    yP.set(y, 0);\n\n    const fft = new FFT(n);\n    const A = fft.createComplexArray();\n    const B = fft.createComplexArray();\n\n    // forward real FFTs\n    fft.realTransform(A, xP);\n    fft.realTransform(B, yP);\n        // complete the spectrum to full complex arrays (negative freqs)\n    if (typeof fft.completeSpectrum === 'function') {\n        fft.completeSpectrum(A);\n        fft.completeSpectrum(B);\n    }\n\n    // multiply A * B -> convolution spectrum\n    const C = fft.createComplexArray();\n    for (let k = 0; k < n; k++) {\n        const ar = A[2 * k], ai = A[2 * k + 1];\n        const br = B[2 * k], bi = B[2 * k + 1];\n        C[2 * k] = ar * br - ai * bi;\n        C[2 * k + 1] = ai * br + ar * bi;\n    }\n\n    // inverse FFT\n    const out = fft.createComplexArray();\n    fft.inverseTransform(out, C);\n\n    // extract real part and normalize by n\n    const result = Float32Array.from({ length: fullLen }, () => 0);\n    for (let i = 0; i < fullLen; i++) {\n        result[i] = out[2 * i];\n    }\n\n    // return 'same' mode (centered, matching first input length)\n    if (mode === 'same') {\n        const start = Math.floor((fullLen - lenX) / 2);\n        return result.slice(start, start + lenX);\n    }\n\n    return result;\n}\n\nexport interface ImpulseResponseResult {\n    ir: Float32Array;\n    ir_complex: Float32Array;\n    t: Float32Array;\n    peakAt: number;\n    sampleRate: number;\n    fftSize: number;\n}\n\n\nexport function twoChannelImpulseResponse(y: Float32Array, x: Float32Array): ImpulseResponseResult {\n    // Calculate the impulse response by taking the IFFT of the division of the FFTs of output and input signals.\n    const fullLen = y.length + x.length - 1;\n    \n    const N = nextPow2(fullLen);\n\n    // zero-pad inputs to length n\n    const xP = Float32Array.from({ length: N }, () => 0);\n    const yP = Float32Array.from({ length: N }, () => 0);\n    xP.set(y, 0);\n    yP.set(x, 0);\n\n    const fft = new FFT(N);\n    const A = fft.createComplexArray();\n    const B = fft.createComplexArray();\n\n    // forward real FFTs\n    fft.realTransform(A, xP);\n    fft.realTransform(B, yP);\n\n    // Division A / B with regularization to avoid division by zero\n    const C = fft.createComplexArray();\n    const epsilon = 1e-20;\n    for (let k = 0; k < N; k++) {\n        const ar = A[2 * k], ai = A[2 * k + 1];\n        const br = B[2 * k], bi = B[2 * k + 1];\n        const denom = br * br + bi * bi + epsilon;\n        C[2 * k] = (ar * br + ai * bi) / denom;\n        C[2 * k + 1] = (ai * br - ar * bi) / denom;\n    }\n\n    // inverse FFT of cross-spectrum\n    const out = Float32Array.from(fft.createComplexArray());\n    fft.inverseTransform(out, C);\n\n    // Real part / N gives impulse response. This is shifted by N/2.\n    const ir = Float32Array.from({ length: N }, () => 0);\n    for (let i = 0; i < N; i++) {\n        ir[i] = out[2 * (( i + N/2) % N)]; // normalize by input length\n    }\n\n    const peakAt = closest(100000000, ir) + (-N) / 2;\n    const ir_complex = out.slice(); // copy\n    for (let i = 0; i < N; i++) {\n        ir_complex[2 * i] = out[2 * mod(i + peakAt, N)];\n        ir_complex[2 * i + 1] = out[2 * mod(i + peakAt, N) + 1];\n    }\n\n    // Remove DC offset.\n    const mean = average(ir)\n    for (let i = 0; i < N; i++) {\n        ir[i] = ir[i] - mean;\n    }\n\n    return {\n        ir,\n        ir_complex,\n        t: linspace((-N - 1) / 2 / 48000, (N - 1) / 2 / 48000, N), // assuming 48kHz\n        peakAt,\n        sampleRate: 48000,\n        fftSize: N,\n    };\n}\n\nexport function twoChannelFFT(dataArray: Float32Array | Float32Array, reference: Float32Array | Float32Array, fftSize: number, offset: number): FFTResult {\n    const dataPadded = Float32Array.from({ length: fftSize }, () => 0);\n    const referencePadded = Float32Array.from({ length: fftSize }, () => 0);\n\n    if (offset >= 0) {\n        // copy reference into referencePadded starting at 'offset'\n        const refLen = Math.min(reference.length, Math.max(0, fftSize - offset));\n        for (let i = 0; i < refLen; i++) {\n            referencePadded[offset + i] = reference[i];\n        }\n        // copy dataArray into dataPadded starting at 0\n        const dataLen = Math.min((dataArray as Float32Array).length, fftSize);\n        for (let i = 0; i < dataLen; i++) {\n            dataPadded[i] = (dataArray as Float32Array)[i];\n        }\n    } else {\n        // offset < 0: copy reference starting at 0\n        const refLen = Math.min(reference.length, fftSize);\n        for (let i = 0; i < refLen; i++) {\n            referencePadded[i] = reference[i];\n        }\n        // place dataArray into dataPadded starting at -offset\n        const start = -offset;\n        const dataLen = Math.min((dataArray as Float32Array).length, Math.max(0, fftSize - start));\n        for (let i = 0; i < dataLen; i++) {\n            dataPadded[start + i] = (dataArray as Float32Array)[i];\n        }\n    }\n\n    //const rmss = rms(referencePadded);\n    const reference_ = computeFFT(referencePadded);  // Avoid log(0)\n    const signal_ = computeFFT(dataPadded);\n    const signalMags = signal_.magnitude.map(v => 20 * Math.log10(v === 0 ? 1e-20 : v));\n    const referenceMags = reference_.magnitude.map(v => 20 * Math.log10(v === 0 ? 1e-20 : v));\n    const h = referenceMags.map((v, i) => signalMags[i] - v); // dB difference\n    const frequency = linspace(0, 48000 / 2, h.length);\n\n    // For phase, align the reference and signal using a fixed offset (26718 samples for 1m @ 340m/s and 48kHz)\n    // This is a hack to get a reasonable phase response for the measurement setup\n    // In a real application, use cross-correlation to find the delay between signals\n\n    const i_50 = closest(50, frequency); // Example usage of closest function\n    const phase_signal = signal_.phase;\n    const phase_reference = reference_.phase;\n    // phase difference (unwrap phases first)\n    const sphase = unwrapPhase(phase_signal.map((v, i) => v - phase_reference[i])); // phase difference in radians\n    const correction = (Math.floor(sphase[i_50] / (2 * Math.PI) + 0.5)) * (2 * Math.PI);\n    const phase = sphase.map(v => (v - correction)); // relative to 50 Hz\n\n    // simple phase unwrapping (returns Float32Array)\n    function unwrapPhase(phases: Float32Array): Float32Array {\n        const N = phases.length;\n        const out = Float32Array.from({ length: N }, () => 0);\n        if (N === 0) return out;\n        out[0] = phases[0];\n        let offset = 0;\n        const theta = Math.PI; // unwrapping threshold\n        for (let i = 1; i < N; i++) {\n            let delta = phases[i] - phases[i - 1];\n            if (delta > theta) {\n                offset -= 2 * Math.PI;\n            } else if (delta < -theta) {\n                offset += 2 * Math.PI;\n            }\n            out[i] = phases[i] + offset;\n        }\n        return out;\n    }\n\n    return {\n        frequency,\n        magnitude: h,\n        phase,\n        fftSize\n    };\n}\n\nexport function computeFFTFromIR(ir: ImpulseResponseResult, f_phase_wrap: number = 1000, frequency_multiplier: number = 1): FFTResult {\n    const fftSize = nextPow2(ir.ir.length);\n    console.log(`Computing FFT from IR with size ${fftSize}`);\n    \n    const fft = new FFT(fftSize);\n    const out = Float32Array.from(fft.createComplexArray());\n    if (ir.ir_complex[1] === 0) {\n        console.log(\"IR is in real format, converting to complex\");\n        // real IR, convert to complex\n        const frame = Float32Array.from({ length: fftSize }, () => 0);\n        for (let i = 0; i < fftSize; i++) {\n            frame[i] = (ir.ir_complex[2 * i] || 0);\n        }\n        fft.realTransform(out, frame);\n    } else {\n        fft.transform(out, ir.ir_complex);\n    }\n\n    const magnitude = Float32Array.from({ length: fftSize / 2 }, () => 0);\n    const phase = Float32Array.from({ length: fftSize / 2 }, () => 0);\n    \n    for (let i = 0; i < fftSize / 2; i++) {\n        const re = out[2 * i];\n        const im = out[2 * i + 1];\n        magnitude[i] = abs(re, im);\n        phase[i] = Math.atan2(im, re); // phase in radians, range [-PI, PI].\n    }\n    const frequency = linspace(0, 48000 / 2, magnitude.length);\n\n    const i_norm = closest(f_phase_wrap, frequency); // Example usage of closest function\n    // phase difference (unwrap phases first)\n    const unwraped_phase = unwrapPhase(phase); // phase difference in radians\n    const correction = (Math.floor(unwraped_phase[i_norm] / (2 * Math.PI) + 0.5)) * (2 * Math.PI);\n    const corrected_unwraped_phase = unwraped_phase.map(v => (v - correction)); // relative to 50 Hz\n\n    // simple phase unwrapping (returns Float32Array)\n    function unwrapPhase(phases: Float32Array): Float32Array {\n        const N = phases.length;\n        const out = Float32Array.from({ length: N }, () => 0);\n        if (N === 0) return out;\n        out[0] = phases[0];\n        let offset = 0;\n        for (let i = 1; i < N; i++) {\n            let delta = phases[i] - phases[i - 1];\n            if (delta > Math.PI) {\n                offset -= 2 * Math.PI;\n            } else if (delta < -Math.PI) {\n                offset += 2 * Math.PI;\n            }\n            out[i] = phases[i] + offset;\n        }\n        return out;\n    }\n\n    return {\n        frequency,\n        magnitude,\n        phase: corrected_unwraped_phase.map(v => v / Math.PI * 180),\n        peakAt: ir.peakAt,\n        sampleRate: ir.sampleRate,\n        fftSize: fftSize,\n    };\n}\n\nexport function groupDelays(fftData: FFTResult, normalizeAt: number = 1000): Float32Array {\n    const { frequency, phase, peakAt } = fftData;\n    const N = frequency.length;\n    const groupDelay = Float32Array.from({ length: N }, () => 0);\n\n    // Numerical differentiation of unwrapped phase\n    for (let i = 1; i < N - 1; i++) {\n        const dPhase = (phase[i] - phase[i - 1]);\n        const dFreq = (frequency[i] - frequency[i - 1]);\n        groupDelay[i] = -dPhase / dFreq / 360; // in seconds\n    }\n    // Edge cases\n    groupDelay[0] = groupDelay[1];\n    groupDelay[N - 1] = groupDelay[N - 2];\n\n    // Normalize group delay at specified frequency and add delay to make it zero there.\n    const normIdx = closest(normalizeAt, frequency);\n    const delayAtNorm = groupDelay[normIdx];\n    for (let i = 0; i < N; i++) {\n        groupDelay[i] = (groupDelay[i] - delayAtNorm); // assuming 48kHz sample rate, s => ms.\n    }\n\n    return groupDelay;\n}\n\nexport const A_WEIGHTING_COEFFICIENTS: [Float32Array, Float32Array] = [\n    Float32Array.from([0.234301792299513, -0.468603584599026, -0.234301792299513, 0.937207169198054, -0.234301792299515, -0.468603584599025, 0.234301792299513]),\n    Float32Array.from([1.000000000000000, -4.113043408775871, 6.553121752655047, -4.990849294163381, 1.785737302937573, -0.246190595319487, 0.011224250033231]),\n];\n// Coefficients for K-weighting filter (pre-emphasis and high-frequency shelving)\n// From ITU-R BS.1770-4, Table 1\n// https://www.itu.int/dms_pubrec/itu-r/rec/bs/r-rec-bs.1770-2-201103-s!!pdf-e.pdf\nexport const K_WEIGHTING_COEFFICIENTS_PRE: [Float32Array, Float32Array] = [\n    Float32Array.from([1.53512485958697, -2.69169618940638, 1.19839281085285]),\n    Float32Array.from([1, -1.69065929318241, 0.73248077421585])\n];\n\nexport const K_WEIGHTING_COEFFICIENTS_RLB: [Float32Array, Float32Array] = [\n    Float32Array.from([1.0, -2.0, 1.0]),\n    Float32Array.from([1, -1.99004745483398, 0.99007225036621])\n];\n\nexport function applyAWeightingToBuffer(buffer: Float32Array, zi: Float32Array): Float32Array {\n    const b = A_WEIGHTING_COEFFICIENTS[0];\n    const a = A_WEIGHTING_COEFFICIENTS[1];\n    const output = Float32Array.from({ length: buffer.length }, () => 0);\n    for (let n = 0; n < buffer.length; n++) {\n        output[n] = b[0] * buffer[n] + zi[0];\n        for (let i = 1; i < b.length; i++) {\n            zi[i - 1] = b[i] * buffer[n] + zi[i] - a[i] * output[n];\n        }\n    }\n    return output;\n}\n\nexport function gateBuffer(buffer: Float32Array, sampleRate: number, thresholdDb: number = -70, blockMs: number = 400, overlap: number = 0.75): Float32Array {\n    const blockSize = Math.floor((blockMs / 1000) * sampleRate);\n    const hopSize = Math.floor(blockSize * (1 - overlap));\n    const threshold = dbToLinear(thresholdDb);\n\n    const gated = Float32Array.from({ length: buffer.length }, () => 0);\n    let i = 0;\n\n    while (i < buffer.length) {\n        const start = i;\n        const end = Math.min(i + blockSize, buffer.length);\n        const block = buffer.slice(start, end);\n        const blockRms = rms(block);\n\n        if (blockRms >= threshold) {\n            // copy block into gated at position 'start'\n            for (let j = 0; j < block.length; j++) {\n                gated[start + j] = block[j];\n            }\n        }\n        // else: leave zeros (gate closed)\n\n        i += hopSize;\n    }\n\n    return gated;\n}\n\nexport const audio = {\n    loadAudioFile,\n    chirp,\n    computeFFT,\n    smoothFFT,\n    fftCorrelation,\n    fftConvolve,\n    twoChannelImpulseResponse,\n    computeFFTFromIR,\n    twoChannelFFT,\n    groupDelays,\n    applyAWeightingToBuffer,\n    gateBuffer,\n};\n\nexport default audio;","// windows.ts\r\n// Various window functions for signal processing.\r\n\r\nexport type WindowType = 'hanning' | 'hamming' | 'blackman' | 'rectangular' | 'gamma';\r\n\r\nfunction hanningWindow(length: number): Float32Array {\r\n    const window = new Float32Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n        window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (length - 1)));\r\n    }\r\n    return window;\r\n}\r\n\r\nfunction hammingWindow(length: number): Float32Array {\r\n    const window = new Float32Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n        window[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (length - 1));\r\n    }\r\n    return window;\r\n}\r\n\r\nfunction blackmanWindow(length: number): Float32Array {\r\n    const window = new Float32Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n        window[i] = (0.42 - 0.5 * Math.cos(2 * Math.PI * i / (length - 1)) + 0.08 * Math.cos(4 * Math.PI * i / (length - 1)));\r\n    }\r\n    return window;\r\n}\r\n\r\nfunction equirippleWindow(length: number, attenuation: number = 60): Float32Array {\r\n    // Dolph-Chebyshev window (approximate equiripple)\r\n    // attenuation: sidelobe attenuation in dB\r\n    // Reference: https://en.wikipedia.org/wiki/Chebyshev_window\r\n\r\n    if (length < 2) return new Float32Array([1]);\r\n\r\n    const M = length - 1;\r\n    const tg = Math.cosh(1 / M * Math.acosh(Math.pow(10, attenuation / 20)));\r\n    const window = new Float32Array(length);\r\n\r\n    // Precompute Chebyshev polynomial coefficients\r\n    for (let n = 0; n <= M; n++) {\r\n        let sum = 0;\r\n        for (let k = 0; k <= M; k++) {\r\n            const x = tg * Math.cos(Math.PI * k / M);\r\n            // Chebyshev polynomial of degree M\r\n            let Tm: number;\r\n            if (Math.abs(x) <= 1) {\r\n                Tm = Math.cos(M * Math.acos(x));\r\n            } else {\r\n                Tm = Math.cosh(M * Math.acosh(x));\r\n            }\r\n            const coeff = ((k === 0 || k === M) ? 0.5 : 1) * Tm * Math.cos(Math.PI * n * (k - M / 2) / M);\r\n            sum += coeff;\r\n        }\r\n        window[n] = sum;\r\n    }\r\n\r\n    return window;\r\n}\r\n\r\nfunction rectangularWindow(length: number): Float32Array {\r\n    const window = new Float32Array(length);\r\n    window.fill(1);\r\n    return window;\r\n}\r\n\r\nexport function getSelectedWindow(windowType: WindowType, length: number, correct: boolean = true): Float32Array {\r\n    const type = windowType;\r\n    let window = new Float32Array(length);\r\n    let wcf = 1; // Window correction factor\r\n    if (type === 'hanning') { window = hanningWindow(length); wcf = 2.000; }\r\n    if (type === 'hamming') { window = hammingWindow(length); wcf = 1.852; }\r\n    if (type === 'blackman') { window = blackmanWindow(length); wcf = 2.381; }\r\n    if (type === 'rectangular') { window = rectangularWindow(length); wcf = 1.000; }\r\n    if (correct) {\r\n        window = window.map(v => v / wcf); // Scale to max 2 for better visualization\r\n    }\r\n\r\n    return window;\r\n}\r\n\r\nexport function tukeyWindow(length: number, alpha: number = 0.5): Float32Array {\r\n    if (length < 1) return new Float32Array(0);\r\n    if (length === 1) return new Float32Array([1]);\r\n    const N = length;\r\n    const w = new Float32Array(N);\r\n\r\n    if (alpha <= 0) {\r\n        w.fill(1); // rectangular\r\n        return w;\r\n    }\r\n    if (alpha >= 1) {\r\n        // Equivalent to a Hann/Hanning window\r\n        for (let i = 0; i < N; i++) {\r\n            w[i] = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (N - 1)));\r\n        }\r\n        return w;\r\n    }\r\n\r\n    const edge = alpha * (N - 1) / 2;\r\n    const denom = alpha * (N - 1);\r\n\r\n    for (let n = 0; n < N; n++) {\r\n        if (n <= edge) {\r\n            w[n] = 0.5 * (1 + Math.cos(Math.PI * ((2 * n) / denom - 1)));\r\n        } else if (n >= (N - 1 - edge)) {\r\n            // symmetric tail\r\n            const m = N - 1 - n;\r\n            w[n] = 0.5 * (1 + Math.cos(Math.PI * ((2 * m) / denom - 1)));\r\n        } else {\r\n            w[n] = 1;\r\n        }\r\n    }\r\n\r\n    return w;\r\n}","export const COLORS = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\nfunction addPlotToList(tabId: string, plotId: string, plotName: string, hidden: boolean = false): void {\n    const plotList = document.getElementById(`plot-list-${tabId}`) as HTMLElement;\n    const listItem = document.createElement('li');\n    listItem.innerHTML = `<input type=\"checkbox\" id=\"checkbox-${plotId}\" alt=\"show/hide\" ${hidden ? '' : 'checked'}><label for=\"checkbox-${plotId}\">${plotName}</label>`;\n    plotList.appendChild(listItem);\n}\n\nfunction addPlotElement(tabId: string, plotId: string, hidden: boolean = false): HTMLElement {\n    const tabContent = document.querySelector(`[data-content=\"${tabId}\"]`) as HTMLElement;\n    const plotBox = document.createElement('div');\n    plotBox.className = 'plot-box';\n    plotBox.innerHTML = `\n        <div id=\"${plotId}\" class=\"plot-medium\"></div>\n        <div class=\"button-bar\">\n            <button>Customize...</button>\n            <button>Export as...</button>   \n            <label for=\"checkbox-${plotId}\">Hide</label>\n        </div>\n    `;\n    tabContent.querySelector('.plot-outer')?.appendChild(plotBox);\n    if (hidden) {\n        plotBox.style.display = 'none';\n    }\n    return plotBox.querySelector(`#${plotId}`) as HTMLElement;\n}\n\nexport function plot(\n    traces: any[], \n    tabId: string,\n    title: string, \n    xTitle: string, \n    yTitle: string, \n    xAxisExtras: any = {},\n    yAxisExtras: any = {},\n    layoutExtras: any = {},\n    hidden: boolean = false,\n): void {\n    const plotSettings: {[key: string]: any} = {\n        plotGlPixelRatio: 2, // For better clarity on high-DPI screens\n        legend: {\"orientation\": \"h\", \"y\": -0.2, \"yanchor\": \"top\"},\n        plot_bgcolor: '#fafbfc',\n        paper_bgcolor: '#fff',\n        staticPlot: false, // Enable interactivity\n        dragmode: 'pan',\n        showAxisDragHandles: true,\n        showAxisRangeEntryBoxes: true,\n        axisDragOnHover: true,\n        tightenLats: true,\n        font: {\n            family: \"'Newsreader', Georgia, 'Times New Roman', Times, serif\",\n        },\n        margin: { t: 80, r: 65, b: 70, l: 65 }\n    };\n\n    const layout = {\n        title: title,\n        xaxis: { \n            title: xTitle,\n            gridcolor: '#e1e4e8',\n            //tickformat: '.0f',\n            ...xAxisExtras\n        },\n        yaxis: { \n            title: yTitle,\n            gridcolor: '#e1e4e8',\n            automargin: true,\n            ...yAxisExtras\n        },\n        ...layoutExtras,\n        ...plotSettings\n    };\n\n    const plotId = `plot-${tabId}-${title.toLowerCase().replace(/\\s+/g, '-')}`;\n\n    const element = addPlotElement(tabId, plotId, hidden);\n    (window as any).Plotly.newPlot(element, traces, layout, {responsive: true});\n    addPlotToList(tabId, plotId, title, hidden);\n\n    document.getElementById(`checkbox-${plotId}`)?.addEventListener('change', (e) => {\n        const box = document.getElementById(`${plotId}`)!.parentElement!;\n        box.setAttribute('style', (e.target as HTMLInputElement).checked ? 'display: block;' : 'display: none;');\n        window.dispatchEvent(new Event('resize'));\n    });\n\n    console.log(`Plotted ${title} in tab ${tabId}`);\n}\n\n","import { closest, linspace, max } from './math';\nimport { getSelectedWindow } from './windows';\nimport { computeFFTFromIR, db, fftConvolve, smoothFFT } from './audio';\nimport { ImpulseResponseResult } from './audio';\nimport { plot, COLORS } from './plotting';\n\nexport class Farina {\n    /* Farina deconvolution implementation according to the Python implementation. */\n    constructor(stimulus: Float32Array, f_start: number = 50, f_stop: number = 22800, fs: number = 48000) {\n        this.f_start = f_start;\n        this.f_stop = f_stop;\n        this.fs = fs;\n        this.stimulus = stimulus;\n        this.duration = this.stimulus.length / this.fs;\n    }\n\n    f_start: number;\n    f_stop: number;\n    fs: number;\n    stimulus: Float32Array;\n    deconvolved: Float32Array = Float32Array.from([]);\n    duration: number;\n\n    lag_of_harmonic(n: number) {\n        return this.ell() * Math.log(n);\n    }\n\n    margin_of_harmonic(n: number) {\n        return this.ell() * Math.log(n + 1) - this.ell() * Math.log(n);\n    }\n\n    max_safe_harmonic(window_size: number): number {\n        const t: number[] = [];\n        for (let n = 1; n < 1000; n++) {\n            if (this.margin_of_harmonic(n) > window_size) {\n                t.push(this.margin_of_harmonic(n));\n            }\n        }\n        return t.length < 999 ? t.length : 0;\n    }\n\n    ell(): number {\n        return this.duration / Math.log(this.f_stop / this.f_start);\n    }\n\n    rate(length: number): number {\n        return 1 / this.f_start * Math.PI * Math.round(length * this.f_start / Math.log2(this.f_stop / this.f_start));\n    }\n\n    instant(): number {\n        // Lag between the start of the sweep and the stimulus.\n        return closest(100000000, this.deconvolved);\n    }\n\n    window(signal: ImpulseResponseResult, at: number, length: number): ImpulseResponseResult {\n        const size = Math.floor(length * this.fs);\n        const window: Float32Array = getSelectedWindow('rectangular', size, false);\n\n        const si = signal.ir.slice(at - size / 2, at + size / 2);\n        const w = Float32Array.from({ length: size }, () => 0);\n\n        if (si.length === window.length) {\n            for (let i = 0; i < window.length; i++) {\n                w[i] = window[i] * si[i];\n            }\n        }\n\n        const ir_complex = Float32Array.from({ length: w.length * 2 }, () => 0);\n        for (let i = 0; i < w.length; i++) {\n            ir_complex[2 * i] = w[i];\n            ir_complex[2 * i + 1] = 0;\n        }\n\n        return {\n            ir: w,\n            ir_complex,\n            t: linspace((-size - 1) / 2 / this.fs, (size - 1) / 2 / this.fs, size),\n            peakAt: at,\n            sampleRate: this.fs,\n            fftSize: w.length,\n        }\n    }\n\n    deconvolution(signal: Float32Array): Float32Array {\n        const n: Float32Array = linspace(0, this.stimulus.length - 1, this.stimulus.length);\n        const ell = this.ell();\n        const k: Float32Array = n.map(v => Math.exp(v / ell / this.fs)); // simplified for first element\n\n        const inv_stimulus = this.stimulus.slice().reverse().map ((v, i) => v / k[i]);\n\n        const deconvolved: Float32Array = fftConvolve(signal, inv_stimulus, 'same').slice();\n        const norm = max(fftConvolve(this.stimulus, inv_stimulus, 'same').map(v => Math.abs(v)));\n\n        this.deconvolved = deconvolved.map(v => v / norm);\n        return this.deconvolved;\n    }\n\n    deconvolvedResponse(signal: Float32Array): ImpulseResponseResult {\n        const ir = this.deconvolution(signal);\n        const peakAt = this.instant();\n\n        const ir_complex = Float32Array.from({ length: ir.length * 2 }, () => 0);\n        for (let i = 0; i < ir.length; i++) {\n                ir_complex[2 * i] = ir[i];\n                ir_complex[2 * i + 1] = 0;\n        }\n\n        return {\n            ir,\n            ir_complex,\n            t: linspace((- peakAt)/ this.fs, (- peakAt + ir.length - 1)/ this.fs, ir.length),\n            peakAt,\n            sampleRate: this.fs,\n            fftSize: ir.length,\n        };\n    }\n\n    harmonics(windowSize: number, harmonicsCount: number): ImpulseResponseResult[] {\n        const results: ImpulseResponseResult[] = [];\n        for (let n = 0; n <= harmonicsCount; n++) {\n            const at = Math.round(this.instant() - this.lag_of_harmonic(n + 1) * this.fs);\n            const w = this.window({\n                ir: this.deconvolved,\n                ir_complex: Float32Array.from([]),\n                t: Float32Array.from([]),\n                peakAt: at,\n                sampleRate: this.fs,\n                fftSize: this.deconvolved.length,\n            }, at, windowSize);\n            results.push(w);\n        }\n        return results;\n    }\n\n}\n\nexport function plotDistortion(farina: Farina, windowSize: number, maxHarmonics: number, tabId: string): void {\n    const harmonics = farina.harmonics(windowSize, maxHarmonics);\n    const harmonicsFFT = harmonics.map((h, n) => computeFFTFromIR(h, 1000, 1 / (n + 1)));\n    const smoothedHarmonicsFFT = harmonicsFFT.map(hf => smoothFFT(hf, 1/6, 1/96));\n\n    const traces: any[] = [];\n    for (let n = 0; n < smoothedHarmonicsFFT.length; n++) {\n        const color = COLORS[n % COLORS.length];\n\n        const response = harmonicsFFT[n];\n        const smoothedResponse = smoothedHarmonicsFFT[n];\n        if (n === 0) {\n            traces.push({\n                x: response.frequency.map(f => f / (n + 1)),\n                y: db(response.magnitude),\n                type: 'scatter',\n                mode: 'lines',\n                name: n === 0 ? 'Fundamental' : `Harmonic ${n + 1}`,\n                line: {\n                    width: .75,\n                    color: color + '33', // Lighter color for raw\n                },\n                showlegend: n === 0,\n            });\n        }\n        traces.push({\n            x: smoothedResponse.frequency.map(f => f / (n + 1)),\n            y: db(smoothedResponse.magnitude),\n            type: 'scatter',\n            mode: 'lines',\n            name: (n === 0 ? 'Fundamental' : `Harmonic ${n + 1}`) + ' (Smoothed)',\n            line: {\n                width: 1.5,\n                color: color,\n            },\n        });\n\n        \n    }\n    plot(\n        traces,\n        tabId, \n        'Fundamental and Harmonic Distortion', \n        'Frequency (Hz)', \n        'Amplitude (dBFS)',\n        {type: 'log', range: [Math.log10(20), Math.log10(20000)]}, \n        {range: [-85, 5]},\n        {}, \n        false\n    );\n}\n\nexport function plotTHD(farina: Farina, windowSize: number, maxHarmonics: number, tabId: string): void {\n    const harmonics = farina.harmonics(windowSize, maxHarmonics);\n    const harmonicsFFT = harmonics.map((h, n) => computeFFTFromIR(h, 1000, 1 / (n + 1)));\n    const smoothedHarmonicsFFT = harmonicsFFT.map(hf => smoothFFT(hf, 1/6, 1/96));\n\n    const fundamental = smoothedHarmonicsFFT[0];\n    const traces: any[] = [];\n\n    const thd: Float32Array = Float32Array.from({ length: fundamental.magnitude.length }, () => 0);\n    for (let i = 0; i < fundamental.magnitude.length; i++) {\n        let sumSquares = 0;\n        for (let n = 1; n < smoothedHarmonicsFFT.length; n++) {\n            sumSquares += Math.pow(smoothedHarmonicsFFT[n].magnitude[i], 2);\n        }\n        thd[i] = Math.sqrt(sumSquares) / fundamental.magnitude[i];\n    }\n\n    traces.push({\n        x: fundamental.frequency,\n        y: thd.map(v => v * 100), // Convert to percentage\n        type: 'scatter',\n        mode: 'lines',\n        name: 'Total Harmonic Distortion (THD)',\n        line: {\n            width: 1.5,\n            color: COLORS[0],\n        },\n    });\n\n    plot(\n        traces,\n        tabId, \n        'Total Harmonic Distortion', \n        'Frequency (Hz)', \n        'THD (%)',\n        {type: 'log', range: [Math.log10(20), Math.log10(20000)]}, \n        {range: [0, 5]},\n        {}, \n        false\n    );  \n}\n","// IndexedDB-backed storage helpers\nfunction openIDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n        const req = indexedDB.open('dunkadunka-storage', 1);\n        req.onupgradeneeded = () => {\n            const db = req.result;\n            if (!db.objectStoreNames.contains('kv')) {\n                db.createObjectStore('kv', { keyPath: 'key' });\n            }\n        };\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n    });\n}\n\nasync function setItem(key: string, value: string): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.put({ key, value });\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n        // mirror to sessionStorage for synchronous reads elsewhere\n        try { setItem(key, value); } catch { /* ignore */ }\n    } catch (e) {\n        console.error('setItem(idb) failed', e);\n    }\n}\n\nasync function getItem(key: string): Promise<string | null> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readonly');\n        const store = tx.objectStore('kv');\n        const req = store.get(key);\n        const res = await new Promise<any>((resolve, reject) => {\n            req.onsuccess = () => resolve(req.result);\n            req.onerror = () => reject(req.error);\n        });\n        return res?.value ?? null;\n    } catch (e) {\n        console.error('getItem(idb) failed', e);\n        return null;\n    }\n}\n\nasync function removeItem(key: string): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.delete(key);\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n    } catch (e) {\n        console.error('removeItem(idb) failed', e);\n    }\n}\n\nasync function clearStorage(): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.clear();\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n        // also clear sessionStorage\n        try { sessionStorage.clear(); } catch { /* ignore */ }\n    } catch (e) {\n        console.error('clearStorage(idb) failed', e);\n    }\n}\n\nasync function dumpStorage(): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readonly');\n        const store = tx.objectStore('kv');\n        const req = store.openCursor();\n        req.onsuccess = (event) => {\n            const cursor = (event.target as IDBRequest).result;\n            if (cursor) {\n                console.log(`Key: ${cursor.key}, Value: ${cursor.value.value}`);\n                cursor.continue();\n            }\n        };\n        req.onerror = () => {\n            console.error('dumpStorage(idb) failed', req.error);\n        };\n    } catch (e) {\n        console.error('dumpStorage(idb) failed', e);\n    }\n}\n\nexport const storage = {\n    setItem,\n    getItem,\n    removeItem,\n    clearStorage,\n    dumpStorage\n};","// Device settings for audio input/output selection\n\nconst INPUT_KEY = 'preferredAudioInputId';\nconst OUTPUT_KEY = 'preferredAudioOutputId';\n\nexport function openDeviceSettings(): void {\n    const modal = document.getElementById('deviceSettingsModal');\n    if (modal) {\n        modal.style.display = 'flex';\n        initDeviceSettings();\n    }\n}\n\nexport function closeDeviceSettings(): void {\n    const modal = document.getElementById('deviceSettingsModal');\n    if (modal) {\n        modal.style.display = 'none';\n    }\n}\n\nasync function ensureDeviceAccess(): Promise<void> {\n    try {\n        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;\n        // Request permission so labels are revealed\n        await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n    } catch (_) {\n        // Permission may be denied; device labels may be blank\n    }\n}\n\nexport async function refreshAudioDeviceList(): Promise<void> {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n        console.warn('MediaDevices API not available');\n        return;\n    }\n\n    await ensureDeviceAccess();\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const inputSel = document.getElementById('inputDeviceSelect') as HTMLSelectElement | null;\n    const outputSel = document.getElementById('outputDeviceSelect') as HTMLSelectElement | null;\n\n    if (!inputSel || !outputSel) return;\n\n    inputSel.innerHTML = '<option value=\"\">Default input</option>';\n    outputSel.innerHTML = '<option value=\"\">Default output</option>';\n\n    const inputId = localStorage.getItem(INPUT_KEY) || '';\n    const outputId = localStorage.getItem(OUTPUT_KEY) || '';\n\n    devices.forEach(d => {\n        if (d.kind === 'audioinput') {\n            const opt = document.createElement('option');\n            opt.value = d.deviceId;\n            opt.textContent = d.label || `Microphone (${d.deviceId.slice(0, 8)})`;\n            if (d.deviceId === inputId) opt.selected = true;\n            inputSel.appendChild(opt);\n        } else if (d.kind === 'audiooutput') {\n            const opt = document.createElement('option');\n            opt.value = d.deviceId;\n            opt.textContent = d.label || `Speaker (${d.deviceId.slice(0, 8)})`;\n            if (d.deviceId === outputId) opt.selected = true;\n            outputSel.appendChild(opt);\n        }\n    });\n\n    const note = document.getElementById('sinkSupportNote');\n    if (note) {\n        const sinkSupported = typeof HTMLMediaElement !== 'undefined' && 'setSinkId' in HTMLMediaElement.prototype;\n        note.textContent = sinkSupported\n            ? 'Output routing supported on this browser.'\n            : 'Output routing (setSinkId) not supported by this browser.';\n    }\n}\n\nasync function applyOutputDevice(deviceId: string): Promise<void> {\n    const router = document.getElementById('appOutputRouter') as HTMLAudioElement | null;\n    if (!router) return;\n\n    if ('setSinkId' in HTMLMediaElement.prototype) {\n        try {\n            await (router as any).setSinkId(deviceId || '');\n        } catch (e) {\n            console.warn('Failed to set sinkId:', e);\n        }\n    }\n}\n\nexport function saveDeviceSelections(): void {\n    const inputSel = document.getElementById('inputDeviceSelect') as HTMLSelectElement | null;\n    const outputSel = document.getElementById('outputDeviceSelect') as HTMLSelectElement | null;\n\n    if (!inputSel || !outputSel) return;\n\n    localStorage.setItem(INPUT_KEY, inputSel.value || '');\n    localStorage.setItem(OUTPUT_KEY, outputSel.value || '');\n\n    applyOutputDevice(outputSel.value || '');\n    closeDeviceSettings();\n}\n\nasync function initDeviceSettings(): Promise<void> {\n    await refreshAudioDeviceList();\n\n    // Persist immediately when changed\n    const inputSel = document.getElementById('inputDeviceSelect') as HTMLSelectElement | null;\n    const outputSel = document.getElementById('outputDeviceSelect') as HTMLSelectElement | null;\n\n    if (!inputSel || !outputSel) return;\n\n    inputSel.onchange = () => {\n        localStorage.setItem(INPUT_KEY, inputSel.value || '');\n    };\n    outputSel.onchange = () => {\n        localStorage.setItem(OUTPUT_KEY, outputSel.value || '');\n        applyOutputDevice(outputSel.value || '');\n    };\n}\n\n// Update list if devices change while modal is open\nif (navigator.mediaDevices && 'ondevicechange' in navigator.mediaDevices) {\n    navigator.mediaDevices.addEventListener('devicechange', () => {\n        const modal = document.getElementById('deviceSettingsModal');\n        if (modal && modal.style.display === 'flex') {\n            refreshAudioDeviceList();\n        }\n    });\n}\n\n// Apply preferred output on load (best-effort)\ndocument.addEventListener('DOMContentLoaded', () => {\n    const outId = localStorage.getItem(OUTPUT_KEY);\n    if (outId) applyOutputDevice(outId);\n});\n\n// Export functions to global scope for inline onclick handlers\n(window as any).openDeviceSettings = openDeviceSettings;\n(window as any).closeDeviceSettings = closeDeviceSettings;\n(window as any).refreshAudioDeviceList = refreshAudioDeviceList;\n(window as any).saveDeviceSelections = saveDeviceSelections;\n","import audio from \"./audio\";\n\nexport class AudioRecorder {\n    audioContext: AudioContext;\n\n    constructor(audioContext: AudioContext) {\n        this.audioContext = audioContext;\n    }\n\n    async record(durationSec: number): Promise<Float32Array[]> {\n        const recording: Float32Array[] = [\n            new Float32Array(durationSec * this.audioContext.sampleRate),\n            new Float32Array(durationSec * this.audioContext.sampleRate)\n        ];\n        let pointer = 0;\n\n        await this.audioContext.audioWorklet.addModule('static/buffering-processor.worklet.js');\n        const stream = await navigator.mediaDevices.getUserMedia({ \n            audio: { \n                echoCancellation: false, \n                noiseSuppression: false, \n                autoGainControl: false \n            } \n        });\n\n        const streamSource = this.audioContext.createMediaStreamSource(stream);\n        const worklet = new AudioWorkletNode(\n        this.audioContext, 'buffering-processor', {\n            numberOfInputs: 1,\n            numberOfOutputs: 0,\n            processorOptions: {\n                buffer: null\n            }\n        });\n        \n        streamSource.connect(worklet);\n\n        worklet.port.onmessage = (event) => {\n            if (pointer + event.data.buffer[0].length > recording[0].length) \n            {\n                worklet.disconnect();\n                streamSource.disconnect();\n                return new Promise<Float32Array[]>((resolve) => {resolve(recording);});\n            }\n            recording[0].set(event.data.buffer[0], pointer);\n            recording[1].set(event.data.buffer[1], pointer);\n            pointer += event.data.buffer[0].length;\n        };\n\n        return new Promise<Float32Array[]>((resolve) => {\n            setTimeout(() => {\n                worklet.disconnect();\n                streamSource.disconnect();\n                stream.getTracks().forEach(track => track.stop());\n                resolve(recording);\n            }, durationSec * 1500);\n        });\n    }\n}","export interface WaveReadResult {\n  samples: Float32Array; // interleaved\n  sampleRate: number;\n  channels: number;\n  bitsPerSample: number;\n  format: number;\n  frames: number;\n}\n\nexport function download(samples: Float32Array | number[], sampleRate = 48000, name = 'output'): void {\n  const channels = 1;\n  const bytesPerSample = 2;\n  const blockAlign = channels * bytesPerSample;\n  const byteRate = sampleRate * blockAlign;\n  const dataSize = samples.length * bytesPerSample;\n  const buffer = new ArrayBuffer(44 + dataSize);\n  const view = new DataView(buffer);\n\n  function writeString(offset: number, str: string) {\n    for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));\n  }\n\n  // RIFF header\n  writeString(0, 'RIFF');\n  view.setUint32(4, 36 + dataSize, true);\n  writeString(8, 'WAVE');\n  writeString(12, 'fmt ');\n  view.setUint32(16, 16, true); // Subchunk1Size (PCM)\n  view.setUint16(20, 1, true); // AudioFormat (PCM)\n  view.setUint16(22, channels, true);\n  view.setUint32(24, sampleRate, true);\n  view.setUint32(28, byteRate, true);\n  view.setUint16(32, blockAlign, true);\n  view.setUint16(34, 16, true); // BitsPerSample\n  writeString(36, 'data');\n  view.setUint32(40, dataSize, true);\n\n  // PCM 16-bit samples\n  let offset = 44;\n  for (let i = 0; i < samples.length; i++, offset += 2) {\n    const s = Math.max(-1, Math.min(1, Number(samples[i])));\n    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n  }\n\n  const blob = new Blob([buffer], { type: 'audio/wav' });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = name + `.wav`;\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n  URL.revokeObjectURL(url);\n}\n\nexport async function read(bufferOrBlob: Blob | ArrayBuffer | Uint8Array): Promise<WaveReadResult> {\n  let buffer: ArrayBuffer;\n  if (bufferOrBlob instanceof Blob) buffer = await bufferOrBlob.arrayBuffer();\n  else if (bufferOrBlob instanceof ArrayBuffer) buffer = bufferOrBlob;\n  else if (bufferOrBlob instanceof Uint8Array) {\n    // Copy the Uint8Array into a new ArrayBuffer to ensure we have a plain ArrayBuffer\n    const tmp = new ArrayBuffer(bufferOrBlob.byteLength);\n    new Uint8Array(tmp).set(bufferOrBlob);\n    buffer = tmp;\n  } else throw new TypeError('Expected Blob, ArrayBuffer or Uint8Array');\n\n  const view = new DataView(buffer);\n  const readStr = (off: number, len: number): string => {\n    let s = '';\n    for (let i = 0; i < len; i++) s += String.fromCharCode(view.getUint8(off + i));\n    return s;\n  };\n\n  if (readStr(0, 4) !== 'RIFF' || readStr(8, 4) !== 'WAVE') throw new Error('Not a valid WAVE file');\n\n  let offset = 12;\n  let fmt: { audioFormat: number; channels: number; sampleRate: number; byteRate: number; blockAlign: number; bitsPerSample: number } | null = null;\n  let dataOffset = -1;\n  let dataSize = 0;\n\n  while (offset + 8 <= view.byteLength) {\n    const id = readStr(offset, 4);\n    const size = view.getUint32(offset + 4, true);\n    const chunkStart = offset + 8;\n\n    if (id === 'fmt ') {\n      const audioFormat = view.getUint16(chunkStart, true);\n      const channels = view.getUint16(chunkStart + 2, true);\n      const sampleRate = view.getUint32(chunkStart + 4, true);\n      const byteRate = view.getUint32(chunkStart + 8, true);\n      const blockAlign = view.getUint16(chunkStart + 12, true);\n      const bitsPerSample = view.getUint16(chunkStart + 14, true);\n      fmt = { audioFormat, channels, sampleRate, byteRate, blockAlign, bitsPerSample };\n    } else if (id === 'data') {\n      dataOffset = chunkStart;\n      dataSize = size;\n    }\n\n    offset = chunkStart + size;\n    if (size % 2 === 1) offset++; // pad byte\n  }\n\n  if (!fmt) throw new Error('Missing \"fmt \" chunk');\n  if (dataOffset < 0) throw new Error('Missing \"data\" chunk');\n\n  const { audioFormat, channels, sampleRate, bitsPerSample } = fmt;\n  const bytesPerSample = bitsPerSample / 8;\n  const totalFrames = Math.floor(dataSize / (bytesPerSample * channels));\n  const out = new Float32Array(totalFrames * channels);\n\n  let p = dataOffset;\n  if (audioFormat === 1) {\n    // PCM integer\n    if (bitsPerSample === 8) {\n      for (let i = 0, o = 0; i < totalFrames * channels; i++, o++) {\n        const v = view.getUint8(p++);\n        out[o] = (v - 128) / 128;\n      }\n    } else if (bitsPerSample === 16) {\n      for (let i = 0, o = 0; i < totalFrames * channels; i++, o++) {\n        const v = view.getInt16(p, true);\n        p += 2;\n        out[o] = v < 0 ? v / 0x8000 : v / 0x7fff;\n      }\n    } else if (bitsPerSample === 24) {\n      for (let i = 0, o = 0; i < totalFrames * channels; i++, o++) {\n        const b0 = view.getUint8(p++);\n        const b1 = view.getUint8(p++);\n        const b2 = view.getUint8(p++);\n        let val = (b2 << 16) | (b1 << 8) | b0;\n        if (val & 0x800000) val |= ~0xffffff;\n        out[o] = val / 8388608; // 2^23\n      }\n    } else if (bitsPerSample === 32) {\n      for (let i = 0, o = 0; i < totalFrames * channels; i++, o++) {\n        const v = view.getInt32(p, true);\n        p += 4;\n        out[o] = v < 0 ? v / 0x80000000 : v / 0x7fffffff;\n      }\n    } else {\n      throw new Error('Unsupported PCM bitsPerSample: ' + bitsPerSample);\n    }\n  } else if (audioFormat === 3) {\n    // IEEE float\n    if (bitsPerSample !== 32 && bitsPerSample !== 64) throw new Error('Unsupported float bit depth: ' + bitsPerSample);\n    if (bitsPerSample === 32) {\n      for (let i = 0, o = 0; i < totalFrames * channels; i++, o++) {\n        out[o] = view.getFloat32(p, true);\n        p += 4;\n      }\n    } else {\n      for (let i = 0, o = 0; i < totalFrames * channels; i++, o++) {\n        out[o] = view.getFloat64(p, true);\n        p += 8;\n      }\n    }\n  } else {\n    throw new Error('Unsupported audio format: ' + audioFormat);\n  }\n\n  return {\n    samples: out,\n    sampleRate,\n    channels,\n    bitsPerSample,\n    format: audioFormat,\n    frames: totalFrames\n  };\n}\n","import { Audio, computeFFT, computeFFTFromIR, db, FFTResult, groupDelays, ImpulseResponseResult, rms, smoothFFT, twoChannelImpulseResponse } from \"./audio\";\nimport { Farina, plotDistortion, plotTHD } from \"./farina\";\nimport { storage } from \"./storage\";\nimport { audio } from \"./audio\";\nimport \"./device-settings\";\nimport { linspace, max } from \"./math\";\nimport { COLORS, plot } from \"./plotting\";\nimport { AudioRecorder } from \"./recorder\";\nimport { download } from \"./wave\";\n\nconsole.debug(\"App module loaded\");\n\nconst root = document.documentElement;\nconst uiColor = \"#0366d6\";\nroot.style.setProperty('--color', uiColor);\n\nlet tabCounter = 0;\nconst tabsContainer = document.getElementById('tabs-outer') as HTMLElement;\nconst tabsInnerContainer = document.getElementById('tabs') as HTMLElement;\nconst tabContents = document.getElementById('tab-contents') as HTMLElement;\nconst responseFileUploadInput = document.getElementById('responseFileUpload') as HTMLInputElement;\nconst referenceFileUploadInput = document.getElementById('referenceFileUpload') as HTMLInputElement;\nconst analyzeUploadBtn = document.getElementById('analyzeUploadBtn') as HTMLButtonElement;\n\n// Polar upload controls\nconst polarReferenceFileInput = document.getElementById('polarReferenceFile') as HTMLInputElement;\nconst polarMeasurementsEl = document.getElementById('polarMeasurements') as HTMLElement;\nconst addPolarMeasurementBtn = document.getElementById('addPolarMeasurementBtn') as HTMLButtonElement;\nconst analyzePolarBtn = document.getElementById('analyzePolarBtn') as HTMLButtonElement;\nconst polarStatusEl = document.getElementById('polarStatus') as HTMLElement;\n\n// Enable analyze button when response file is selected\nresponseFileUploadInput.addEventListener('change', () => {\n    analyzeUploadBtn.disabled = !responseFileUploadInput.files?.length;\n});\n\ntype PolarMeasurement = { angleDeg: number; file: File };\n\nfunction normalizeAngleDeg(angleDeg: number): number {\n    let a = angleDeg % 360;\n    if (a < 0) a += 360;\n    return a;\n}\n\nfunction getPolarMeasurements(): PolarMeasurement[] {\n    const rows = Array.from(polarMeasurementsEl.querySelectorAll<HTMLElement>('.polar-measurement-row'));\n    const out: PolarMeasurement[] = [];\n    for (const row of rows) {\n        const angleInput = row.querySelector<HTMLInputElement>('.polar-angle');\n        const fileInput = row.querySelector<HTMLInputElement>('.polar-response-file');\n        if (!angleInput || !fileInput) continue;\n\n        const file = fileInput.files?.[0];\n        if (!file) continue;\n\n        const parsed = parseFloat(angleInput.value);\n        const angleDeg = Number.isFinite(parsed) ? normalizeAngleDeg(parsed) : 0;\n        out.push({ angleDeg, file });\n    }\n    return out;\n}\n\nfunction updatePolarAnalyzeEnabled(): void {\n    const hasReference = !!polarReferenceFileInput.files?.length;\n    const hasAnyMeasurement = getPolarMeasurements().length > 0;\n    analyzePolarBtn.disabled = !(hasReference && hasAnyMeasurement);\n\n    if (!hasReference) {\n        polarStatusEl.textContent = 'Select a reference/stimulus file.';\n    } else if (!hasAnyMeasurement) {\n        polarStatusEl.textContent = 'Add at least one measurement (angle + file).';\n    } else {\n        polarStatusEl.textContent = '';\n    }\n}\n\nfunction addPolarMeasurementRow(initialAngleDeg: number = 0): void {\n    const row = document.createElement('div');\n    row.className = 'param-row polar-measurement-row';\n    row.innerHTML = `\n        <label>Angle (deg):</label>\n        <input type=\"number\" class=\"param-input polar-angle\" value=\"${initialAngleDeg}\" step=\"1\" min=\"0\" max=\"360\">\n        <input type=\"file\" class=\"polar-response-file\" accept=\"audio/*,.wav,.mp3,.flac,.ogg\">\n        <button class=\"button-custom button-custom-secondary polar-remove\" type=\"button\">Remove</button>\n    `;\n    polarMeasurementsEl.appendChild(row);\n}\n\n// Polar UI wiring\npolarReferenceFileInput.addEventListener('change', updatePolarAnalyzeEnabled);\naddPolarMeasurementBtn.addEventListener('click', () => {\n    addPolarMeasurementRow(0);\n    updatePolarAnalyzeEnabled();\n});\npolarMeasurementsEl.addEventListener('input', (e) => {\n    const t = e.target as HTMLElement;\n    if (t.classList.contains('polar-angle')) updatePolarAnalyzeEnabled();\n});\npolarMeasurementsEl.addEventListener('change', (e) => {\n    const t = e.target as HTMLElement;\n    if (t.classList.contains('polar-response-file')) updatePolarAnalyzeEnabled();\n});\npolarMeasurementsEl.addEventListener('click', (e) => {\n    const t = e.target as HTMLElement;\n    if (!t.classList.contains('polar-remove')) return;\n    const row = t.closest('.polar-measurement-row');\n    row?.remove();\n    if (polarMeasurementsEl.querySelectorAll('.polar-measurement-row').length === 0) {\n        addPolarMeasurementRow(0);\n    }\n    updatePolarAnalyzeEnabled();\n});\n\nupdatePolarAnalyzeEnabled();\n\n// ============================================================================\n// Acquisition Tab Functionality\n// ============================================================================\n\ninterface AcquisitionState {\n    audioContext: AudioContext | null;\n    mediaRecorder: MediaRecorder | null;\n    recordedChunks: Blob[];\n    oscillatorNode: OscillatorNode | null;\n    playbackSource: AudioBufferSourceNode | null;\n    isRecording: boolean;\n}\n\nconst acquisitionState: AcquisitionState = {\n    audioContext: null,\n    mediaRecorder: null,\n    recordedChunks: [],\n    oscillatorNode: null,\n    playbackSource: null,\n    isRecording: false\n};\n\nconst startBtn = document.getElementById('startBtn') as HTMLButtonElement;\nconst stopBtn = document.getElementById('stopBtn') as HTMLButtonElement;\nconst playBtn = document.getElementById('playBtn') as HTMLButtonElement;\nconst stopPlayBtn = document.getElementById('stopPlayBtn') as HTMLButtonElement;\nconst sweepStartFreqInput = document.getElementById('sweepStartFreq') as HTMLInputElement;\nconst sweepEndFreqInput = document.getElementById('sweepEndFreq') as HTMLInputElement;\nconst sweepDurationInput = document.getElementById('sweepDuration') as HTMLInputElement;\nconst recordingStatusEl = document.getElementById('recordingStatus') as HTMLElement;\nconst recordingMeterEl = document.getElementById('recordingMeter') as HTMLElement;\nconst recordingVisualizationEl = document.getElementById('recordingVisualization') as HTMLElement;\nconst recordedAudioContainer = document.getElementById('recordedAudioContainer') as HTMLElement;\nconst recordedAudioEl = document.getElementById('recordedAudio') as HTMLAudioElement;\nconst analyzeRecordingBtn = document.getElementById('analyzeRecordingBtn') as HTMLButtonElement;\nconst viewWaveformBtn = document.getElementById('viewWaveformBtn') as HTMLButtonElement;\nconst channelSelectionContainer = document.getElementById('channelSelectionContainer') as HTMLElement;\nconst channelSelect = document.getElementById('channelSelect') as HTMLSelectElement;\n\nasync function initializeAudioContext(): Promise<AudioContext> {\n    if (!acquisitionState.audioContext) {\n        acquisitionState.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n    }\n    if (acquisitionState.audioContext.state === 'suspended') {\n        await acquisitionState.audioContext.resume();\n    }\n    return acquisitionState.audioContext;\n}\n\nasync function detectAndSetupChannels(): Promise<void> {\n    try {\n        // Request audio input to check channel count\n        const stream = await navigator.mediaDevices.getUserMedia({ \n            audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } \n        });\n        \n        const audioContext = await initializeAudioContext();\n        const analyser = audioContext.createAnalyser();\n        const source = audioContext.createMediaStreamSource(stream);\n        source.connect(analyser);\n\n        // Get channel count from the stream\n        const channelCount = source.mediaStream.getAudioTracks()[0].getSettings()?.channelCount || 1;\n        \n        // Stop the stream as we only need it for channel detection\n        stream.getTracks().forEach(track => track.stop());\n\n        // Populate channel selection\n        channelSelect.innerHTML = '';\n        for (let i = 0; i < channelCount; i++) {\n            const option = document.createElement('option');\n            option.value = i.toString();\n            const channelNames = ['Left', 'Right', 'Center', 'LFE', 'Back Left', 'Back Right'];\n            option.textContent = `Channel ${i + 1}${channelNames[i] ? ` (${channelNames[i]})` : ''}`;\n            channelSelect.appendChild(option);\n        }\n\n        // Show channel selection only if more than 1 channel\n        if (channelCount > 1) {\n            channelSelectionContainer.style.display = 'flex';\n        } else {\n            channelSelectionContainer.style.display = 'none';\n        }\n    } catch (error) {\n        console.error('Error detecting channels:', error);\n        channelSelectionContainer.style.display = 'none';\n    }\n}\n\n// Detect channels when the acquisition tab is opened\ntabsContainer.addEventListener('click', (e: MouseEvent) => {\n    const target = e.target as HTMLElement;\n    if (target.classList.contains('tab') && target.dataset.tab === 'acquisition') {\n        detectAndSetupChannels();\n    }\n});\n\nlet recorded = [Float32Array.from([]), Float32Array.from([])];\n\nasync function startRecordingAndPlayback(): Promise<void> {\n    try {\n        const audioContext = await initializeAudioContext();\n\n        // Generate and play sweep\n        const startFreq = parseFloat(sweepStartFreqInput.value);\n        const endFreq = parseFloat(sweepEndFreqInput.value);\n        const duration = parseFloat(sweepDurationInput.value);\n        \n        // Pre and post recording buffers (in seconds)\n        const preRecordTime = 0.5;  // Start recording 0.5s before playback\n        const postRecordTime = 1.0; // Continue recording 1s after playback ends\n        const totalRecordTime = preRecordTime + duration + postRecordTime;\n\n        const [sweepSignal, , ] = audio.chirp(startFreq, endFreq, duration);\n\n        // Create audio buffer from sweep signal\n        const audioBuffer = audioContext.createBuffer(1, sweepSignal.length, audioContext.sampleRate);\n        const channelData = audioBuffer.getChannelData(0);\n        channelData.set(sweepSignal);\n\n        // Create gain nodes for monitoring\n        const sourceGain = audioContext.createGain();\n        sourceGain.gain.value = 0.5;\n\n        // Start recording\n        recordingStatusEl.textContent = `Recording for ${totalRecordTime.toFixed(1)}s...`;\n        recordingVisualizationEl.style.display = 'block';\n\n        const recorder = new AudioRecorder(audioContext);\n        recorder.record(totalRecordTime).then((recordingData) => {\n            recorded = recordingData;\n            stopRecording();\n        });\n\n        // Update UI\n        startBtn.disabled = true;\n        stopBtn.disabled = false;\n        playBtn.disabled = true;\n        sweepStartFreqInput.disabled = true;\n        sweepEndFreqInput.disabled = true;\n        sweepDurationInput.disabled = true;\n\n        // Start playback after pre-record time\n        setTimeout(() => {\n            acquisitionState.playbackSource = audioContext.createBufferSource();\n            acquisitionState.playbackSource.buffer = audioBuffer;\n            acquisitionState.playbackSource.connect(sourceGain);\n            sourceGain.connect(audioContext.destination);\n            acquisitionState.playbackSource.start();\n        }, preRecordTime * 1000);\n\n        // Stop recording after total time (pre + sweep + post)\n        setTimeout(() => {\n            stopRecording();\n        }, totalRecordTime * 1000);\n\n    } catch (error) {\n        console.error('Error starting recording:', error);\n        recordingStatusEl.textContent = `Error: ${(error as Error).message}`;\n        recordingStatusEl.style.color = '#d73a49';\n    }\n}\n\nasync function playbackOnly(): Promise<void> {\n    try {\n        const audioContext = await initializeAudioContext();\n        \n        const startFreq = parseFloat(sweepStartFreqInput.value);\n        const endFreq = parseFloat(sweepEndFreqInput.value);\n        const duration = parseFloat(sweepDurationInput.value);\n\n        const [sweepSignal] = audio.chirp(startFreq, endFreq, duration);\n\n        // Create audio buffer from sweep signal\n        const audioBuffer = audioContext.createBuffer(1, sweepSignal.length, audioContext.sampleRate);\n        const channelData = audioBuffer.getChannelData(0);\n        channelData.set(sweepSignal);\n\n        // Create gain node\n        const sourceGain = audioContext.createGain();\n        sourceGain.gain.value = 0.5;\n\n        // Connect and start playback\n        acquisitionState.playbackSource = audioContext.createBufferSource();\n        acquisitionState.playbackSource.buffer = audioBuffer;\n        acquisitionState.playbackSource.connect(sourceGain);\n        sourceGain.connect(audioContext.destination);\n        acquisitionState.playbackSource.start();\n\n        recordingStatusEl.textContent = `Playing sweep...`;\n        recordingStatusEl.style.color = '#0366d6';\n\n        playBtn.disabled = true;\n        stopPlayBtn.disabled = false;\n\n        setTimeout(() => {\n            stopPlayback();\n        }, (duration + 0.5) * 1000);\n\n    } catch (error) {\n        console.error('Error during playback:', error);\n        recordingStatusEl.textContent = `Error: ${(error as Error).message}`;\n        recordingStatusEl.style.color = '#d73a49';\n    }\n}\n\nfunction stopRecording(): void {\n    recordingStatusEl.textContent = 'Recording complete. Ready to analyze.';\n    recordingStatusEl.style.color = '#28a745';\n\n    // Update UI\n    startBtn.disabled = false;\n    stopBtn.disabled = true;\n    playBtn.disabled = false;\n    sweepStartFreqInput.disabled = false;\n    sweepEndFreqInput.disabled = false;\n    sweepDurationInput.disabled = false;\n\n    recordedAudioContainer.style.display = 'block';\n}\n\nfunction stopPlayback(): void {\n    if (acquisitionState.playbackSource) {\n        try {\n            acquisitionState.playbackSource.stop();\n        } catch (e) {\n            // Already stopped\n        }\n    }\n\n    recordingStatusEl.textContent = 'Playback stopped.';\n    playBtn.disabled = false;\n    stopPlayBtn.disabled = true;\n}\n\n// Event listeners for acquisition controls\nstartBtn.addEventListener('click', startRecordingAndPlayback);\nstopBtn.addEventListener('click', stopRecording);\nplayBtn.addEventListener('click', playbackOnly);\nstopPlayBtn.addEventListener('click', stopPlayback);\n\nanalyzeRecordingBtn.addEventListener('click', async () => {\n    console.log('Analyzing recording...');\n\n    try {        \n        const recordedAudio = Audio.fromSamples(recorded[0], 48000);\n        download(recorded[0], 48000, 'recorded_audio.wav');\n        // Generate the chirp sweep as reference data\n        const startFreq = parseFloat(sweepStartFreqInput.value);\n        const endFreq = parseFloat(sweepEndFreqInput.value);\n        const duration = parseFloat(sweepDurationInput.value);\n\n        const [sweepSignal] = audio.chirp(startFreq, endFreq, duration);\n        const referenceAudio = Audio.fromSamples(sweepSignal, 48000);\n\n        // Add timestamp to recording name\n        const now = new Date();\n        const dateTime = now.toLocaleString('sv-SE', { \n            year: '2-digit', \n            month: '2-digit', \n            day: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit',\n            second: '2-digit',\n            hour12: false\n        }).replace(',', '');\n        const recordingName = `${dateTime}`;\n\n        createAnalysisTab(\n            recordedAudio.applyGain(1 / 16384),\n            referenceAudio.applyGain(1 / 16384),\n            recordingName,\n            `${startFreq}-${endFreq}Hz`,\n        );\n        // \n        \n    } catch (error) {\n        console.error('Error analyzing recording:', error);\n        alert('Error analyzing recording: ' + (error as Error).message);\n    }\n});\n\n// Save state when the user attempts to close or reload the window\nwindow.addEventListener('beforeunload', (e: BeforeUnloadEvent) => {\n    try {\n        saveState();\n    } catch (err) {\n        console.error('Failed to save state on beforeunload:', err);\n    }\n    // If you want to prompt the user to confirm leaving (browser-dependent), uncomment:\n    // e.preventDefault();\n    // e.returnValue = '';\n});\n\n// Tab switching\ntabsContainer.addEventListener('click', (e: MouseEvent) => {\n    const target = e.target as HTMLElement;\n    \n    if (target.classList.contains('tab-close')) {\n        const tab = target.parentElement as HTMLElement;\n        const tabId = tab.dataset.tab;\n        if (tabId == 'upload') return;\n\n        console.debug('Closing tab', tabId);\n        tab.remove();\n        document.querySelector(`[data-content=\"${tabId}\"]`)?.remove();\n        storage.removeItem(`analysis-${tabId}`).catch(err => console.error('Failed to remove analysis from storage:', err));\n        \n        // Activate upload tab if current was closed\n        if (tab.classList.contains('active')) {\n            switchTab('upload');\n        }\n        saveState();\n        e.stopPropagation();\n    } else if (target.classList.contains('tab')) {\n        const tabId = target.dataset.tab;\n        if (tabId) {\n            switchTab(tabId);\n        }\n    }\n});\n\nfunction switchTab(tabId: string): void {\n    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));\n    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));\n    \n    document.querySelector(`[data-tab=\"${tabId}\"]`)?.classList.add('active');\n    document.querySelector(`[data-content=\"${tabId}\"]`)?.classList.add('active');\n}\n\nanalyzeUploadBtn.addEventListener('click', async () => {\n    const responseFile = responseFileUploadInput.files?.[0];\n    const referenceFile = referenceFileUploadInput.files?.[0];\n\n    if (!responseFile) return;\n\n    analyzeUploadBtn.disabled = true;\n    analyzeUploadBtn.textContent = 'Analyzing...';\n\n    try {\n        const responseData = await audio.loadAudioFile(responseFile);\n        const referenceData = referenceFile ? await audio.loadAudioFile(referenceFile) : null;\n\n        createAnalysisTab(\n            responseData.applyGain(1 / 16384),\n            referenceData ? referenceData.applyGain(1 / 16384) : null,\n            responseFile.name,\n            referenceFile?.name || null\n        );\n    } catch (error) {\n        alert('Error analyzing files: ' + (error as Error).message);\n    } finally {\n        analyzeUploadBtn.disabled = false;\n        analyzeUploadBtn.textContent = 'Analyze Frequency Response';\n    }\n});\n\nanalyzePolarBtn.addEventListener('click', async () => {\n    const referenceFile = polarReferenceFileInput.files?.[0];\n    if (!referenceFile) return;\n\n    const measurements = getPolarMeasurements();\n    if (measurements.length === 0) {\n        alert('Please add at least one measurement (angle + file).');\n        return;\n    }\n\n    const oldText = analyzePolarBtn.textContent || 'Analyze Polar Directivity';\n    analyzePolarBtn.disabled = true;\n    analyzePolarBtn.textContent = 'Analyzing...';\n\n    try {\n        const referenceData = (await audio.loadAudioFile(referenceFile)).applyGain(1 / 16384);\n\n        const loaded = await Promise.all(\n            measurements.map(async (m) => ({\n                angleDeg: m.angleDeg,\n                audio: (await audio.loadAudioFile(m.file)).applyGain(1 / 16384),\n            }))\n        );\n\n        loaded.sort((a, b) => a.angleDeg - b.angleDeg);\n        const responseAudios = loaded.map((x) => x.audio);\n        const anglesDeg = loaded.map((x) => x.angleDeg);\n\n        createDirectivityPlotTab(responseAudios, referenceData, anglesDeg);\n    } catch (error) {\n        alert('Error analyzing polar files: ' + (error as Error).message);\n    } finally {\n        analyzePolarBtn.textContent = oldText;\n        updatePolarAnalyzeEnabled();\n    }\n});\n\nfunction createAnalysisTab(responseData: Audio, referenceData: Audio | null, filename: string, referenceFilename: string | null): void {\n    tabCounter++;\n    const tabId = `analysis-${tabCounter}`;\n    let shortName = filename.length > 20 ? filename.substring(0, 17) + '...' : filename;\n    if (referenceFilename != null) {\n        const shortReferenceName = referenceFilename?.length > 20 ? referenceFilename.substring(0, 17) + '...' : referenceFilename;\n        shortName += ' / ' + shortReferenceName;\n    }\n    // Create tab button\n    const tab = document.createElement('button');\n    tab.className = 'tab tab-closable';\n    tab.dataset.tab = tabId;\n    tab.innerHTML = `<span class=\"tab-icon-analysis\"></span>${shortName} <span class=\"tab-close\"></span>`;\n    tabsInnerContainer.appendChild(tab);\n    \n    // Create tab content\n    const content = document.createElement('div');\n    content.className = 'tab-content';\n    content.dataset.content = tabId;\n    content.innerHTML = `\n    <!-- nav class=\"tab-menu-bar\">\n                <div>\n                    <label for=\"smoothing-${tabId}\">Smoothing</label>\n                    <select id=\"smoothing-${tabId}\" class=\"smoothing-select\" aria-label=\"Smoothing factor\">\n                        <option value=\"0\">None</option>\n                        <option value=\"1/3\">1/3 octave</option>\n                        <option value=\"1/6\" selected>1/6 octave</option>\n                        <option value=\"1/12\">1/12 octave</option>\n                        <option value=\"1/24\">1/24 octave</option>\n                        <option value=\"1/48\">1/48 octave</option>\n                    </select>\n                </div>\n            </nav> <h5 class=\"text-xs italic text-gray-600\">Frequency Response Analysis of ${filename}${referenceFilename ? ' / ' + referenceFilename : ''}</h5 -->\n        <button class=\"sidecar-toggle\" id=\"sidebar-toggle-${tabId}\" title=\"Toggle Sidecar\">Open settings pane</button>\n        <div class=\"flex h-full\">\n            <div class=\"flex-none w-86 border-r border-[#ddd] p-2 relative sidecar\" style=\"transition:50ms linear;\">\n                <div class=\"section\">\n                    <div class=\"title\">Settings</div>\n                    <p><i>There are no settings for this analysis.</i></p>\n                </div>\n                <div class=\"section\">\n                    <div class=\"title\">Plots</div>\n                    <ul class=\"list\" id=\"plot-list-${tabId}\">\n                        <!--li><input type=\"checkbox\" id=\"checkbox-magnitude-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-magnitude-${tabId}\">Magnitude</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-phase-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-phase-${tabId}\">Phase</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-ir-${tabId}\" alt=\"show/hide\" checked><label for=\"checkbox-ir-${tabId}\">Impulse Response</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-ir-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-ir-${tabId}\">Fundamental + Harmonic Distortion</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-distortion-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-distortion-${tabId}\">Distortion</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-distortion-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-distortion-${tabId}\">Sound Pressure Level</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-deconvoluted-ir-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-deconvoluted-ir-${tabId}\">Deconvoluted Impulse Response</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-stimulus-waveform-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-stimulus-waveform-${tabId}\">Stimulus Waveform</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-recorded-waveform-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-recorded-waveform-${tabId}\">Recorded Waveform</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-recorded-noise-floor-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-recorded-noise-floor-${tabId}\">Recorded Noise Floor</label></li>\n                        <li><input type=\"checkbox\" id=\"checkbox-target-curve-${tabId}\" alt=\"show/hide\" disabled><label for=\"checkbox-target-curve-${tabId}\">Target Curve<button class=\"float-right text-xs cursor-pointer\" style=\"color: #bbb; padding-top: 3px\">Set</button></label></li-->\n                    </ul>\n                </div>\n                <div class=\"section\">\n                    <div class=\"title\">Properties</div>\n                    <p><i>There are no properties for this analysis.</i></p>\n                </div>\n                <div id=\"resize-handle\" class=\"resize-handle\"></div>\n            </div>\n            <div class=\"flex-1 main-content\">\n                <div class=\"grid grid-cols-6 gap-[1px] bg-[#ddd] border-b border-[#ddd] plot-outer\">\n                </div>\n            </div>\n        </div>\n       \n        \n    `;\n    tabContents.appendChild(content);\n\n    // Switch to new tab\n    switchTab(tabId);\n\n    // Compute and plot FFTs\n    const responseSamples = responseData.getChannelData(0);\n    \n    const responseFFT = computeFFT(responseSamples);\n    const smoothedResponseFFT = smoothFFT(responseFFT, 1/6, 1/48);\n\n    let referenceSamples = Float32Array.from([]);\n\n    plot(\n        [\n            {x: responseFFT.frequency, y: db(responseFFT.magnitude), name: 'Recorded signal', line: { color: '#0366d666', width: 0.75}},\n            {x: smoothedResponseFFT.frequency, y: db(smoothedResponseFFT.magnitude), name: 'Recorded signal (Smoothed)', line: { color: '#0366d6', width: 1.5 }}\n        ], \n        tabId, \n        'Recorded Spectrum', \n        'Frequency (Hz)', \n        'Amplitude (dBFS)',\n        {type: 'log', range: [Math.log10(20), Math.log10(20000)]}, \n        {range: [-85, 5]},\n        {}, \n        true\n    );\n    plot(\n        [\n            {x: linspace(0, responseSamples.length/48000, responseSamples.length), y: responseSamples, name: 'Recorded signal', line: { color: '#0366d6ff', width: 0.75}}\n        ],\n        tabId, \n        'Recorded Waveform', \n        'Time (s)', \n        'Amplitude',\n        {}, \n        {}, \n        {}, \n        true\n    );\n\n    if (referenceData) {\n        referenceSamples = referenceData.getChannelData(0);\n        const referenceFFT: FFTResult = computeFFT(referenceSamples);\n        const smoothedReferenceFFT = smoothFFT(referenceFFT, 1/6, 1/48);\n        plot(\n            [\n                {x: referenceFFT.frequency, y: db(referenceFFT.magnitude), name: 'Stimulus signal', line: { color: '#0366d666', width: 0.75}},\n                {x: smoothedReferenceFFT.frequency, y: db(smoothedReferenceFFT.magnitude), name: 'Stimulus signal (Smoothed)', line: { color: '#0366d6', width: 1.5 }}\n            ], \n            tabId, \n            'Stimulus Spectrum', \n            'Frequency (Hz)', \n            'Amplitude (dBFS)',\n            {type: 'log', range: [Math.log10(20), Math.log10(20000)]}, \n            {range: [-85, 5]},\n            {}, \n            true\n        );\n        plot(\n            [\n                {x: linspace(0, referenceSamples.length/48000, referenceSamples.length), y: referenceSamples, name: 'Stimulus signal', line: { color: '#0366d6ff', width: 0.75}}\n            ],\n            tabId, \n            'Stimulus Waveform', \n            'Time (s)', \n            'Amplitude',\n            {}, \n            {}, \n            {}, \n            true\n        );\n        const ir: ImpulseResponseResult = twoChannelImpulseResponse(responseSamples, referenceSamples);\n        const farina = new Farina(referenceSamples, 20, 20000, 48000);\n        const farina_ir: ImpulseResponseResult = farina.deconvolvedResponse(responseSamples);\n\n        plotDistortion(farina, 0.1, 5, tabId);\n        plotTHD(farina, 0.1, 5, tabId);\n            \n        console.log('Impulse response peak at', farina.lag_of_harmonic(2));\n\n        plot(\n            [\n                {x: ir.t, y:ir.ir, type: 'scatter', mode: 'lines', name: 'Dual-FFT Impulse Response', line: { color: COLORS[0], width: 0.75}}\n            ],\n            tabId,\n            'Impulse Response',\n            'Time (s)',\n            'Amplitude',\n            {},\n            {},\n            {},\n            false\n        );\n\n        plot(\n            [   \n                {x: [-max(farina_ir.t), max(farina_ir.t)], y: [-200, -200], showlegend: false},\n                {x: farina_ir.t, y:db(farina_ir.ir.map(x => Math.abs(x))), type: 'scatter', mode: 'lines', fill: 'tonexty', name: 'Farina Impulse Response', line: { color: COLORS[0], width: 0.75}, fillcolor: COLORS[0]},\n                {x: [- 0.05, - 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'Fundamental window start', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [0.05, 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'Fundamental window end', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(2) - 0.05, -farina.lag_of_harmonic(2) - 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H2 window start', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(2) + 0.05, -farina.lag_of_harmonic(2) + 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H2 window end', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(3) - 0.05, -farina.lag_of_harmonic(3) - 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H3 window start', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(3) + 0.05, -farina.lag_of_harmonic(3) + 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H3 window end', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(4) - 0.05, -farina.lag_of_harmonic(4) - 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H4 window start', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(4) + 0.05, -farina.lag_of_harmonic(4) + 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H4 window end', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(5) - 0.05, -farina.lag_of_harmonic(5) - 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H5 window start', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(5) + 0.05, -farina.lag_of_harmonic(5) + 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H5 window end', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(6) - 0.05, -farina.lag_of_harmonic(6) - 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H6 window start', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(6) + 0.05, -farina.lag_of_harmonic(6) + 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H6 window end', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(7) - 0.05, -farina.lag_of_harmonic(7) - 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H7 window start', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                {x: [-farina.lag_of_harmonic(7) + 0.05, -farina.lag_of_harmonic(7) + 0.05], y: [-999, 999], type: 'scatter', mode: 'lines', name: 'H7 window end', line: { color: '#00000033', width: 0.75}, hoverinfo: 'skip', showlegend: false},\n                \n            ],\n            tabId,\n            'Deconvolved Response',\n            'Time (s)',\n            'Amplitude',\n            { range: [-1, 1]},\n            { range: [-150, 10]},\n            {},\n            false\n        );\n        const transferFunction = computeFFTFromIR(ir);\n        // const dreferenceFFT = twoChannelFFT(responseData.data, referenceSamples, nextPow2(referenceSamples.length), -5627);\n        const smoothedFreqResponse = smoothFFT(transferFunction, 1/6, 1/48);\n        \n        const gd = groupDelays(transferFunction, 1000);\n\n        plot(\n            [\n                {x: transferFunction.frequency, y: db(transferFunction.magnitude), name: 'Magnitude', line: { color: '#0366d666', width: 0.75}},\n                {x: smoothedFreqResponse.frequency, y: db(smoothedFreqResponse.magnitude), name: 'Magnitude (Smoothed)', line: { color: '#0366d6', width: 1.5 }}\n            ], \n            tabId, \n            'Transfer Function', \n            'Frequency (Hz)', \n            'Amplitude (dBFS)',\n            {type: 'log', range: [Math.log10(20), Math.log10(20000)]}, \n            {range: [-85, 5]},\n            {}, \n            false\n        );\n        \n        plot(\n            [\n                {x: transferFunction.frequency, y: transferFunction.phase, name: 'Phase', line: { color: '#0366d666', width: 0.75}},\n                {x: smoothedFreqResponse.frequency, y: smoothedFreqResponse.phase, name: 'Phase (Smoothed)', line: { color: '#0366d6', width: 1.5 }}\n            ], \n            tabId, \n            'Phase', \n            'Frequency (Hz)', \n            'Amplitude (dBFS)',\n            {type: 'log', range: [Math.log10(20), Math.log10(20000)]}, \n            {range: [-720, 720]}, \n            {}, \n            false\n        );\n        plot(\n            [\n                {x: transferFunction.frequency, y: gd, name: 'Group Delay', line: { color: COLORS[0], width: 1.5, dash: 'dot' }}\n            ], \n            tabId, \n            'Group Delay', \n            'Frequency (Hz)', \n            'Group Delay (ms)',\n            {type: 'log', range: [Math.log10(20), Math.log10(20000)]}, \n            {range: [-20, 20]}, \n            {}, \n            false\n        );\n\n        // --- Colormap / Spectrogram (Plotly heatmap) ---\n        (() => {\n            const sr =\n                (responseData as any).sampleRate ??\n                (referenceData as any)?.sampleRate ??\n                48000;\n\n            const n = responseSamples.length;\n            if (n < 4096) return;\n\n            const windowSize = 2048;\n            const targetFrames = 320;\n            const minHop = 256;\n\n            const rawFrames = Math.max(1, Math.floor((n - windowSize) / minHop) + 1);\n            const hop =\n                rawFrames > targetFrames\n                    ? Math.max(minHop, Math.ceil((n - windowSize) / targetFrames))\n                    : minHop;\n\n            const frames = Math.max(1, Math.floor((n - windowSize) / hop) + 1);\n\n            // Hann window\n            const win = new Float32Array(windowSize);\n            for (let i = 0; i < windowSize; i++) {\n                win[i] = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (windowSize - 1)));\n            }\n\n            // Determine frequency bins from first frame\n            const firstFrame = new Float32Array(windowSize);\n            firstFrame.set(responseSamples.subarray(0, windowSize));\n            for (let i = 0; i < windowSize; i++) firstFrame[i] *= win[i];\n\n            const firstFFT = computeFFT(firstFrame);\n            const freqs = Array.from(firstFFT.frequency);\n            const bins = freqs.length;\n\n            // z[freqIndex][timeIndex]\n            const z: number[][] = Array.from({ length: bins }, () => []);\n\n            const times: number[] = [];\n            for (let frame = 0; frame < frames; frame++) {\n                const start = frame * hop;\n                const slice = responseSamples.subarray(start, start + windowSize);\n\n                const windowed = new Float32Array(windowSize);\n                windowed.set(slice);\n                for (let i = 0; i < windowSize; i++) windowed[i] *= win[i];\n\n                const fft = computeFFT(windowed);\n                const magDb = db(fft.magnitude);\n\n                for (let k = 0; k < bins; k++) {\n                    z[k].push(magDb[k]);\n                }\n\n                // Use center-of-window time for x axis\n                times.push((start + windowSize / 2) / sr);\n            }\n\n            plot(\n                [\n                    {\n                        type: 'heatmap',\n                        x: times,\n                        y: freqs,\n                        z,\n                        colorscale: 'Electric',\n                        zmin: -120,\n                        zmax: 0,\n                        colorbar: { title: 'dBFS' }\n                    } as any\n                ],\n                tabId,\n                'Recorded Spectrogram',\n                'Time (s)',\n                'Frequency (Hz)',\n                {},\n                { type: 'log', range: [Math.log10(20), Math.log10(20000)] },\n                { margin: { l: 60, r: 20, t: 40, b: 50 } },\n                false\n            );\n        })();\n    }\n\n    saveState();\n\n    // Persist analysis using IndexedDB (mirrored to sessionStorage for compatibility)\n    storage.setItem(`${tabId}`, JSON.stringify({\n        filename,\n        referenceFilename,\n        responseSamples: Array.from(responseSamples),\n        referenceSamples: referenceSamples.length > 0 ? Array.from(referenceSamples) : null,\n    })).catch(err => console.error('Failed to persist analysis:', err));\n\n    function initResize(e: MouseEvent): void {\n        e.preventDefault();\n        window.addEventListener('mousemove', resize, false);\n        window.addEventListener('mouseup', stopResize, false);\n        console.log('Init resize');\n        document.body.style.cursor = 'col-resize';\n    }\n\n    function resize(e: MouseEvent): void {\n        const container = content.querySelector<HTMLElement>('.flex')!;\n        const handle = document.getElementById('resize-handle')?.parentElement!;\n        const rect = container.getBoundingClientRect();\n        const newWidth = e.clientX - rect.left;\n        if (newWidth > 150 && newWidth < rect.width - 150) {\n            handle.style.width = `${newWidth}px`;\n        }\n    }\n\n    function stopResize(): void {\n        window.removeEventListener('mousemove', resize, false);\n        window.removeEventListener('mouseup', stopResize, false);\n        window.dispatchEvent(new Event('resize'));\n        document.body.style.cursor = 'default';\n    }       \n\n    document.getElementById('resize-handle')?.addEventListener('mousedown', initResize, false);\n}\n\n\nfunction createDirectivityPlotTab(responseDatas: Audio[], referenceData: Audio, anglesDeg?: number[]): void {\n    if (responseDatas.length === 0 || referenceData.length === 0) return;\n\n    tabCounter++;\n    const directivityTabId = `directivity-${tabCounter}`;\n    const shortName = `Directivity (${responseDatas.length})`;\n\n    const tab = document.createElement('button');\n    tab.className = 'tab tab-closable';\n    tab.dataset.tab = directivityTabId;\n    tab.innerHTML = `<span class=\"tab-icon-analysis\"></span>${shortName} <span class=\"tab-close\"></span>`;\n    tabsInnerContainer.appendChild(tab);\n\n    const content = document.createElement('div');\n    content.className = 'tab-content';\n    content.dataset.content = directivityTabId;\n    content.innerHTML = `\n        <div class=\"flex h-full\">\n        <div class=\"flex-1 main-content\">\n            <div class=\"grid grid-cols-6 gap-[1px] bg-[#ddd] border-b border-[#ddd] plot-outer\"></div>\n        </div>\n        </div>\n    `;\n    tabContents.appendChild(content);\n\n    switchTab(directivityTabId);\n\n    const useCustomAngles = !!anglesDeg && anglesDeg.length === responseDatas.length;\n    const angles = useCustomAngles\n        ? anglesDeg!.map(normalizeAngleDeg)\n        : responseDatas.map((_, i) => (360 * i) / responseDatas.length);\n\n    const referenceSamples = Float32Array.from(referenceData.getChannelData(0));\n\n    const transfers: FFTResult[] = responseDatas.map((resp) => {\n        const len = Math.min(resp.getChannelData(0).length, referenceSamples.length);\n        const ir: ImpulseResponseResult = twoChannelImpulseResponse(\n        resp.getChannelData(0).subarray(0, len),\n        referenceSamples.subarray(0, len)\n        );\n        return smoothFFT(computeFFTFromIR(ir), 1/3, 1/48);\n    });\n\n    const baseFreq = transfers[0]?.frequency;\n    if (!baseFreq || baseFreq.length === 0) return;\n\n    const normHz = 1000;\n    let normIdx = 0;\n    let best = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < baseFreq.length; i++) {\n        const d = Math.abs(baseFreq[i] - normHz);\n        if (d < best) {\n        best = d;\n        normIdx = i;\n        }\n    }\n    transfers.push(transfers[0]); // close the circle\n    angles.push(360); // close the circle\n\n    // z[angleIndex][freqIndex]\n    const z: any = transfers.map((tf) => {\n        const magDb = db(tf.magnitude);\n        const ref = magDb[normIdx] ?? 0;\n        return magDb.map((v) => v - ref);\n    });\n\n    plot(\n        [\n        {\n            type: 'heatmap',\n            x: Array.from(baseFreq),\n            y: angles,\n            z,\n            colorscale: 'Jet',\n            zmin: -50,\n            zmax: 0,\n            colorbar: { title: 'dB (norm @ 1 kHz)' }\n        } as any\n        ],\n        directivityTabId,\n        'Directivity Map',\n        'Frequency (Hz)',\n        'Angle (deg)',\n        { type: 'log', range: [Math.log10(20), Math.log10(20000)] },\n        { range: [0, 360] },\n        { margin: { l: 60, r: 20, t: 40, b: 50 } },\n        false\n    );\n}\n\n// Save and load state from sessionStorage\nfunction saveState(): void {\n    const tabs = Array.from(document.querySelectorAll('.tab[data-tab]')).map(tab => ({\n        id: (tab as HTMLElement).dataset.tab,\n        name: (tab as HTMLElement).textContent?.replace('', '').trim()\n    }));\n    \n    storage.setItem('tabs', JSON.stringify(tabs));\n    console.log('Saved state with tabs:', tabs);\n}\n\nasync function loadState(): Promise<void> {\n    try {\n        const savedTabs = await storage.getItem('tabs');\n        if (!savedTabs) return;\n        const tabs = JSON.parse(savedTabs);\n        console.log('Loading saved tabs:', tabs);\n\n        for (const tab of tabs as { id: string; name: string }[]) {\n            // Call createAnalysisTab for each tab\n            const raw = await storage.getItem(`${tab.id}`);\n            const analysisData = raw ? JSON.parse(raw) : null;\n            console.log('Restoring analysis data for tab', tab.id, analysisData);\n            if (analysisData) {\n                createAnalysisTab(Audio.fromSamples(Float32Array.from(analysisData.responseSamples)), analysisData.referenceSamples ? Audio.fromSamples(Float32Array.from(analysisData.referenceSamples)) : null, analysisData.filename, analysisData.referenceFilename);\n            }\n        }\n        // Tabs will be recreated when user analyzes files again\n    } catch (e) {\n        console.error('Failed to load saved state:', e);\n    }\n}\n\n// Load state on page load\nloadState();"]}