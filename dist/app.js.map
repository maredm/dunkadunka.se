{"version":3,"sources":["/workspaces/dunkadunka.se/dist/app.js","../src/math.ts","../src/fft.ts","../src/fractional_octave_smoothing.ts","../src/audio.ts","../src/storage.ts","../src/device-settings.ts","../src/app.ts"],"names":["console","debug","logspace","start","end","num","logStart","Math","log10","logEnd","logStep","Array","from","length","_","i","pow","linspace","step","closest","arr","curr","diff","abs","index","val","newDiff","average","array","reduce","a","b","re","im","sqrt","mod","n","m","nextPow2","v","p","FFT","size","Error","_csize","table","angle","PI","cos","sin","power","t","_width","_bitrev","j","shift","revShift","_out","_data","_inv","fromComplexArray","complex","storage","res","createComplexArray","toComplexArray","input","completeSpectrum","spectrum","half","transform","out","data","_transform4","realTransform","_realTransform4","inverseTransform","width","len","outOff","bitrev","off","_singleTransform2","_singleTransform4","inv","quarterLen","limit","k","A","B","C","D","Ar","Ai","Br","Bi","Cr","Ci","Dr","Di","MAr","MAi","tableBr","tableBi","MBr","MBi","tableCr","tableCi","MCr","MCi","tableDr","tableDi","MDr","MDi","T0r","T0i","T1r","T1i","T2r","T2i","T3r","T3i","FAr","FAi","FCr","FCi","FBr","FBi","FDr","FDi","evenR","evenI","oddR","oddI","leftR","leftI","rightR","rightI","step2","step3","_singleRealTransform2","_singleRealTransform4","halfLen","hquarterLen","ST0r","ST0i","ST1r","ST1i","ST2r","ST2i","ST3r","ST3i","SFAr","SFAi","SFBr","SFBi","SA","SB","getFractionalOctaveFrequencies","fraction","f_low","f_high","fftSize","num_points","round","frequencies","frequency_resolution","Set","fractionalOctaveSmoothing","frequencyData","frequenciesAll","smoothedData","Float32Array","factor","sum","as","slice","min","window","buffer","rms","db","value","isArray","map","smoothFFT","fftData","resolution","frequency","magnitude","phase","smoothedMagnitude","fractionalFrequencies","smoothed","smoothedPhase","computeFFT","ceil","log2","log","fft","frame","SQRT2","atan2","frequencyResolution","fftConvolve","x","y","mode","lenX","lenY","fullLen","xP","yP","set","ar","ai","br","bi","result","Float64Array","floor","FarinaImpulseResponse","ratio","duration","exp","L","rate","x_inv","measurementResponse","stimulusResponse","norm","max","sums","rmss","ir","ir_complex","peakAt","sampleRate","twoChannelImpulseResponse","N","epsilon","denom","mean","computeFFTFromIR","f_phase_wrap","i_norm","unwraped_phase","unwrapPhase","correction","corrected_unwraped_phase","phases","offset","delta","openIDB","Promise","resolve","reject","req","indexedDB","open","onupgradeneeded","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","onerror","error","setItem","key","tx","store","e","transaction","objectStore","put","oncomplete","onabort","getItem","get","removeItem","delete","clearStorage","clear","sessionStorage","dumpStorage","openCursor","event","cursor","target","continue","INPUT_KEY","OUTPUT_KEY","openDeviceSettings","modal","document","getElementById","style","display","initDeviceSettings","closeDeviceSettings","ensureDeviceAccess","navigator","mediaDevices","getUserMedia","audio","video","refreshAudioDeviceList","devices","inputSel","outputSel","inputId","outputId","note","sinkSupported","enumerateDevices","warn","innerHTML","localStorage","forEach","d","kind","opt","createElement","deviceId","textContent","label","selected","appendChild","HTMLMediaElement","prototype","applyOutputDevice","router","setSinkId","saveDeviceSelections","onchange","addEventListener","outId","root","documentElement","uiColor","setProperty","tabCounter","tabsContainer","tabContents","responseFileInput","referenceFileInput","analyzeBtn","disabled","files","saveState","err","classList","tab","parentElement","tabId","dataset","remove","querySelector","catch","switchTab","stopPropagation","querySelectorAll","c","add","responseFile","referenceFile","responseData","referenceData","loadAudioFile","createAnalysisTab","name","alert","message","file","headerBuffer","ext","mime","metadata","wavInfo","mp3Info","arrayBuffer","audioContext","audioBuffer","getExt","split","pop","toLowerCase","parseWav","buf","dv","DataView","readStr","s","String","fromCharCode","getUint8","info","byteLength","id","getUint32","audioFormat","getUint16","numChannels","byteRate","blockAlign","bitsPerSample","dataChunkSize","parseMp3","sampleRates","bytes","Uint8Array","headerIndex","b1","b2","b3","versionBits","layerBits","bitrateBits","sampleRateBits","channelMode","versions","layers","versionKey","layerKey","bitrateTable","versionStr","layerStr","bitrateKbps","tbKey","channels","version","layer","type","format","Object","assign","AudioContext","webkitAudioContext","decodeAudioData","getChannelData","filename","referenceFilename","shortName","substring","shortReferenceName","className","content","responseFFT","tracesMagnitude","line","color","tracesPhase","tracesIR","irPeakAt","referenceFFT","push","farina_ir","transferFunction","transferFunctionF","smoothedFreqResponse","plotSettings","plotGlPixelRatio","legend","xanchor","yanchor","plot_bgcolor","paper_bgcolor","staticPlot","dragmode","showAxisDragHandles","showAxisRangeEntryBoxes","axisDragOnHover","tightenLats","font","family","layoutMagnitude","title","xaxis","gridcolor","range","tickformat","yaxis","rangemode","Plotly","newPlot","responsive","layoutPhase","automargin","layoutIR","JSON","stringify","tabs","replace","trim","loadState","savedTabs","raw","analysisData","parse"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// src/math.ts\nconsole.debug(\"Math module loaded\");\nfunction logspace(start, end, num) {\n  const logStart = Math.log10(start);\n  const logEnd = Math.log10(end);\n  const logStep = (logEnd - logStart) / (num - 1);\n  return Array.from({ length: num }, (_, i) => Math.pow(10, logStart + i * logStep));\n}\nfunction linspace(start, end, num) {\n  if (num === 1) return [start];\n  const step = (end - start) / (num - 1);\n  return Array.from({ length: num }, (_, i) => start + i * step);\n}\nfunction closest(num, arr) {\n  let curr = arr[0];\n  let diff = Math.abs(num - curr);\n  let index = 0;\n  for (let val = 0; val < arr.length; val++) {\n    const newDiff = Math.abs(num - arr[val]);\n    if (newDiff < diff) {\n      diff = newDiff;\n      curr = arr[val];\n      index = val;\n    }\n  }\n  return index;\n}\nvar average = (array) => array.reduce((a, b) => a + b) / array.length;\nvar abs = (re, im = 0) => Math.sqrt(re * re + im * im);\nvar mod = (n, m) => (n % m + m) % m;\nvar nextPow2 = (v) => {\n  let p = 1;\n  while (p < v) p <<= 1;\n  return p;\n};\n\n// src/fft.ts\nconsole.debug(\"FFT module loaded\");\nvar FFT = class {\n  constructor(size) {\n    this.size = size | 0;\n    if (this.size <= 1 || (this.size & this.size - 1) !== 0)\n      throw new Error(\"FFT size must be a power of two and bigger than 1\");\n    this._csize = size << 1;\n    const table = new Array(this.size * 2);\n    for (let i = 0; i < table.length; i += 2) {\n      const angle = Math.PI * i / this.size;\n      table[i] = Math.cos(angle);\n      table[i + 1] = -Math.sin(angle);\n    }\n    this.table = table;\n    let power = 0;\n    for (let t = 1; this.size > t; t <<= 1)\n      power++;\n    this._width = power % 2 === 0 ? power - 1 : power;\n    this._bitrev = new Array(1 << this._width);\n    for (let j = 0; j < this._bitrev.length; j++) {\n      this._bitrev[j] = 0;\n      for (let shift = 0; shift < this._width; shift += 2) {\n        const revShift = this._width - shift - 2;\n        this._bitrev[j] |= (j >>> shift & 3) << revShift;\n      }\n    }\n    this._out = null;\n    this._data = null;\n    this._inv = 0;\n  }\n  fromComplexArray(complex, storage2) {\n    const res = storage2 || new Array(complex.length >>> 1);\n    for (let i = 0; i < complex.length; i += 2)\n      res[i >>> 1] = complex[i];\n    return res;\n  }\n  createComplexArray() {\n    const res = new Array(this._csize);\n    for (let i = 0; i < res.length; i++)\n      res[i] = 0;\n    return res;\n  }\n  toComplexArray(input, storage2) {\n    const res = storage2 || this.createComplexArray();\n    for (let i = 0; i < res.length; i += 2) {\n      res[i] = input[i >>> 1];\n      res[i + 1] = 0;\n    }\n    return res;\n  }\n  completeSpectrum(spectrum) {\n    const size = this._csize;\n    const half = size >>> 1;\n    for (let i = 2; i < half; i += 2) {\n      spectrum[size - i] = spectrum[i];\n      spectrum[size - i + 1] = -spectrum[i + 1];\n    }\n  }\n  transform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 0;\n    this._transform4();\n    this._out = null;\n    this._data = null;\n  }\n  realTransform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 0;\n    this._realTransform4();\n    this._out = null;\n    this._data = null;\n  }\n  inverseTransform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 1;\n    this._transform4();\n    for (let i = 0; i < out.length; i++)\n      out[i] /= this.size;\n    this._out = null;\n    this._data = null;\n  }\n  // radix-4 implementation\n  //\n  // NOTE: Uses of `var` are intentional for older V8 version that do not\n  // support both `let compound assignments` and `const phi`\n  _transform4() {\n    const out = this._out;\n    const size = this._csize;\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    let outOff;\n    let t;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform2(outOff, off, step);\n      }\n    } else {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform4(outOff, off, step);\n      }\n    }\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      const quarterLen = len >>> 2;\n      for (outOff = 0; outOff < size; outOff += len) {\n        const limit = outOff + quarterLen;\n        for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n          const A = i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n          const MAr = Ar;\n          const MAi = Ai;\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n          const FCr = T0r - T2r;\n          const FCi = T0i - T2i;\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n          const FDr = T1r - T3i;\n          const FDi = T1i + T3r;\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          out[D] = FDr;\n          out[D + 1] = FDi;\n        }\n      }\n    }\n  }\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  _singleTransform2(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const evenR = data[off];\n    const evenI = data[off + 1];\n    const oddR = data[off + step];\n    const oddI = data[off + step + 1];\n    const leftR = evenR + oddR;\n    const leftI = evenI + oddI;\n    const rightR = evenR - oddR;\n    const rightI = evenI - oddI;\n    out[outOff] = leftR;\n    out[outOff + 1] = leftI;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = rightI;\n  }\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  _singleTransform4(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n    const Ar = data[off];\n    const Ai = data[off + 1];\n    const Br = data[off + step];\n    const Bi = data[off + step + 1];\n    const Cr = data[off + step2];\n    const Ci = data[off + step2 + 1];\n    const Dr = data[off + step3];\n    const Di = data[off + step3 + 1];\n    const T0r = Ar + Cr;\n    const T0i = Ai + Ci;\n    const T1r = Ar - Cr;\n    const T1i = Ai - Ci;\n    const T2r = Br + Dr;\n    const T2i = Bi + Di;\n    const T3r = inv * (Br - Dr);\n    const T3i = inv * (Bi - Di);\n    const FAr = T0r + T2r;\n    const FAi = T0i + T2i;\n    const FBr = T1r + T3i;\n    const FBi = T1i - T3r;\n    const FCr = T0r - T2r;\n    const FCi = T0i - T2i;\n    const FDr = T1r - T3i;\n    const FDi = T1i + T3r;\n    out[outOff] = FAr;\n    out[outOff + 1] = FAi;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = FCi;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n  // Real input radix-4 implementation\n  _realTransform4() {\n    const out = this._out;\n    const size = this._csize;\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    let outOff;\n    let t;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n      }\n    } else {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n      }\n    }\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      const halfLen = len >>> 1;\n      const quarterLen = halfLen >>> 1;\n      const hquarterLen = quarterLen >>> 1;\n      for (outOff = 0; outOff < size; outOff += len) {\n        for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n          const A = outOff + i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n          const MAr = Ar;\n          const MAi = Ai;\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          if (i === 0) {\n            const FCr = T0r - T2r;\n            const FCi = T0i - T2i;\n            out[C] = FCr;\n            out[C + 1] = FCi;\n            continue;\n          }\n          if (i === hquarterLen)\n            continue;\n          const ST0r = T1r;\n          const ST0i = -T1i;\n          const ST1r = T0r;\n          const ST1i = -T0i;\n          const ST2r = -inv * T3i;\n          const ST2i = -inv * T3r;\n          const ST3r = -inv * T2i;\n          const ST3i = -inv * T2r;\n          const SFAr = ST0r + ST2r;\n          const SFAi = ST0i + ST2i;\n          const SFBr = ST1r + ST3i;\n          const SFBi = ST1i - ST3r;\n          const SA = outOff + quarterLen - i;\n          const SB = outOff + halfLen - i;\n          out[SA] = SFAr;\n          out[SA + 1] = SFAi;\n          out[SB] = SFBr;\n          out[SB + 1] = SFBi;\n        }\n      }\n    }\n  }\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  _singleRealTransform2(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const evenR = data[off];\n    const oddR = data[off + step];\n    const leftR = evenR + oddR;\n    const rightR = evenR - oddR;\n    out[outOff] = leftR;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = 0;\n  }\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  _singleRealTransform4(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n    const Ar = data[off];\n    const Br = data[off + step];\n    const Cr = data[off + step2];\n    const Dr = data[off + step3];\n    const T0r = Ar + Cr;\n    const T1r = Ar - Cr;\n    const T2r = Br + Dr;\n    const T3r = inv * (Br - Dr);\n    const FAr = T0r + T2r;\n    const FBr = T1r;\n    const FBi = -T3r;\n    const FCr = T0r - T2r;\n    const FDr = T1r;\n    const FDi = T3r;\n    out[outOff] = FAr;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = 0;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n};\n\n// src/fractional_octave_smoothing.ts\nconsole.debug(\"Fractional Octave Smoothing module loaded\");\nfunction getFractionalOctaveFrequencies(fraction, f_low = 20, f_high = 24e3, fftSize) {\n  if (fraction <= 0) {\n    throw new Error(\"Fraction must be greater than 0\");\n  }\n  if (f_low <= 0 || f_high <= 0) {\n    throw new Error(\"Frequencies must be greater than 0\");\n  }\n  if (f_low >= f_high) {\n    throw new Error(\"f_low must be less than f_high\");\n  }\n  const num_points = Math.round((Math.log10(f_high) - Math.log10(f_low)) / fraction) + 1;\n  let frequencies = logspace(f_low, f_high, num_points);\n  const frequency_resolution = 48e3 / fftSize;\n  for (let i = 0; i < frequencies.length; i++) {\n    frequencies[i] = Math.round(frequencies[i] / frequency_resolution) * frequency_resolution;\n  }\n  frequencies = Array.from(new Set(frequencies));\n  return frequencies;\n}\nfunction fractionalOctaveSmoothing(frequencyData, fraction, frequencies) {\n  const frequenciesAll = linspace(0, 48e3 / 2, frequencyData.length);\n  const frequency_resolution = 48e3 / frequencyData.length;\n  const smoothedData = new Float32Array(frequencies.length);\n  const n = frequencyData.length;\n  const factor = Math.pow(2, 0.5 * fraction) - Math.pow(0.5, 0.5 * fraction);\n  for (let p = 0; p < frequencies.length; p++) {\n    const i = closest(frequencies[p], frequenciesAll);\n    let sum2 = 0;\n    const width = Math.round(0.5 * factor * (n * 0.5 - Math.abs(n * 0.5 - i)));\n    if (width === 0) {\n      sum2 = frequencyData[i];\n    } else {\n      const as = frequencyData.slice(Math.round(i - width + 1), Math.min(Math.round(i + width), n - 1));\n      sum2 = average(as);\n    }\n    smoothedData[p] = sum2;\n  }\n  return smoothedData;\n}\n\n// src/audio.ts\nconsole.debug(\"Audio module loaded\");\nwindow.FFT = FFT;\nfunction sum(buffer) {\n  let sum2 = 0;\n  for (let i = 0; i < buffer.length; i++) {\n    sum2 += buffer[i] * buffer[i];\n  }\n  return sum2;\n}\nfunction rms(buffer) {\n  return Math.sqrt(sum(buffer) / buffer.length);\n}\nfunction db(value) {\n  if (Array.isArray(value)) {\n    return value.map((v) => 20 * Math.log10(v + 1e-50));\n  } else {\n    return 20 * Math.log10(value + 1e-50);\n  }\n}\nfunction smoothFFT(fftData, fraction, resolution) {\n  const { frequency, magnitude, phase, fftSize } = fftData;\n  const smoothedMagnitude = new Float32Array(magnitude.length);\n  const fractionalFrequencies = getFractionalOctaveFrequencies(resolution, 20, 24e3, fftSize);\n  const smoothed = fractionalOctaveSmoothing(db(magnitude), fraction, fractionalFrequencies);\n  const smoothedPhase = fractionalOctaveSmoothing(phase, fraction, fractionalFrequencies);\n  return {\n    frequency: fractionalFrequencies,\n    magnitude: Array.from(smoothed),\n    phase: Array.from(smoothedPhase),\n    fftSize\n  };\n}\nfunction computeFFT(data, fftSize = null) {\n  fftSize ?? (fftSize = 2 ** Math.ceil(Math.log2(data.length)));\n  console.log(`Computing FFT with ${fftSize} bins for data length ${data.length}`);\n  const fft = new FFT(fftSize);\n  const out = fft.createComplexArray();\n  const frame = new Float32Array(fftSize);\n  for (let i = 0; i < fftSize; i++) {\n    frame[i] = (data[i] || 0) * 1;\n  }\n  fft.realTransform(out, frame);\n  const frequency = [];\n  const magnitude = [];\n  const phase = [];\n  for (let i = 0; i < fftSize / 2; i++) {\n    const re = out[2 * i];\n    const im = out[2 * i + 1];\n    magnitude[i] = abs(re, im) * Math.SQRT2;\n    phase[i] = Math.atan2(im, re);\n  }\n  const frequencyResolution = 48e3 / fftSize;\n  for (let i = 0; i < fftSize / 2; i++) {\n    frequency[i] = i * frequencyResolution;\n  }\n  return {\n    frequency,\n    magnitude,\n    phase,\n    fftSize\n  };\n}\nfunction fftConvolve(x, y, mode = \"same\") {\n  const lenX = x.length;\n  const lenY = y.length;\n  const fullLen = lenX + lenY - 1;\n  const n = nextPow2(fullLen);\n  const xP = new Float32Array(n);\n  const yP = new Float32Array(n);\n  xP.set(x, 0);\n  yP.set(y, 0);\n  const fft = new FFT(n);\n  const A = fft.createComplexArray();\n  const B = fft.createComplexArray();\n  fft.realTransform(A, xP);\n  fft.realTransform(B, yP);\n  if (typeof fft.completeSpectrum === \"function\") {\n    fft.completeSpectrum(A);\n    fft.completeSpectrum(B);\n  }\n  const C = fft.createComplexArray();\n  for (let k = 0; k < n; k++) {\n    const ar = A[2 * k], ai = A[2 * k + 1];\n    const br = B[2 * k], bi = B[2 * k + 1];\n    C[2 * k] = ar * br - ai * bi;\n    C[2 * k + 1] = ai * br + ar * bi;\n  }\n  const out = fft.createComplexArray();\n  fft.inverseTransform(out, C);\n  const result = new Float64Array(fullLen);\n  for (let i = 0; i < fullLen; i++) {\n    result[i] = out[2 * i];\n  }\n  if (mode === \"same\") {\n    const start = Math.floor((fullLen - lenX) / 2);\n    return Array.from(result).slice(start, start + lenX);\n  }\n  return Array.from(result);\n}\nfunction FarinaImpulseResponse(y, x) {\n  const n = linspace(0, x.length - 1, x.length);\n  const ratio = Math.log(22800 / 50);\n  const duration = x.length / 48e3;\n  const k = n.map((v) => Math.exp(v * ratio / x.length));\n  const L = duration / ratio;\n  const rate = Math.log(10) * L;\n  const x_inv = new Float32Array(x.length);\n  for (let i = 0; i < x.length; i++) {\n    x_inv[i] = x[x.length - 1 - i] / k[i];\n  }\n  const measurementResponse = fftConvolve(y, x_inv, \"same\");\n  const stimulusResponse = fftConvolve(x, x_inv, \"same\");\n  const norm = Array.from(stimulusResponse).reduce((a, b) => Math.max(a, Math.abs(b)), 0);\n  let sums = 0;\n  for (let i = 0; i < stimulusResponse.length; i++) {\n    sums += stimulusResponse[i];\n  }\n  const rmss = sum(x_inv) * 2 * y.length / x_inv.length;\n  const ir = Array.from(new Float32Array(measurementResponse.length));\n  for (let i = 0; i < measurementResponse.length; i++) {\n    ir[i] = measurementResponse[i] / norm;\n  }\n  const ir_complex = Array.from(new Float32Array(measurementResponse.length * 2));\n  for (let i = 0; i < measurementResponse.length; i++) {\n    ir_complex[2 * i] = measurementResponse[i] / norm;\n    ir_complex[2 * i + 1] = 0;\n  }\n  const peakAt = closest(1e8, ir) + -measurementResponse.length / 2;\n  return {\n    ir,\n    ir_complex,\n    t: Array.from(linspace((-measurementResponse.length - 1) / 2 / 48e3, (measurementResponse.length - 1) / 2 / 48e3, measurementResponse.length)),\n    // assuming 48kHz\n    peakAt,\n    sampleRate: 48e3,\n    fftSize: measurementResponse.length\n  };\n}\nfunction twoChannelImpulseResponse(y, x) {\n  const fullLen = y.length + x.length - 1;\n  const N = nextPow2(fullLen);\n  const xP = new Float32Array(N);\n  const yP = new Float32Array(N);\n  xP.set(y, 0);\n  yP.set(x, 0);\n  const fft = new FFT(N);\n  const A = fft.createComplexArray();\n  const B = fft.createComplexArray();\n  fft.realTransform(A, xP);\n  fft.realTransform(B, yP);\n  const C = fft.createComplexArray();\n  const epsilon = 1e-20;\n  for (let k = 0; k < N; k++) {\n    const ar = A[2 * k], ai = A[2 * k + 1];\n    const br = B[2 * k], bi = B[2 * k + 1];\n    const denom = br * br + bi * bi + epsilon;\n    C[2 * k] = (ar * br + ai * bi) / denom;\n    C[2 * k + 1] = (ai * br - ar * bi) / denom;\n  }\n  const out = fft.createComplexArray();\n  fft.inverseTransform(out, C);\n  const ir = Array.from(new Float32Array(N));\n  for (let i = 0; i < N; i++) {\n    ir[i] = out[2 * ((i + N / 2) % N)];\n  }\n  const peakAt = closest(1e8, ir) + -N / 2;\n  const ir_complex = out.slice();\n  for (let i = 0; i < N; i++) {\n    ir_complex[2 * i] = out[2 * mod(i + peakAt, N)];\n    ir_complex[2 * i + 1] = out[2 * mod(i + peakAt, N) + 1];\n  }\n  const mean = average(ir);\n  for (let i = 0; i < N; i++) {\n    ir[i] = ir[i] - mean;\n  }\n  return {\n    ir,\n    ir_complex,\n    t: Array.from(linspace((-N - 1) / 2 / 48e3, (N - 1) / 2 / 48e3, N)),\n    // assuming 48kHz\n    peakAt,\n    sampleRate: 48e3,\n    fftSize: N\n  };\n}\nfunction computeFFTFromIR(ir, f_phase_wrap = 50) {\n  const magnitude = [];\n  const phase = [];\n  const N = nextPow2(ir.ir.length);\n  console.log(`Computing FFT from IR with size ${N}`);\n  const fft = new FFT(N);\n  const out = fft.createComplexArray();\n  if (ir.ir_complex[1] === 0) {\n    console.log(\"IR is in real format, converting to complex\");\n    const frame = new Float32Array(N);\n    for (let i = 0; i < N; i++) {\n      frame[i] = (ir.ir_complex[2 * i] || 0) * 1;\n    }\n    fft.realTransform(out, frame);\n  } else {\n    fft.transform(out, ir.ir_complex);\n  }\n  console.log(ir.ir_complex);\n  for (let i = 0; i < N / 2; i++) {\n    const re = out[2 * i];\n    const im = out[2 * i + 1];\n    magnitude[i] = abs(re, im);\n    phase[i] = Math.atan2(im, re);\n  }\n  const frequency = linspace(0, 48e3 / 2, magnitude.length);\n  const i_norm = closest(f_phase_wrap, frequency);\n  const unwraped_phase = unwrapPhase(phase);\n  const correction = Math.floor(unwraped_phase[i_norm] / (2 * Math.PI) + 0.5) * (2 * Math.PI);\n  const corrected_unwraped_phase = unwraped_phase.map((v) => v - correction);\n  function unwrapPhase(phases) {\n    const N2 = phases.length;\n    const out2 = Array.from(new Float32Array(N2));\n    if (N2 === 0) return out2;\n    out2[0] = phases[0];\n    let offset = 0;\n    for (let i = 1; i < N2; i++) {\n      let delta = phases[i] - phases[i - 1];\n      if (delta > Math.PI) {\n        offset -= 2 * Math.PI;\n      } else if (delta < -Math.PI) {\n        offset += 2 * Math.PI;\n      }\n      out2[i] = phases[i] + offset;\n    }\n    return out2;\n  }\n  return {\n    frequency,\n    magnitude,\n    phase: corrected_unwraped_phase.map((v) => v / Math.PI * 180),\n    fftSize: N\n  };\n}\n\n// src/storage.ts\nfunction openIDB() {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.open(\"dunkadunka-storage\", 1);\n    req.onupgradeneeded = () => {\n      const db2 = req.result;\n      if (!db2.objectStoreNames.contains(\"kv\")) {\n        db2.createObjectStore(\"kv\", { keyPath: \"key\" });\n      }\n    };\n    req.onsuccess = () => resolve(req.result);\n    req.onerror = () => reject(req.error);\n  });\n}\nasync function setItem(key, value) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.put({ key, value });\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n    try {\n      setItem(key, value);\n    } catch {\n    }\n  } catch (e) {\n    console.error(\"setItem(idb) failed\", e);\n  }\n}\nasync function getItem(key) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readonly\");\n    const store = tx.objectStore(\"kv\");\n    const req = store.get(key);\n    const res = await new Promise((resolve, reject) => {\n      req.onsuccess = () => resolve(req.result);\n      req.onerror = () => reject(req.error);\n    });\n    return res?.value ?? null;\n  } catch (e) {\n    console.error(\"getItem(idb) failed\", e);\n    return null;\n  }\n}\nasync function removeItem(key) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.delete(key);\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n  } catch (e) {\n    console.error(\"removeItem(idb) failed\", e);\n  }\n}\nasync function clearStorage() {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.clear();\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n    try {\n      sessionStorage.clear();\n    } catch {\n    }\n  } catch (e) {\n    console.error(\"clearStorage(idb) failed\", e);\n  }\n}\nasync function dumpStorage() {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readonly\");\n    const store = tx.objectStore(\"kv\");\n    const req = store.openCursor();\n    req.onsuccess = (event) => {\n      const cursor = event.target.result;\n      if (cursor) {\n        console.log(`Key: ${cursor.key}, Value: ${cursor.value.value}`);\n        cursor.continue();\n      }\n    };\n    req.onerror = () => {\n      console.error(\"dumpStorage(idb) failed\", req.error);\n    };\n  } catch (e) {\n    console.error(\"dumpStorage(idb) failed\", e);\n  }\n}\nvar storage = {\n  setItem,\n  getItem,\n  removeItem,\n  clearStorage,\n  dumpStorage\n};\n\n// src/device-settings.ts\nvar INPUT_KEY = \"preferredAudioInputId\";\nvar OUTPUT_KEY = \"preferredAudioOutputId\";\nfunction openDeviceSettings() {\n  const modal = document.getElementById(\"deviceSettingsModal\");\n  if (modal) {\n    modal.style.display = \"flex\";\n    initDeviceSettings();\n  }\n}\nfunction closeDeviceSettings() {\n  const modal = document.getElementById(\"deviceSettingsModal\");\n  if (modal) {\n    modal.style.display = \"none\";\n  }\n}\nasync function ensureDeviceAccess() {\n  try {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;\n    await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n  } catch (_) {\n  }\n}\nasync function refreshAudioDeviceList() {\n  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n    console.warn(\"MediaDevices API not available\");\n    return;\n  }\n  await ensureDeviceAccess();\n  const devices = await navigator.mediaDevices.enumerateDevices();\n  const inputSel = document.getElementById(\"inputDeviceSelect\");\n  const outputSel = document.getElementById(\"outputDeviceSelect\");\n  if (!inputSel || !outputSel) return;\n  inputSel.innerHTML = '<option value=\"\">Default input</option>';\n  outputSel.innerHTML = '<option value=\"\">Default output</option>';\n  const inputId = localStorage.getItem(INPUT_KEY) || \"\";\n  const outputId = localStorage.getItem(OUTPUT_KEY) || \"\";\n  devices.forEach((d) => {\n    if (d.kind === \"audioinput\") {\n      const opt = document.createElement(\"option\");\n      opt.value = d.deviceId;\n      opt.textContent = d.label || `Microphone (${d.deviceId.slice(0, 8)}\\u2026)`;\n      if (d.deviceId === inputId) opt.selected = true;\n      inputSel.appendChild(opt);\n    } else if (d.kind === \"audiooutput\") {\n      const opt = document.createElement(\"option\");\n      opt.value = d.deviceId;\n      opt.textContent = d.label || `Speaker (${d.deviceId.slice(0, 8)}\\u2026)`;\n      if (d.deviceId === outputId) opt.selected = true;\n      outputSel.appendChild(opt);\n    }\n  });\n  const note = document.getElementById(\"sinkSupportNote\");\n  if (note) {\n    const sinkSupported = typeof HTMLMediaElement !== \"undefined\" && \"setSinkId\" in HTMLMediaElement.prototype;\n    note.textContent = sinkSupported ? \"Output routing supported on this browser.\" : \"Output routing (setSinkId) not supported by this browser.\";\n  }\n}\nasync function applyOutputDevice(deviceId) {\n  const router = document.getElementById(\"appOutputRouter\");\n  if (!router) return;\n  if (\"setSinkId\" in HTMLMediaElement.prototype) {\n    try {\n      await router.setSinkId(deviceId || \"\");\n    } catch (e) {\n      console.warn(\"Failed to set sinkId:\", e);\n    }\n  }\n}\nfunction saveDeviceSelections() {\n  const inputSel = document.getElementById(\"inputDeviceSelect\");\n  const outputSel = document.getElementById(\"outputDeviceSelect\");\n  if (!inputSel || !outputSel) return;\n  localStorage.setItem(INPUT_KEY, inputSel.value || \"\");\n  localStorage.setItem(OUTPUT_KEY, outputSel.value || \"\");\n  applyOutputDevice(outputSel.value || \"\");\n  closeDeviceSettings();\n}\nasync function initDeviceSettings() {\n  await refreshAudioDeviceList();\n  const inputSel = document.getElementById(\"inputDeviceSelect\");\n  const outputSel = document.getElementById(\"outputDeviceSelect\");\n  if (!inputSel || !outputSel) return;\n  inputSel.onchange = () => {\n    localStorage.setItem(INPUT_KEY, inputSel.value || \"\");\n  };\n  outputSel.onchange = () => {\n    localStorage.setItem(OUTPUT_KEY, outputSel.value || \"\");\n    applyOutputDevice(outputSel.value || \"\");\n  };\n}\nif (navigator.mediaDevices && \"ondevicechange\" in navigator.mediaDevices) {\n  navigator.mediaDevices.addEventListener(\"devicechange\", () => {\n    const modal = document.getElementById(\"deviceSettingsModal\");\n    if (modal && modal.style.display === \"flex\") {\n      refreshAudioDeviceList();\n    }\n  });\n}\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const outId = localStorage.getItem(OUTPUT_KEY);\n  if (outId) applyOutputDevice(outId);\n});\nwindow.openDeviceSettings = openDeviceSettings;\nwindow.closeDeviceSettings = closeDeviceSettings;\nwindow.refreshAudioDeviceList = refreshAudioDeviceList;\nwindow.saveDeviceSelections = saveDeviceSelections;\n\n// src/app.ts\nconsole.debug(\"App module loaded\");\nvar root = document.documentElement;\nvar uiColor = \"#0366d6\";\nroot.style.setProperty(\"--color\", uiColor);\nvar tabCounter = 0;\nvar tabsContainer = document.getElementById(\"tabs\");\nvar tabContents = document.getElementById(\"tab-contents\");\nvar responseFileInput = document.getElementById(\"responseFile\");\nvar referenceFileInput = document.getElementById(\"referenceFile\");\nvar analyzeBtn = document.getElementById(\"analyzeBtn\");\nresponseFileInput.addEventListener(\"change\", () => {\n  analyzeBtn.disabled = !responseFileInput.files?.length;\n});\nwindow.addEventListener(\"beforeunload\", (e) => {\n  try {\n    saveState();\n  } catch (err) {\n    console.error(\"Failed to save state on beforeunload:\", err);\n  }\n});\ntabsContainer.addEventListener(\"click\", (e) => {\n  const target = e.target;\n  if (target.classList.contains(\"tab-close\")) {\n    const tab = target.parentElement;\n    const tabId = tab.dataset.tab;\n    if (tabId == \"upload\") return;\n    console.debug(\"Closing tab\", tabId);\n    tab.remove();\n    document.querySelector(`[data-content=\"${tabId}\"]`)?.remove();\n    storage.removeItem(`analysis-${tabId}`).catch((err) => console.error(\"Failed to remove analysis from storage:\", err));\n    if (tab.classList.contains(\"active\")) {\n      switchTab(\"upload\");\n    }\n    saveState();\n    e.stopPropagation();\n  } else if (target.classList.contains(\"tab\")) {\n    const tabId = target.dataset.tab;\n    if (tabId) {\n      switchTab(tabId);\n    }\n  }\n});\nfunction switchTab(tabId) {\n  document.querySelectorAll(\".tab\").forEach((t) => t.classList.remove(\"active\"));\n  document.querySelectorAll(\".tab-content\").forEach((c) => c.classList.remove(\"active\"));\n  document.querySelector(`[data-tab=\"${tabId}\"]`)?.classList.add(\"active\");\n  document.querySelector(`[data-content=\"${tabId}\"]`)?.classList.add(\"active\");\n}\nanalyzeBtn.addEventListener(\"click\", async () => {\n  const responseFile = responseFileInput.files?.[0];\n  const referenceFile = referenceFileInput.files?.[0];\n  if (!responseFile) return;\n  analyzeBtn.disabled = true;\n  analyzeBtn.textContent = \"Analyzing...\";\n  try {\n    const responseData = await loadAudioFile(responseFile);\n    const referenceData = referenceFile ? await loadAudioFile(referenceFile) : null;\n    createAnalysisTab(responseData, referenceData, responseFile.name, referenceFile?.name || null);\n  } catch (error) {\n    alert(\"Error analyzing files: \" + error.message);\n  } finally {\n    analyzeBtn.disabled = false;\n    analyzeBtn.textContent = \"Analyze Frequency Response\";\n  }\n});\nasync function loadAudioFile(file) {\n  const headerBuffer = await file.slice(0, 256 * 1024).arrayBuffer();\n  function getExt(name) {\n    return (name.split(\".\").pop() || \"\").toLowerCase();\n  }\n  function parseWav(buf) {\n    const dv = new DataView(buf);\n    function readStr(off, len) {\n      let s = \"\";\n      for (let i = 0; i < len; i++) s += String.fromCharCode(dv.getUint8(off + i));\n      return s;\n    }\n    if (readStr(0, 4) !== \"RIFF\" || readStr(8, 4) !== \"WAVE\") return null;\n    let offset = 12;\n    const info = {};\n    while (offset + 8 <= dv.byteLength) {\n      const id = readStr(offset, 4);\n      const size = dv.getUint32(offset + 4, true);\n      if (id === \"fmt \") {\n        info.audioFormat = dv.getUint16(offset + 8, true);\n        info.numChannels = dv.getUint16(offset + 10, true);\n        info.sampleRate = dv.getUint32(offset + 12, true);\n        info.byteRate = dv.getUint32(offset + 16, true);\n        info.blockAlign = dv.getUint16(offset + 20, true);\n        info.bitsPerSample = dv.getUint16(offset + 22, true);\n      } else if (id === \"data\") {\n        info.dataChunkSize = size;\n      }\n      offset += 8 + size + size % 2;\n    }\n    if (info.sampleRate && info.byteRate && info.dataChunkSize) {\n      info.duration = info.dataChunkSize / info.byteRate;\n    }\n    return info;\n  }\n  function parseMp3(buf) {\n    const bytes = new Uint8Array(buf);\n    let offset = 0;\n    if (bytes[0] === 73 && bytes[1] === 68 && bytes[2] === 51) {\n      const size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n      offset = 10 + size;\n    }\n    let headerIndex = -1;\n    for (let i = offset; i < bytes.length - 4; i++) {\n      if (bytes[i] === 255 && (bytes[i + 1] & 224) === 224) {\n        headerIndex = i;\n        break;\n      }\n    }\n    if (headerIndex < 0) return null;\n    const b1 = bytes[headerIndex + 1];\n    const b2 = bytes[headerIndex + 2];\n    const b3 = bytes[headerIndex + 3];\n    const versionBits = b1 >> 3 & 3;\n    const layerBits = b1 >> 1 & 3;\n    const bitrateBits = b2 >> 4 & 15;\n    const sampleRateBits = b2 >> 2 & 3;\n    const channelMode = b3 >> 6 & 3;\n    const versions = {\n      0: \"MPEG Version 2.5\",\n      1: \"reserved\",\n      2: \"MPEG Version 2 (ISO/IEC 13818-3)\",\n      3: \"MPEG Version 1 (ISO/IEC 11172-3)\"\n    };\n    const layers = {\n      0: \"reserved\",\n      1: \"Layer III\",\n      2: \"Layer II\",\n      3: \"Layer I\"\n    };\n    const sampleRates = {\n      3: [44100, 48e3, 32e3],\n      2: [22050, 24e3, 16e3],\n      0: [11025, 12e3, 8e3]\n    };\n    const versionKey = versionBits;\n    const layerKey = layerBits;\n    const bitrateTable = {\n      // MPEG1 Layer III\n      \"3_1\": [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 0],\n      // MPEG2/2.5 Layer III\n      \"0_1\": [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0],\n      \"2_1\": [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0],\n      // fallback generic table for other layers/versions (best-effort)\n      \"3_2\": [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 0],\n      \"3_3\": [0, 32, 64, 96, 128, 160, 192, 224, 256, 320, 384, 448, 512, 576, 640, 0]\n    };\n    const versionStr = versions[versionKey] || \"unknown\";\n    const layerStr = layers[layerKey] || \"unknown\";\n    let sampleRate = sampleRates[versionKey]?.[sampleRateBits] || null;\n    let bitrateKbps = 0;\n    const tbKey = `${versionKey}_${layerKey}`;\n    if (bitrateTable[tbKey]) {\n      bitrateKbps = bitrateTable[tbKey][bitrateBits] || 0;\n    } else if (bitrateTable[\"3_1\"] && versionKey === 3 && layerKey === 1) {\n      bitrateKbps = bitrateTable[\"3_1\"][bitrateBits] || 0;\n    }\n    const channels = channelMode === 3 ? 1 : 2;\n    let duration = null;\n    if (bitrateKbps > 0) {\n      duration = bytes.length * 8 / (bitrateKbps * 1e3);\n    }\n    return {\n      version: versionStr,\n      layer: layerStr,\n      bitrateKbps: bitrateKbps || null,\n      sampleRate,\n      channels,\n      duration\n    };\n  }\n  const ext = getExt(file.name);\n  const mime = file.type || \"unknown\";\n  let metadata = {};\n  const wavInfo = parseWav(headerBuffer);\n  if (wavInfo) {\n    metadata.format = \"wav\";\n    metadata = Object.assign(metadata, wavInfo || {});\n  } else if (mime === \"audio/mpeg\" || ext === \"mp3\") {\n    const mp3Info = parseMp3(headerBuffer);\n    metadata.format = \"mp3\";\n    metadata = Object.assign(metadata, mp3Info || {});\n  } else {\n    metadata.format = mime || ext || \"unknown\";\n  }\n  console.log(\"Extracted file metadata:\", metadata);\n  const arrayBuffer = await file.arrayBuffer();\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n  console.log(\"Metadata:\", metadata);\n  console.log(\"Loaded audio file with RMS of\", db(rms(Array.from(audioBuffer.getChannelData(0)))));\n  return {\n    sampleRate: audioBuffer.sampleRate,\n    data: Array.from(audioBuffer.getChannelData(0)).map((x) => x / 16384),\n    // normalize 16-bit PCM\n    duration: audioBuffer.duration,\n    metadata\n  };\n}\nfunction createAnalysisTab(responseData, referenceData, filename, referenceFilename) {\n  tabCounter++;\n  const tabId = `analysis-${tabCounter}`;\n  let shortName = filename.length > 20 ? filename.substring(0, 17) + \"...\" : filename;\n  if (referenceFilename != null) {\n    const shortReferenceName = referenceFilename?.length > 20 ? referenceFilename.substring(0, 17) + \"...\" : referenceFilename;\n    shortName += \" / \" + shortReferenceName;\n  }\n  const tab = document.createElement(\"button\");\n  tab.className = \"tab tab-closable\";\n  tab.dataset.tab = tabId;\n  tab.innerHTML = `<span class=\"tab-icon-analysis\"></span>${shortName} <span class=\"tab-close\">\\u2715</span>`;\n  tabsContainer.appendChild(tab);\n  const content = document.createElement(\"div\");\n  content.className = \"tab-content\";\n  content.dataset.content = tabId;\n  content.innerHTML = `\n        <div class=\"loose-container\">\n            <div id=\"plot-${tabId}-magnitude\" class=\"plot-medium\"></div>\n            <div id=\"plot-${tabId}-phase\" class=\"plot-medium\"></div>\n            <div id=\"plot-${tabId}-ir\" class=\"plot-medium\"></div>\n            <div class=\"analysis-description\" style=\"margin-bottom:12px; font-size:0.95rem; color:#24292e;\">\n                <p><strong>Analysis:</strong> Magnitude, phase and impulse\\u2011response computed from the uploaded response (and optional reference) via FFT and a two\\u2011channel impulse response.</p>\n                <p><strong>Smoothing:</strong> Fractional\\u2011octave smoothing applied to the reference response (1/6 octave).</p>\n            </div>\n        </div>\n    `;\n  tabContents.appendChild(content);\n  switchTab(tabId);\n  console.log(\"Analyzing response file:\", filename);\n  const data = new Float32Array(responseData.data);\n  const responseFFT = computeFFT(data);\n  const tracesMagnitude = [{\n    x: responseFFT.frequency,\n    y: db(responseFFT.magnitude),\n    type: \"scatter\",\n    mode: \"lines\",\n    name: \"Measurement signal\",\n    line: { color: \"#0366d6\", width: 2 }\n  }];\n  const tracesPhase = [];\n  const tracesIR = [];\n  let irPeakAt = 0;\n  if (referenceData) {\n    const referenceFFT = computeFFT(referenceData.data);\n    tracesMagnitude.push({\n      x: referenceFFT.frequency,\n      y: db(referenceFFT.magnitude),\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Reference signal\",\n      line: { color: \"#0366d6\", width: 2 }\n    });\n    const ir = twoChannelImpulseResponse(responseData.data, referenceData ? referenceData.data : new Float32Array(responseData.data.length));\n    const farina_ir = FarinaImpulseResponse(responseData.data, referenceData ? referenceData.data : new Float32Array(responseData.data.length));\n    console.log(\"Impulse response peak at\", ir.peakAt);\n    irPeakAt = ir.peakAt;\n    tracesIR.push({\n      x: ir.t,\n      y: db(ir.ir.map((v) => Math.abs(v))),\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Dual-FFT Impulse Response\",\n      line: { color: \"#d73a49\", width: 2 }\n    });\n    tracesIR.push({\n      x: farina_ir.t,\n      y: db(farina_ir.ir.map((v) => Math.abs(v))),\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Farina Impulse Response\",\n      line: { color: \"#d73a49\", width: 2 }\n    });\n    const transferFunction = computeFFTFromIR(ir, 100);\n    const transferFunctionF = computeFFTFromIR(farina_ir, 100);\n    const smoothedFreqResponse = smoothFFT(transferFunction, 1 / 6, 1 / 48);\n    tracesMagnitude.push({\n      x: transferFunction.frequency,\n      y: db(transferFunction.magnitude),\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Dual-FFT Transfer Function (Raw)\",\n      line: { color: \"#d73a4933\", width: 1 }\n    });\n    tracesMagnitude.push({\n      x: transferFunctionF.frequency,\n      y: db(transferFunctionF.magnitude),\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Farina Transfer Function\",\n      line: { color: \"#2600ff\", width: 1 }\n    });\n    tracesMagnitude.push({\n      x: smoothedFreqResponse.frequency,\n      y: smoothedFreqResponse.magnitude,\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Dual-FFT Transfer Function (Smoothed)\",\n      line: { color: \"#d73a49\", width: 2 }\n    });\n    tracesPhase.push({\n      x: transferFunction.frequency,\n      y: transferFunction.phase,\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Dual-FFT Transfer Function (Raw)\",\n      line: { color: \"#d73a4933\", width: 1 }\n    });\n    tracesPhase.push({\n      x: smoothedFreqResponse.frequency,\n      y: smoothedFreqResponse.phase,\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Dual-FFT Transfer Function (Smoothed)\",\n      line: { color: \"#d73a49\", width: 2 }\n    });\n  }\n  const plotSettings = {\n    plotGlPixelRatio: 2,\n    // For better clarity on high-DPI screens\n    legend: { x: 0.98, y: 0.02, xanchor: \"right\", yanchor: \"bottom\" },\n    plot_bgcolor: \"#fafbfc\",\n    paper_bgcolor: \"#fff\",\n    staticPlot: false,\n    // Enable interactivity\n    dragmode: \"pan\",\n    showAxisDragHandles: true,\n    showAxisRangeEntryBoxes: true,\n    axisDragOnHover: true,\n    tightenLats: true,\n    font: {\n      family: \"'Newsreader', Georgia, 'Times New Roman', Times, serif\"\n    }\n  };\n  const layoutMagnitude = {\n    title: \"Magnitude Analysis\",\n    xaxis: {\n      title: \"Frequency (Hz)\",\n      type: \"log\",\n      gridcolor: \"#e1e4e8\",\n      range: [Math.log10(20), Math.log10(2e4)],\n      tickformat: \".0f\"\n    },\n    yaxis: {\n      title: \"Magnitude (dB)\",\n      gridcolor: \"#e1e4e8\",\n      rangemode: \"tozero\",\n      range: [-90, 0]\n    },\n    ...plotSettings\n  };\n  window.Plotly.newPlot(`plot-${tabId}-magnitude`, tracesMagnitude, layoutMagnitude, { responsive: true });\n  const layoutPhase = {\n    title: \"Phase Analysis\",\n    xaxis: {\n      title: \"Frequency (Hz)\",\n      type: \"log\",\n      gridcolor: \"#e1e4e8\",\n      range: [Math.log10(20), Math.log10(2e4)],\n      tickformat: \".0f\"\n    },\n    yaxis: {\n      title: \"Phase (degrees)\",\n      gridcolor: \"#e1e4e8\",\n      automargin: true,\n      range: [-720, 720]\n    },\n    ...plotSettings\n  };\n  window.Plotly.newPlot(`plot-${tabId}-phase`, tracesPhase, layoutPhase, { responsive: true });\n  const layoutIR = {\n    title: \"Impulse response\",\n    xaxis: {\n      title: \"Amplitude\",\n      gridcolor: \"#e1e4e8\",\n      range: [-0.05 + irPeakAt / responseData.sampleRate, 0.05 + irPeakAt / responseData.sampleRate]\n    },\n    yaxis: {\n      title: \"Phase (degrees)\",\n      gridcolor: \"#e1e4e8\",\n      automargin: true\n    },\n    ...plotSettings\n  };\n  window.Plotly.newPlot(`plot-${tabId}-ir`, tracesIR, layoutIR, { responsive: true });\n  saveState();\n  storage.setItem(`${tabId}`, JSON.stringify({\n    filename,\n    referenceFilename,\n    responseData,\n    referenceData\n  })).catch((err) => console.error(\"Failed to persist analysis:\", err));\n}\nfunction saveState() {\n  const tabs = Array.from(document.querySelectorAll(\".tab[data-tab]\")).map((tab) => ({\n    id: tab.dataset.tab,\n    name: tab.textContent?.replace(\"\\xD7\", \"\").trim()\n  }));\n  storage.setItem(\"tabs\", JSON.stringify(tabs));\n  console.log(\"Saved state with tabs:\", tabs);\n}\nasync function loadState() {\n  try {\n    const savedTabs = await storage.getItem(\"tabs\");\n    if (!savedTabs) return;\n    const tabs = JSON.parse(savedTabs);\n    console.log(\"Loading saved tabs:\", tabs);\n    for (const tab of tabs) {\n      const raw = await storage.getItem(`${tab.id}`);\n      const analysisData = raw ? JSON.parse(raw) : null;\n      if (analysisData) {\n        createAnalysisTab(analysisData.responseData, analysisData.referenceData, analysisData.filename, analysisData.referenceFilename);\n      }\n    }\n  } catch (e) {\n    console.error(\"Failed to load saved state:\", e);\n  }\n}\nloadState();\n","console.debug(\"Math module loaded\");\n\nexport function logspace(start: number, end: number, num: number): number[] {\n    const logStart = Math.log10(start);\n    const logEnd = Math.log10(end);\n    const logStep = (logEnd - logStart) / (num - 1);\n    return Array.from({ length: num }, (_, i) => Math.pow(10, logStart + i * logStep));\n}\n\nexport function linspace(start: number, end: number, num: number): number[] {\n    if (num === 1) return [start];\n    const step = (end - start) / (num - 1);\n    return Array.from({ length: num }, (_, i) => start + i * step);\n}\n\nexport function closest(num: number, arr: number[]): number {\n    let curr = arr[0];\n    let diff = Math.abs(num - curr);\n    let index = 0;\n    for (let val = 0; val < arr.length; val++) {\n        const newDiff = Math.abs(num - arr[val]);\n        if (newDiff < diff) {\n            diff = newDiff;\n            curr = arr[val];\n            index = val;\n        }\n    }\n    return index;\n}\n\nexport function clamp(v: number, lower: number, upper: number): number {\n    return Math.max(lower, Math.min(upper, v));\n}\n\nexport const average = (array: number[]): number => array.reduce((a, b) => a + b) / array.length;\n\nexport const abs = (re: number, im: number = 0): number => Math.sqrt(re * re + im * im);\n\nexport const mod = (n: number, m: number): number => ((n % m) + m) % m;\n\nexport const nextPow2 = (v: number): number => {\n        let p = 1;\n        while (p < v) p <<= 1;\n        return p;\n    };","/* This software is licensed under the MIT License.\n\nCopyright Fedor Indutny, 2017.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\nconsole.debug(\"FFT module loaded\");\n\nexport class FFT {\n  size: number;\n  private _csize: number;\n  table: number[];\n  private _width: number;\n  private _bitrev: number[];\n  private _out: number[] | null;\n  private _data: number[] | null;\n  private _inv: number;\n\n  constructor(size: number) {\n    this.size = size | 0;\n    if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n      throw new Error('FFT size must be a power of two and bigger than 1');\n\n    this._csize = size << 1;\n\n    // NOTE: Use of `var` is intentional for old V8 versions\n    const table = new Array<number>(this.size * 2);\n    for (let i = 0; i < table.length; i += 2) {\n      const angle = Math.PI * i / this.size;\n      table[i] = Math.cos(angle);\n      table[i + 1] = -Math.sin(angle);\n    }\n    this.table = table;\n\n    // Find size's power of two\n    let power = 0;\n    for (let t = 1; this.size > t; t <<= 1)\n      power++;\n\n    // Calculate initial step's width:\n    //   * If we are full radix-4 - it is 2x smaller to give inital len=8\n    //   * Otherwise it is the same as `power` to give len=4\n    this._width = power % 2 === 0 ? power - 1 : power;\n\n    // Pre-compute bit-reversal patterns\n    this._bitrev = new Array<number>(1 << this._width);\n    for (let j = 0; j < this._bitrev.length; j++) {\n      this._bitrev[j] = 0;\n      for (let shift = 0; shift < this._width; shift += 2) {\n        const revShift = this._width - shift - 2;\n        this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n      }\n    }\n\n    this._out = null;\n    this._data = null;\n    this._inv = 0;\n  }\n\n  fromComplexArray(complex: number[] | Float32Array, storage?: number[] | Float32Array): number[] | Float32Array {\n    const res = storage || new Array<number>(complex.length >>> 1);\n    for (let i = 0; i < complex.length; i += 2)\n      res[i >>> 1] = complex[i];\n    return res;\n  }\n\n  createComplexArray(): number[] {\n    const res = new Array<number>(this._csize);\n    for (let i = 0; i < res.length; i++)\n      res[i] = 0;\n    return res;\n  }\n\n  toComplexArray(input: number[] | Float32Array, storage?: number[] | Float32Array): number[] | Float32Array {\n    const res = storage || this.createComplexArray();\n    for (let i = 0; i < res.length; i += 2) {\n      res[i] = input[i >>> 1];\n      res[i + 1] = 0;\n    }\n    return res;\n  }\n\n  completeSpectrum(spectrum: number[] | Float32Array): void {\n    const size = this._csize;\n    const half = size >>> 1;\n    for (let i = 2; i < half; i += 2) {\n      spectrum[size - i] = spectrum[i];\n      spectrum[size - i + 1] = -spectrum[i + 1];\n    }\n  }\n\n  transform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 0;\n    this._transform4();\n    this._out = null;\n    this._data = null;\n  }\n\n  realTransform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 0;\n    this._realTransform4();\n    this._out = null;\n    this._data = null;\n  }\n\n  inverseTransform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 1;\n    this._transform4();\n    for (let i = 0; i < out.length; i++)\n      out[i] /= this.size;\n    this._out = null;\n    this._data = null;\n  }\n\n  // radix-4 implementation\n  //\n  // NOTE: Uses of `var` are intentional for older V8 version that do not\n  // support both `let compound assignments` and `const phi`\n  private _transform4(): void {\n    const out = this._out!;\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = (size / step) << 1;\n\n    let outOff: number;\n    let t: number;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform2(outOff, off, step);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform4(outOff, off, step);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = (size / step) << 1;\n      const quarterLen = len >>> 2;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        // Full case\n        const limit = outOff + quarterLen;\n        for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n          const A = i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n\n          // Middle values\n          const MAr = Ar;\n          const MAi = Ai;\n\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n\n          const FCr = T0r - T2r;\n          const FCi = T0i - T2i;\n\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n\n          const FDr = T1r - T3i;\n          const FDi = T1i + T3r;\n\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          out[D] = FDr;\n          out[D + 1] = FDi;\n        }\n      }\n    }\n  }\n\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  private _singleTransform2(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n\n    const evenR = data[off];\n    const evenI = data[off + 1];\n    const oddR = data[off + step];\n    const oddI = data[off + step + 1];\n\n    const leftR = evenR + oddR;\n    const leftI = evenI + oddI;\n    const rightR = evenR - oddR;\n    const rightI = evenI - oddI;\n\n    out[outOff] = leftR;\n    out[outOff + 1] = leftI;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = rightI;\n  }\n\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  private _singleTransform4(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Ai = data[off + 1];\n    const Br = data[off + step];\n    const Bi = data[off + step + 1];\n    const Cr = data[off + step2];\n    const Ci = data[off + step2 + 1];\n    const Dr = data[off + step3];\n    const Di = data[off + step3 + 1];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T0i = Ai + Ci;\n    const T1r = Ar - Cr;\n    const T1i = Ai - Ci;\n    const T2r = Br + Dr;\n    const T2i = Bi + Di;\n    const T3r = inv * (Br - Dr);\n    const T3i = inv * (Bi - Di);\n\n    // Final values\n    const FAr = T0r + T2r;\n    const FAi = T0i + T2i;\n\n    const FBr = T1r + T3i;\n    const FBi = T1i - T3r;\n\n    const FCr = T0r - T2r;\n    const FCi = T0i - T2i;\n\n    const FDr = T1r - T3i;\n    const FDi = T1i + T3r;\n\n    out[outOff] = FAr;\n    out[outOff + 1] = FAi;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = FCi;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n\n  // Real input radix-4 implementation\n  private _realTransform4(): void {\n    const out = this._out!;\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = (size / step) << 1;\n\n    let outOff: number;\n    let t: number;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = (size / step) << 1;\n      const halfLen = len >>> 1;\n      const quarterLen = halfLen >>> 1;\n      const hquarterLen = quarterLen >>> 1;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n          const A = outOff + i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n\n          // Middle values\n          const MAr = Ar;\n          const MAi = Ai;\n\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n\n          // Output final middle point\n          if (i === 0) {\n            const FCr = T0r - T2r;\n            const FCi = T0i - T2i;\n            out[C] = FCr;\n            out[C + 1] = FCi;\n            continue;\n          }\n\n          // Do not overwrite ourselves\n          if (i === hquarterLen)\n            continue;\n\n          // In the flipped case:\n          // MAi = -MAi\n          // MBr=-MBi, MBi=-MBr\n          // MCr=-MCr\n          // MDr=MDi, MDi=MDr\n          const ST0r = T1r;\n          const ST0i = -T1i;\n          const ST1r = T0r;\n          const ST1i = -T0i;\n          const ST2r = -inv * T3i;\n          const ST2i = -inv * T3r;\n          const ST3r = -inv * T2i;\n          const ST3i = -inv * T2r;\n\n          const SFAr = ST0r + ST2r;\n          const SFAi = ST0i + ST2i;\n\n          const SFBr = ST1r + ST3i;\n          const SFBi = ST1i - ST3r;\n\n          const SA = outOff + quarterLen - i;\n          const SB = outOff + halfLen - i;\n\n          out[SA] = SFAr;\n          out[SA + 1] = SFAi;\n          out[SB] = SFBr;\n          out[SB + 1] = SFBi;\n        }\n      }\n    }\n  }\n\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  private _singleRealTransform2(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n\n    const evenR = data[off];\n    const oddR = data[off + step];\n\n    const leftR = evenR + oddR;\n    const rightR = evenR - oddR;\n\n    out[outOff] = leftR;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = 0;\n  }\n\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  private _singleRealTransform4(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Br = data[off + step];\n    const Cr = data[off + step2];\n    const Dr = data[off + step3];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T1r = Ar - Cr;\n    const T2r = Br + Dr;\n    const T3r = inv * (Br - Dr);\n\n    // Final values\n    const FAr = T0r + T2r;\n\n    const FBr = T1r;\n    const FBi = -T3r;\n\n    const FCr = T0r - T2r;\n\n    const FDr = T1r;\n    const FDi = T3r;\n\n    out[outOff] = FAr;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = 0;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n}\n","import { average, closest, logspace, linspace } from './math';\n\nconsole.debug(\"Fractional Octave Smoothing module loaded\");\n\nexport function getFractionalOctaveFrequencies(fraction: number, f_low: number = 20, f_high: number = 24000, fftSize: number): number[] {\n    if (fraction <= 0) {\n        throw new Error(\"Fraction must be greater than 0\");\n    }\n    if (f_low <= 0 || f_high <= 0) {\n        throw new Error(\"Frequencies must be greater than 0\");\n    }\n    if (f_low >= f_high) {\n        throw new Error(\"f_low must be less than f_high\");\n    }\n    const num_points = Math.round((Math.log10(f_high) - Math.log10(f_low)) / fraction) + 1;\n\n    let frequencies = logspace(f_low, f_high, num_points);\n\n    const frequency_resolution = 48000 / fftSize; // Assuming a sample rate of 48000 Hz\n\n    for (let i = 0; i < frequencies.length; i++) {\n        frequencies[i] = Math.round(frequencies[i] / frequency_resolution) * frequency_resolution;\n    }\n    frequencies = Array.from(new Set(frequencies)); // Remove duplicates\n\n    return frequencies;\n}\n\nexport function fractionalOctaveSmoothing(frequencyData: number[], fraction: number, frequencies: number[]): Float32Array {\n    const frequenciesAll = linspace(0, 48000 / 2, frequencyData.length);\n    const frequency_resolution = 48000 / frequencyData.length;\n    const smoothedData = new Float32Array(frequencies.length);\n    const n = frequencyData.length;\n    const factor = Math.pow(2, (0.5 * fraction)) - Math.pow(0.5, (0.5 * fraction));\n    for (let p = 0; p < frequencies.length; p++) {\n        const i = closest(frequencies[p], frequenciesAll);\n        // If the distance between this and previous frequency is less than frequency_resolution, pass direct value\n\n        let sum = 0;\n        const width = Math.round(0.5 * factor * (n * 0.5 - Math.abs(n * 0.5 - i)));\n        if (width === 0) {\n            sum = frequencyData[i];\n        } else {\n            const as = frequencyData.slice(Math.round(i - width + 1), Math.min(Math.round(i + width), n - 1));\n            sum = average(as);\n        }\n        smoothedData[p] = sum;\n    }\n    return smoothedData;\n}","import { abs, average, closest, linspace, mod, nextPow2 } from './math';\nimport { FFT } from './fft';\nimport { fractionalOctaveSmoothing, getFractionalOctaveFrequencies } from './fractional_octave_smoothing';\nimport { getSelectedWindow } from './windows';\n\nconsole.debug(\"Audio module loaded\");\n\n(window as any).FFT = FFT; // Make FFT globally available\n\nexport function sum(buffer: number[] | Float32Array): number {\n    let sum = 0;\n    for (let i = 0; i < buffer.length; i++) {\n        sum += buffer[i] * buffer[i];\n    }\n    return sum\n}\n\nexport function rms(buffer: number[] | Float32Array): number {\n    return Math.sqrt(sum(buffer) / buffer.length);\n}\n\n\n\nexport function normalize(input: number[] | Float32Array, peak: boolean = false): Float32Array {\n    const signal = Float32Array.from(input);\n\n    const rms_value = rms(input);\n    if (rms_value === 0) return Float32Array.from(input); // avoid division by zero, return original (silence)\n\n    const factor = (1 / rms_value) * (peak ? 1 : Math.SQRT2);\n\n    return signal.map(v => v * factor);\n}\n\nexport function exponentialMovingAverage(old: number, value: number, alpha: number): number {\n    return alpha * value + (1 - alpha) * old;\n}\n\nexport function db(value: Array<number>): Array<number>;\nexport function db(value: number): number;\nexport function db(value: Array<number> | number): Array<number> | number {\n    if (Array.isArray(value)) {\n        return value.map(v => 20 * Math.log10(v + 1e-50));\n    } else {\n        return 20 * Math.log10(value + 1e-50);\n    }\n}\n\nexport const smoothingFactor = (timeConstant: number, sampleRate: number): number => {\n    return 1 - Math.exp(-1 / (sampleRate * timeConstant));\n}\n\nexport function dbToLinear(db: number): number {\n    return Math.pow(10, db / 20);\n}\n\nexport function getExponentialSmoothingFactor(timeConstant: number, sampleRate: number): number {\n    return 1 - Math.exp(-1 / (timeConstant * sampleRate));\n}\n\nexport function linearToDb(linear: number): number {\n    return linear > 0 ? 20 * Math.log10(linear) : -Infinity;\n}\n\n/**\n * Generate a logarithmic chirp (sweep) similar to the provided Python version.\n * @param f_start - start frequency (Hz)\n * @param f_stop - stop frequency (Hz)\n * @param duration - total duration in seconds (if null, computed from rate)\n * @param rate - seconds per decade (if null, computed from duration)\n * @param fade - fade fraction (used to compute fade-in/out lengths)\n * @param fs - sample rate in Hz\n * @returns [sweepWindowed, timeVector, envelope]\n */\nexport function chirp(f_start: number, f_stop: number, duration: number | null = null, rate: number | null = null, fade: number = 0.01, fs: number = 48000): [Float32Array, Float32Array, Float32Array] {\n    const c = Math.log(f_stop / f_start);\n\n    let L: number;\n    let samples_count: number;\n\n    if (duration == null && rate == null) {\n        // Default to one decade per second if nothing provided\n        rate = 1.0;\n    }\n\n    if (duration == null) {\n        // rate is seconds per decade -> L = rate / ln(10)\n        L = (rate as number) / Math.log(10);\n        samples_count = Math.round(L * c * fs);\n        duration = samples_count / fs;\n    } else {\n        L = duration / c;\n        rate = Math.log(10) * L;\n        samples_count = Math.round(L * c * fs);\n    }\n\n    samples_count = Math.max(1, samples_count);\n\n    const fade_in = Math.max(0, Math.floor(fade * fs));\n    const fade_out = Math.max(0, Math.floor((fade / 10) * fs));\n\n    // instantaneous phase\n    // phi = (L * f_start) * (exp(t/L) - 1)\n    // compact phi: pre-fade (fade_in samples), main sweep, post-fade (fade_out samples)\n    const pre = Math.max(0, fade_in);\n    const post = Math.max(0, fade_out);\n    const phi = new Float32Array(pre + samples_count + post);\n\n    // offset matches original phi_fade_in last value: f_start * ((fade_in+1)/fs)\n    const offset = f_start * ((fade_in + 1) / fs);\n\n    // pre-fade linear ramp\n    for (let i = 0; i < pre; i++) phi[i] = f_start * (i / fs);\n\n    // main sweep (adds offset)\n    const baseIdx = pre;\n    for (let i = 0; i < samples_count; i++) {\n        let t = i / fs;\n        phi[baseIdx + i] = L * f_start * (Math.exp(t / L) - 1) + offset;\n    }\n\n    // post-fade linear ramp starting from last sweep value\n    const last = phi[baseIdx + samples_count - 1] || 0;\n    for (let i = 0; i < post; i++) {\n        phi[baseIdx + samples_count + i] = last + f_stop * ((i + 1) / fs);\n    }\n\n    // sweep = sin(2 * PI * phi)\n    const sweep = new Float32Array(phi.length);\n    for (let i = 0; i < phi.length; i++) sweep[i] = Math.sin(2 * Math.PI * phi[i]);\n\n    // compute time vector t for sweep length\n    const t = new Float32Array(sweep.length);\n    for (let i = 0; i < sweep.length; i++) t[i] = i / fs;\n\n    // envelope main: (exp(-t/L) / L) * f_stop * duration^2\n    const envMain = new Float32Array(t.length);\n    const factor = f_stop * (duration as number) * (duration as number);\n    for (let i = 0; i < t.length; i++) envMain[i] = (Math.exp(-t[i] / L) / L) * factor;\n\n    // prepend and append small zero pads (approx. 10ms and 1ms at given fs)\n    const startZeros = Math.floor(0.01 * fs); // ~480 samples at 48k\n    const endZeros = Math.floor(0.001 * fs);  // ~48 samples at 48k\n    const envelope = new Float32Array(startZeros + envMain.length + endZeros);\n    // zeros already, copy envMain into middle\n    envelope.set(envMain, startZeros);\n\n    // window: simple linear fade in/out over fade_in / fade_out samples\n    const window = new Float32Array(sweep.length);\n    for (let i = 0; i < sweep.length; i++) {\n        let w = 1.0;\n        if (fade_in > 0 && i < fade_in) {\n            w = i / Math.max(1, fade_in);\n        }\n        if (fade_out > 0 && i >= sweep.length - fade_out) {\n            const k = i - (sweep.length - fade_out);\n            w *= 1 - (k / Math.max(1, fade_out));\n        }\n        window[i] = w;\n    }\n\n    // apply window to sweep\n    const sweepWindowed = new Float32Array(sweep.length);\n    for (let i = 0; i < sweep.length; i++) sweepWindowed[i] = sweep[i] * window[i];\n\n    return [sweepWindowed, t, envelope];\n}\n\nexport interface Audio {\n    sampleRate: number;\n    channels: number;\n    data: Float32Array[];\n}\n\nexport interface FFTResult {\n    frequency: number[];\n    magnitude: number[];\n    phase: number[];\n    fftSize: number;\n}\n\n\nexport function smoothFFT(fftData: FFTResult, fraction: number, resolution: number): FFTResult {\n    const { frequency, magnitude, phase, fftSize } = fftData;\n    const smoothedMagnitude = new Float32Array(magnitude.length);\n\n    // Get fractional octave frequencies\n    const fractionalFrequencies = getFractionalOctaveFrequencies(resolution, 20, 24000, fftSize);\n\n    // Apply fractional octave smoothing\n    const smoothed = fractionalOctaveSmoothing(db(magnitude), fraction, fractionalFrequencies);\n    const smoothedPhase = fractionalOctaveSmoothing(phase, fraction, fractionalFrequencies);\n\n    return {\n        frequency: fractionalFrequencies,\n        magnitude: Array.from(smoothed),\n        phase: Array.from(smoothedPhase),\n        fftSize\n    };\n}\n\nexport function computeFFT(data: Array<number> | Float32Array, fftSize: number | null = null): FFTResult {\n    fftSize ??= 2 ** Math.ceil(Math.log2(data.length));\n    console.log(`Computing FFT with ${fftSize} bins for data length ${data.length}`);\n    const fft = new FFT(fftSize);\n    const out = fft.createComplexArray();\n\n    // Fix data length by zero-padding or truncating.\n    const frame = new Float32Array(fftSize);\n    for (let i = 0; i < fftSize; i++) {\n        frame[i] = (data[i] || 0) * 1;\n    }\n    fft.realTransform(out, frame);\n    \n    const frequency: number[] = [];\n    const magnitude: number[] = [];\n    const phase: number[] = [];\n\n    for (let i = 0; i < fftSize / 2; i++) {\n            const re = out[2 * i];\n            const im = out[2 * i + 1];\n            magnitude[i] = abs(re, im) * Math.SQRT2; // Scale by sqrt(2) for single-sided spectrum.\n            phase[i] = Math.atan2(im, re); // phase in radians, range [-PI, PI].\n    }\n    const frequencyResolution = 48000 / fftSize; // Assuming sample rate of 48000 Hz\n    for (let i = 0; i < fftSize / 2; i++) {\n        frequency[i] = i * frequencyResolution;\n    }\n\n    return {\n        frequency,\n        magnitude,\n        phase,\n        fftSize,\n    };\n}\n\nexport interface CorrelationResult {\n    corr: Float64Array;\n    lags: Int32Array;\n    estimatedLagSamples: number;\n    estimatedLagIndex: number;\n    peakCorrelation: number;\n    raw: Float64Array;\n    nfft: number;\n}\n\nexport function fftCorrelation(x: number[] | Float32Array, y: number[] | Float32Array): CorrelationResult {\n    // cross-correlate x with y using FFT (fft.js). Returns normalized cross-correlation,\n    // lags (samples), estimated lag (samples) and peak correlation value.\n    const lenX = x.length;\n    const lenY = y.length;\n    const fullLen = lenX + lenY - 1;\n\n    // next pow2 >= fullLen\n    const nextPow2 = (v: number): number => {\n        let p = 1;\n        while (p < v) p <<= 1;\n        return p;\n    };\n    const n = nextPow2(fullLen);\n\n    // zero-pad inputs to length n\n    const xP = new Float32Array(n);\n    const yP = new Float32Array(n);\n    xP.set(x, 0);\n    yP.set(y, 0);\n\n    const fft = new FFT(n);\n    const A = fft.createComplexArray();\n    const B = fft.createComplexArray();\n\n    // forward real FFTs\n    fft.realTransform(A, xP);\n    fft.realTransform(B, yP);\n    // complete the spectrum to full complex arrays (negative freqs)\n    if (typeof fft.completeSpectrum === 'function') {\n        fft.completeSpectrum(A);\n        fft.completeSpectrum(B);\n    }\n\n    // multiply A * conj(B) -> cross-spectrum\n    const C = fft.createComplexArray();\n    for (let k = 0; k < n; k++) {\n        const ar = A[2 * k], ai = A[2 * k + 1];\n        const br = B[2 * k], bi = B[2 * k + 1];\n        // A * conj(B) = (ar + i ai)*(br - i bi)\n        C[2 * k] = ar * br + ai * bi;\n        C[2 * k + 1] = ai * br - ar * bi;\n    }\n\n    // inverse FFT of cross-spectrum\n    const out = fft.createComplexArray();\n    fft.inverseTransform(out, C);\n\n    // real part / n gives linear cross-correlation (no circular wrap because padded)\n    const corr = new Float64Array(fullLen);\n    for (let i = 0; i < fullLen; i++) {\n        corr[i] = out[2 * i] / n;\n    }\n\n    // compute normalization factor (energy)\n    let sumX2 = 0, sumY2 = 0;\n    for (let i = 0; i < lenX; i++) sumX2 += x[i] * x[i];\n    for (let i = 0; i < lenY; i++) sumY2 += y[i] * y[i];\n    const denom = Math.sqrt(sumX2 * sumY2);\n\n    const normalized = new Float64Array(fullLen);\n    if (denom > 0) {\n        for (let i = 0; i < fullLen; i++) normalized[i] = corr[i] / denom;\n    } else {\n        // silence case -> zeros\n        for (let i = 0; i < fullLen; i++) normalized[i] = 0;\n    }\n\n    // lags: index i corresponds to lag = i - (lenY - 1)\n    const lags = new Int32Array(fullLen);\n    for (let i = 0; i < fullLen; i++) lags[i] = i - (lenY - 1);\n\n    // find peak\n    let peakIdx = 0;\n    let peakVal = -Infinity;\n    for (let i = 0; i < fullLen; i++) {\n        if (normalized[i] > peakVal) {\n            peakVal = normalized[i];\n            peakIdx = i;\n        }\n    }\n    const estimatedLag = lags[peakIdx];\n\n    return {\n        corr: normalized,\n        lags,\n        estimatedLagSamples: estimatedLag,\n        estimatedLagIndex: peakIdx,\n        peakCorrelation: peakVal,\n        raw: corr,\n        nfft: n\n    };\n}\n\nexport function fftConvolve(x: number[] | Float32Array, y: number[] | Float32Array, mode: 'same' | 'full' = 'same'): Array<number> {\n    const lenX = x.length;\n    const lenY = y.length;\n    const fullLen = lenX + lenY - 1;\n\n    // next pow2 >= fullLen\n    const n = nextPow2(fullLen);\n\n    // zero-pad inputs to length n\n    const xP = new Float32Array(n);\n    const yP = new Float32Array(n);\n    xP.set(x, 0);\n    yP.set(y, 0);\n\n    const fft = new FFT(n);\n    const A = fft.createComplexArray();\n    const B = fft.createComplexArray();\n\n    // forward real FFTs\n    fft.realTransform(A, xP);\n    fft.realTransform(B, yP);\n        // complete the spectrum to full complex arrays (negative freqs)\n    if (typeof fft.completeSpectrum === 'function') {\n        fft.completeSpectrum(A);\n        fft.completeSpectrum(B);\n    }\n\n    // multiply A * B -> convolution spectrum\n    const C = fft.createComplexArray();\n    for (let k = 0; k < n; k++) {\n        const ar = A[2 * k], ai = A[2 * k + 1];\n        const br = B[2 * k], bi = B[2 * k + 1];\n        C[2 * k] = ar * br - ai * bi;\n        C[2 * k + 1] = ai * br + ar * bi;\n    }\n\n    // inverse FFT\n    const out = fft.createComplexArray();\n    fft.inverseTransform(out, C);\n\n    // extract real part and normalize by n\n    const result = new Float64Array(fullLen);\n    for (let i = 0; i < fullLen; i++) {\n        result[i] = out[2 * i];\n    }\n\n    // return 'same' mode (centered, matching first input length)\n    if (mode === 'same') {\n        const start = Math.floor((fullLen - lenX) / 2);\n        return Array.from(result).slice(start, start + lenX);\n    }\n\n    return Array.from(result);\n}\n\nexport interface ImpulseResponseResult {\n    ir: Array<number>;\n    ir_complex: Array<number>;\n    t: Array<number>;\n    peakAt: number;\n    sampleRate: number;\n    fftSize: number;\n}\n\n\nfunction max(arr: Array<number>): number {\n    let maxVal = -Infinity;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] > maxVal) {\n            maxVal = Math.abs(arr[i]);\n        }\n    }\n    return maxVal;\n}\n\nfunction normalizeToMax(arr: Array<number>): Array<number> {\n    const maxVal = max(arr);\n    if (maxVal === 0) return arr.slice(); // avoid division by zero\n    return arr.map(v => v / maxVal);\n}\n\n\nclass Farina {\n    /* Farina deconvolution implementation according to the Python implementation: \n    class Farina():\n        \"\"\"Farina method.\"\"\"\n\n        def __init__(self, stim, f_start=50, f_stop=22800, fs=48000):\n            self.stimulus = np.trim_zeros(stim)\n            self.f_start = f_start\n            self.f_stop = f_stop\n            self.fs = fs\n            self.last_instant = 0\n\n            self.deconv_signal = []\n            self.deconv_hash = 0\n\n        def lag_of_harmonic(self, n: np.ndarray):\n            return self.ell*np.log(n)\n\n        def margin_of_harmonic(self, n: np.ndarray):\n            return self.ell*np.log(n+1)-self.ell*np.log(n)\n\n        def max_safe_harmonic(self, window_size: float):\n            t = [\n                self.margin_of_harmonic(n)\n                for n in range(1, 1000)\n                if self.margin_of_harmonic(n) > window_size\n            ]\n            return len(t) if len(t) < 999 else None\n\n        def rate(self, length):\n            return 1/self.f_start*np.pi*np.round(length*self.f_start/np.log2(\n                self.f_stop/self.f_start))\n\n        def deconvolution(self, signal):\n            if hash(signal.tostring()) == self.deconv_hash:\n            return self.deconv_signal\n            bins = scipy.fftpack.helper.next_fast_len(len(signal))\n            ratio = self.f_stop/self.f_start\n            kend = 10**((-6*np.log2(ratio))/20)\n            k = np.log(kend)/self.duration\n            t = np.arange(0, 255788)/self.fs\n            k = np.exp(-t*k)\n            inv_stimulus = self.stimulus[-1::-1]/k/np.max(self.stimulus)\n\n            #signal_fft = scipy.fft(signal, bins)/np.sqrt(len(signal))\n            #stimulus_fft = scipy.fft(inv_stimulus, bins)/np.sqrt(len(inv_stimulus))\n\n            #h_fft = signal_fft*stimulus_fft.T\n\n            self.deconv_signal = scipy.signal.fftconvolve(signal, inv_stimulus, 'same')[-1::-1]/np.sqrt(len(signal))/58.5 ##scipy.ifft(h_fft)[::-1]*np.sqrt(len(h_fft))\n            self.deconv_hash = hash(signal.tostring())\n            return self.deconv_signal\n\n        def impulse_response(self, signal):\n            bins = scipy.fftpack.helper.next_fast_len(len(signal))\n\n            signal_fft = scipy.fft(signal, bins)\n            stimulus_fft = scipy.fft(self.stimulus, bins)\n            h_fft = signal_fft/stimulus_fft.T\n\n            h = scipy.ifft(h_fft)\n            return h\n\n        @property\n        def duration(self):\n            return len(np.trim_zeros(self.stimulus))/self.fs\n\n        def window(self, signal, at, length):\n            w = scipy.signal.windows.tukey(int(length * 2 * self.fs), 0.2)\n            size = int(length * self.fs)\n            sig = self.deconvolution(signal)\n            #print(at - size)\n            #print(at + size)\n            si = sig[at - size:at + size]\n\n            if len(si) == len(w):\n            return w*si.T\n            else:\n            return np.zeros_like(w)\n\n        def frequency_response(self, signal, length, num):\n            signal = np.pad(signal, (int(length * self.fs),int(length * self.fs)), 'constant')\n            print(self.instant(signal) + int(self.lag_of_harmonic(num) * self.fs))\n            signal = self.window(signal, self.instant(signal) + int(self.lag_of_harmonic(num) * self.fs), length)\n\n            bins = scipy.fftpack.helper.next_fast_len(len(signal))\n            et = np.abs(np.fft.fft(signal, bins))[0:int(bins/2+1)]\n            return et, np.fft.rfftfreq(bins)*self.fs\n\n        def instant(self, signal = None):\n            if signal is not None:\n            self.last_instant = np.argmax(self.deconvolution(signal))\n            if self.instant == 0:\n            print('No delay in signal.')\n            return self.last_instant\n\n        @property\n        def ell(self):\n            return 255788/np.log(self.f_stop/self.f_start)/self.fs\n    */\n    constructor(stimulus: Float32Array, f_start: number = 50, f_stop: number = 22800, fs: number = 48000) {\n        this.f_start = f_start;\n        this.f_stop = f_stop;\n        this.fs = fs;\n        this.stimulus = stimulus;\n    }\n\n    f_start: number;\n    f_stop: number;\n    fs: number;\n    stimulus: Float32Array;\n\n    lag_of_harmonic(n: number) {\n        return this.ell() * Math.log(n);\n    }\n\n    margin_of_harmonic(n: number) {\n        return this.ell() * Math.log(n + 1) - this.ell() * Math.log(n);\n    }\n\n    max_safe_harmonic(window_size: number): number | null {\n        const t: number[] = [];\n        for (let n = 1; n < 1000; n++) {\n            if (this.margin_of_harmonic(n) > window_size) {\n                t.push(this.margin_of_harmonic(n));\n            }\n        }\n        return t.length < 999 ? t.length : null;\n    }\n\n    ell(): number {\n        return 255788 / Math.log(this.f_stop / this.f_start) / this.fs;\n    }\n\n    rate(length: number): number {\n        return 1 / this.f_start * Math.PI * Math.round(length * this.f_start / Math.log2(this.f_stop / this.f_start));\n    }\n\n    duration(): number {\n        return this.stimulus.filter(v => v !== 0).length / this.fs;\n    }\n\n    window(signal: Float32Array, at: number, length: number): Float32Array {\n        const size = Math.floor(length * this.fs);\n        const window: Array<number> = getSelectedWindow('hanning', size);\n        const sig = this.deconvolution(signal);\n        const si = sig.slice(at - size, at + size);\n        const w = new Float32Array(size);\n        if (si.length === window.length) {\n            for (let i = 0; i < window.length; i++) {\n                w[i] = window[i] * si[i];\n            }\n            return w;\n        } else {\n            return new Float32Array(window.length); // zeros\n        }        \n    }\n\n    deconvolution(signal: Float32Array): Float32Array {\n        const fftSize = nextPow2(signal.length);\n        const ratio = this.f_stop / this.f_start;\n        const kend = Math.pow(10, (-6 * Math.log2(ratio)) / 20);\n        const k = Math.log(kend) / this.duration();\n        const t = new Float32Array(255788);\n        for (let i = 0; i < t.length; i++) {\n            t[i] = i / this.fs;\n        }\n        const exp_k = new Float32Array(t.length);\n        for (let i = 0; i < t.length; i++) {\n            exp_k[i] = Math.exp(-t[i] * k);\n        }\n\n        const inv_stimulus = new Float32Array(this.stimulus.length);\n        const maxStimulus = max(Array.from(this.stimulus));\n        for (let i = 0; i < this.stimulus.length; i++) {\n            inv_stimulus[i] = this.stimulus[this.stimulus.length - 1 - i] / exp_k[i] / maxStimulus;\n        }\n\n        const convolved = fftConvolve(signal, inv_stimulus, 'same');\n        const deconv_signal = new Float32Array(convolved.length);\n        for (let i = 0; i < convolved.length; i++) {\n            deconv_signal[i] = convolved[convolved.length - 1 - i] / Math.sqrt(signal.length) / 58.5;\n        }\n        return deconv_signal;\n    }\n    \n    \n}\n\nexport function FarinaImpulseResponse(y: number[] | Float32Array, x: number[] | Float32Array): ImpulseResponseResult {\n    const n: number[] = linspace(0, x.length - 1, x.length);\n    const ratio: number = Math.log(22800 / 50);\n    const duration = x.length / 48000; // assuming 48kHz.\n    const k: number[] = n.map(v => Math.exp(v * ratio / x.length)); // simplified for first element\n    \n    const L = duration / ratio;\n    const rate = Math.log(10) * L;\n\n    const x_inv: Float32Array = new Float32Array(x.length);\n    for (let i = 0; i < x.length; i++) {\n        x_inv[i] = x[x.length - 1 - i] / k[i];\n    }\n\n    const measurementResponse = fftConvolve(y, x_inv, 'same');\n    const stimulusResponse = fftConvolve(x, x_inv, 'same');\n    const norm: number = Array.from(stimulusResponse).reduce((a, b) => Math.max(a, Math.abs(b)), 0);\n    \n    let sums: number = 0;\n    for (let i = 0; i < stimulusResponse.length; i++) {\n        sums += stimulusResponse[i];\n    }\n    // Real part / N gives impulse response. This is shifted by N/2.\n    const rmss = sum(x_inv) * 2 * y.length / x_inv.length; // RMS of input signal\n    const ir = Array.from(new Float32Array(measurementResponse.length));\n    for (let i = 0; i < measurementResponse.length; i++) {\n        ir[i] = measurementResponse[i] / norm; // normalize by input length\n    }\n\n    const ir_complex = Array.from(new Float32Array(measurementResponse.length * 2));\n    for (let i = 0; i < measurementResponse.length; i++) {\n        ir_complex[2 * i] = measurementResponse[i] / norm; // normalize by input length\n        ir_complex[2 * i + 1] = 0;\n    }\n\n    const peakAt = closest(100000000, ir) + (-measurementResponse.length) / 2;\n    /* const ir_complex = Array.from(measurementResponse); // copy\n    for (let i = 0; i < N; i++) {\n        ir_complex[2 * i] = measurementResponse[2 * mod(i + peakAt, N)];\n        ir_complex[2 * i + 1] = measurementResponse[2 * mod(i + peakAt, N) + 1];\n    }*/\n\n    return {\n        ir,\n        ir_complex,\n        t: Array.from(linspace((-measurementResponse.length - 1) / 2 / 48000, (measurementResponse.length - 1) / 2 / 48000, measurementResponse.length)), // assuming 48kHz\n        peakAt,\n        sampleRate: 48000,\n        fftSize: measurementResponse.length,\n    };\n}\n\n\nexport function twoChannelImpulseResponse(y: number[] | Float32Array, x: number[] | Float32Array): ImpulseResponseResult {\n    // Calculate the impulse response by taking the IFFT of the division of the FFTs of output and input signals.\n    const fullLen = y.length + x.length - 1;\n    \n    const N = nextPow2(fullLen);\n\n    // zero-pad inputs to length n\n    const xP = new Float32Array(N);\n    const yP = new Float32Array(N);\n    xP.set(y, 0);\n    yP.set(x, 0);\n\n    const fft = new FFT(N);\n    const A = fft.createComplexArray();\n    const B = fft.createComplexArray();\n\n    // forward real FFTs\n    fft.realTransform(A, xP);\n    fft.realTransform(B, yP);\n\n    // Division A / B with regularization to avoid division by zero\n    const C = fft.createComplexArray();\n    const epsilon = 1e-20;\n    for (let k = 0; k < N; k++) {\n        const ar = A[2 * k], ai = A[2 * k + 1];\n        const br = B[2 * k], bi = B[2 * k + 1];\n        const denom = br * br + bi * bi + epsilon;\n        C[2 * k] = (ar * br + ai * bi) / denom;\n        C[2 * k + 1] = (ai * br - ar * bi) / denom;\n    }\n\n    // inverse FFT of cross-spectrum\n    const out = fft.createComplexArray();\n    fft.inverseTransform(out, C);\n\n    // Real part / N gives impulse response. This is shifted by N/2.\n    const ir = Array.from(new Float32Array(N));\n    for (let i = 0; i < N; i++) {\n        ir[i] = out[2 * (( i + N / 2) % N)]; // normalize by input length\n    }\n\n    const peakAt = closest(100000000, ir) + (-N) / 2;\n    const ir_complex = out.slice(); // copy\n    for (let i = 0; i < N; i++) {\n        ir_complex[2 * i] = out[2 * mod(i + peakAt, N)];\n        ir_complex[2 * i + 1] = out[2 * mod(i + peakAt, N) + 1];\n    }\n\n    // Remove DC offset.\n    const mean = average(ir)\n    for (let i = 0; i < N; i++) {\n        ir[i] = ir[i] - mean;\n    }\n\n    return {\n        ir,\n        ir_complex,\n        t: Array.from(linspace((-N - 1) / 2 / 48000, (N - 1) / 2 / 48000, N)), // assuming 48kHz\n        peakAt,\n        sampleRate: 48000,\n        fftSize: N,\n    };\n}\n\nexport function twoChannelFFT(dataArray: number[] | Float32Array, reference: number[] | Float32Array, fftSize: number, offset: number): FFTResult {\n    const dataPadded = new Float32Array(fftSize);\n    const referencePadded = new Float32Array(fftSize);\n\n    if (offset >= 0) {\n        referencePadded.set(reference.slice(0, Math.min(reference.length, fftSize) - offset), offset);\n        dataPadded.set(dataArray.slice(0, Math.min(dataArray.length, fftSize)), 0);\n    } else {\n        referencePadded.set(reference.slice(0, Math.min(reference.length, fftSize)), 0);\n        dataPadded.set(dataArray.slice(-offset, Math.min(dataArray.length, fftSize) + offset), -offset);\n    }\n\n    //const rmss = rms(referencePadded);\n    const reference_ = computeFFT(referencePadded);  // Avoid log(0)\n    const signal_ = computeFFT(dataPadded);\n    const signalMags = signal_.magnitude.map(v => 20 * Math.log10(v === 0 ? 1e-20 : v));\n    const referenceMags = reference_.magnitude.map(v => 20 * Math.log10(v === 0 ? 1e-20 : v));\n    const h = referenceMags.map((v, i) => signalMags[i] - v); // dB difference\n    const frequency = linspace(0, 48000 / 2, h.length);\n\n    // For phase, align the reference and signal using a fixed offset (26718 samples for 1m @ 340m/s and 48kHz)\n    // This is a hack to get a reasonable phase response for the measurement setup\n    // In a real application, use cross-correlation to find the delay between signals\n\n    const i_50 = closest(50, frequency); // Example usage of closest function\n    const phase_signal = signal_.phase;\n    const phase_reference = reference_.phase;\n    // phase difference (unwrap phases first)\n    const sphase = unwrapPhase(phase_signal.map((v, i) => v - phase_reference[i])); // phase difference in radians\n    const correction = (Math.floor(sphase[i_50] / (2 * Math.PI) + 0.5)) * (2 * Math.PI);\n    const phase = sphase.map(v => (v - correction)); // relative to 50 Hz\n\n    // simple phase unwrapping (returns Float32Array)\n    function unwrapPhase(phases: number[]): Array<number> {\n        const N = phases.length;\n        const out = Array.from(new Float32Array(N));\n        if (N === 0) return out;\n        out[0] = phases[0];\n        let offset = 0;\n        const theta = Math.PI; // unwrapping threshold\n        for (let i = 1; i < N; i++) {\n            let delta = phases[i] - phases[i - 1];\n            if (delta > theta) {\n                offset -= 2 * Math.PI;\n            } else if (delta < -theta) {\n                offset += 2 * Math.PI;\n            }\n            out[i] = phases[i] + offset;\n        }\n        return out;\n    }\n\n    return {\n        frequency,\n        magnitude: h,\n        phase,\n        fftSize\n    };\n}\n\nexport function computeFFTFromIR(ir: ImpulseResponseResult, f_phase_wrap: number = 50): FFTResult {\n    const magnitude: number[] = [];\n    const phase: number[] = [];\n\n    const N = nextPow2(ir.ir.length);\n    console.log(`Computing FFT from IR with size ${N}`);\n    \n    const fft = new FFT(N);\n    const out = fft.createComplexArray();\n\n    if (ir.ir_complex[1] === 0) {\n        console.log(\"IR is in real format, converting to complex\");\n        // real IR, convert to complex\n        const frame = new Float32Array(N);\n        for (let i = 0; i < N; i++) {\n            frame[i] = (ir.ir_complex[2 * i] || 0) * 1;\n        }\n        fft.realTransform(out, frame);\n    } else {\n        fft.transform(out, ir.ir_complex);\n    }\n    console.log(ir.ir_complex);\n    \n    for (let i = 0; i < N / 2; i++) {\n        const re = out[2 * i];\n        const im = out[2 * i + 1];\n        magnitude[i] = abs(re, im);\n        phase[i] = Math.atan2(im, re); // phase in radians, range [-PI, PI].\n    }\n    const frequency = linspace(0, 48000 / 2, magnitude.length);\n\n    const i_norm = closest(f_phase_wrap, frequency); // Example usage of closest function\n    // phase difference (unwrap phases first)\n    const unwraped_phase = unwrapPhase(phase); // phase difference in radians\n    const correction = (Math.floor(unwraped_phase[i_norm] / (2 * Math.PI) + 0.5)) * (2 * Math.PI);\n    const corrected_unwraped_phase = unwraped_phase.map(v => (v - correction)); // relative to 50 Hz\n\n    // simple phase unwrapping (returns Float32Array)\n    function unwrapPhase(phases: number[]): Array<number> {\n        const N = phases.length;\n        const out = Array.from(new Float32Array(N));\n        if (N === 0) return out;\n        out[0] = phases[0];\n        let offset = 0;\n        for (let i = 1; i < N; i++) {\n            let delta = phases[i] - phases[i - 1];\n            if (delta > Math.PI) {\n                offset -= 2 * Math.PI;\n            } else if (delta < -Math.PI) {\n                offset += 2 * Math.PI;\n            }\n            out[i] = phases[i] + offset;\n        }\n        return out;\n    }\n\n    return {\n        frequency,\n        magnitude,\n        phase: corrected_unwraped_phase.map(v => v / Math.PI * 180),\n        fftSize: N,\n    };\n}\n\nexport const A_WEIGHTING_COEFFICIENTS: [number[], number[]] = [\n    [0.234301792299513, -0.468603584599026, -0.234301792299513, 0.937207169198054, -0.234301792299515, -0.468603584599025, 0.234301792299513],\n    [1.000000000000000, -4.113043408775871, 6.553121752655047, -4.990849294163381, 1.785737302937573, -0.246190595319487, 0.011224250033231],\n];\n// Coefficients for K-weighting filter (pre-emphasis and high-frequency shelving)\n// From ITU-R BS.1770-4, Table 1\n// https://www.itu.int/dms_pubrec/itu-r/rec/bs/r-rec-bs.1770-2-201103-s!!pdf-e.pdf\nexport const K_WEIGHTING_COEFFICIENTS_PRE: [number[], number[]] = [\n    [1.53512485958697, -2.69169618940638, 1.19839281085285],\n    [1, -1.69065929318241, 0.73248077421585]\n];\n\nexport const K_WEIGHTING_COEFFICIENTS_RLB: [number[], number[]] = [\n    [1.0, -2.0, 1.0],\n    [1, -1.99004745483398, 0.99007225036621]\n];\n\nexport function applyAWeightingToBuffer(buffer: Float32Array, zi: number[]): Float32Array {\n    const b = A_WEIGHTING_COEFFICIENTS[0];\n    const a = A_WEIGHTING_COEFFICIENTS[1];\n    const output = new Float32Array(buffer.length);\n    for (let n = 0; n < buffer.length; n++) {\n        output[n] = b[0] * buffer[n] + zi[0];\n        for (let i = 1; i < b.length; i++) {\n            zi[i - 1] = b[i] * buffer[n] + zi[i] - a[i] * output[n];\n        }\n    }\n    return output;\n}\n\nexport function gateBuffer(buffer: Float32Array, sampleRate: number, thresholdDb: number = -70, blockMs: number = 400, overlap: number = 0.75): Float32Array {\n    const blockSize = Math.floor((blockMs / 1000) * sampleRate);\n    const hopSize = Math.floor(blockSize * (1 - overlap));\n    const threshold = dbToLinear(thresholdDb);\n\n    const gated = new Float32Array(buffer.length);\n    let i = 0;\n\n    while (i < buffer.length) {\n        const start = i;\n        const end = Math.min(i + blockSize, buffer.length);\n        const block = buffer.subarray(start, end);\n        const blockRms = rms(block);\n\n        if (blockRms >= threshold) {\n            gated.set(block, start);\n        }\n        // else: leave zeros (gate closed)\n\n        i += hopSize;\n    }\n\n    return gated;\n}\n\n/**\n * Calculate ITU-R BS.1770-4 loudness (LKFS/LUFS) for a mono or stereo buffer.\n * https://www.itu.int/dms_pubrec/itu-r/rec/bs/R-REC-BS.1770-5-202311-I!!PDF-E.pdf\n * @param input - Mono buffer or array of channel buffers.\n * @param sampleRate - Sample rate in Hz.\n * @returns Integrated loudness in LUFS.\n */\nexport function bs1770Loudness(input: Float32Array | Float32Array[], sampleRate: number): number {\n    // K-weighting filter coefficients (biquad, 2nd order)\n    // From ITU-R BS.1770-4, Table 1\n    const b = [1.53512485958697, -2.69169618940638, 1.19839281085285];\n    const a = [1, -1.69065929318241, 0.73248077421585];\n\n    // Helper: apply biquad filter to a buffer\n    function biquadFilter(buffer: Float32Array, b: number[], a: number[]): Float32Array {\n        const out = new Float32Array(buffer.length);\n        let x1 = 0, x2 = 0, y1 = 0, y2 = 0;\n        for (let n = 0; n < buffer.length; n++) {\n            const x0 = buffer[n];\n            const y0 = b[0] * x0 + b[1] * x1 + b[2] * x2 - a[1] * y1 - a[2] * y2;\n            out[n] = y0;\n            x2 = x1; x1 = x0;\n            y2 = y1; y1 = y0;\n        }\n        return out;\n    }\n\n    // Accept mono or stereo\n    let channels: Float32Array[];\n    if (Array.isArray(input)) {\n        channels = input;\n    } else {\n        channels = [input];\n    }\n\n    // Apply K-weighting filter to each channel\n    const filtered = channels.map(ch => biquadFilter(ch, b, a));\n\n    // Gating parameters\n    const windowMs = 400;\n    const windowSize = Math.floor(windowMs * sampleRate / 1000);\n    const overlapRatio = 0.75;\n    const hopSize = Math.floor(windowSize * (1 - overlapRatio));\n    const absoluteGate = dbToLinear(-70);\n    const relativeGateOffset = -10; // dB\n\n    // Calculate channel weights (ITU: [1, 1] for stereo)\n    const weights = channels.length === 2 ? [1, 1] : [1];\n\n    // Calculate block energies\n    let energies: number[] = [];\n    for (let i = 0; i + windowSize <= filtered[0].length; i += hopSize) {\n        let sum = 0;\n        for (let ch = 0; ch < filtered.length; ch++) {\n            const block = filtered[ch].subarray(i, i + windowSize);\n            const blockSum = block.reduce((acc, v) => acc + v * v, 0);\n            sum += weights[ch] * blockSum;\n        }\n        const energy = sum / (windowSize * weights.reduce((a, b) => a + b, 0));\n        energies.push(energy);\n    }\n\n    // Absolute gating\n    const gatedEnergies = energies.filter(e => e >= absoluteGate);\n\n    if (gatedEnergies.length === 0) return -Infinity;\n\n    // Relative gating\n    const meanEnergy = gatedEnergies.reduce((a, b) => a + b, 0) / gatedEnergies.length;\n    const relativeGate = meanEnergy * dbToLinear(relativeGateOffset);\n    const finalEnergies = gatedEnergies.filter(e => e >= relativeGate);\n\n    if (finalEnergies.length === 0) return -Infinity;\n\n    // Integrated loudness (LUFS)\n    const integrated = finalEnergies.reduce((a, b) => a + b, 0) / finalEnergies.length;\n    return linearToDb(Math.sqrt(integrated));\n}","// IndexedDB-backed storage helpers\nfunction openIDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n        const req = indexedDB.open('dunkadunka-storage', 1);\n        req.onupgradeneeded = () => {\n            const db = req.result;\n            if (!db.objectStoreNames.contains('kv')) {\n                db.createObjectStore('kv', { keyPath: 'key' });\n            }\n        };\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n    });\n}\n\nasync function setItem(key: string, value: string): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.put({ key, value });\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n        // mirror to sessionStorage for synchronous reads elsewhere\n        try { setItem(key, value); } catch { /* ignore */ }\n    } catch (e) {\n        console.error('setItem(idb) failed', e);\n    }\n}\n\nasync function getItem(key: string): Promise<string | null> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readonly');\n        const store = tx.objectStore('kv');\n        const req = store.get(key);\n        const res = await new Promise<any>((resolve, reject) => {\n            req.onsuccess = () => resolve(req.result);\n            req.onerror = () => reject(req.error);\n        });\n        return res?.value ?? null;\n    } catch (e) {\n        console.error('getItem(idb) failed', e);\n        return null;\n    }\n}\n\nasync function removeItem(key: string): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.delete(key);\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n    } catch (e) {\n        console.error('removeItem(idb) failed', e);\n    }\n}\n\nasync function clearStorage(): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.clear();\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n        // also clear sessionStorage\n        try { sessionStorage.clear(); } catch { /* ignore */ }\n    } catch (e) {\n        console.error('clearStorage(idb) failed', e);\n    }\n}\n\nasync function dumpStorage(): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readonly');\n        const store = tx.objectStore('kv');\n        const req = store.openCursor();\n        req.onsuccess = (event) => {\n            const cursor = (event.target as IDBRequest).result;\n            if (cursor) {\n                console.log(`Key: ${cursor.key}, Value: ${cursor.value.value}`);\n                cursor.continue();\n            }\n        };\n        req.onerror = () => {\n            console.error('dumpStorage(idb) failed', req.error);\n        };\n    } catch (e) {\n        console.error('dumpStorage(idb) failed', e);\n    }\n}\n\nexport const storage = {\n    setItem,\n    getItem,\n    removeItem,\n    clearStorage,\n    dumpStorage\n};","// Device settings for audio input/output selection\n\nconst INPUT_KEY = 'preferredAudioInputId';\nconst OUTPUT_KEY = 'preferredAudioOutputId';\n\nexport function openDeviceSettings(): void {\n    const modal = document.getElementById('deviceSettingsModal');\n    if (modal) {\n        modal.style.display = 'flex';\n        initDeviceSettings();\n    }\n}\n\nexport function closeDeviceSettings(): void {\n    const modal = document.getElementById('deviceSettingsModal');\n    if (modal) {\n        modal.style.display = 'none';\n    }\n}\n\nasync function ensureDeviceAccess(): Promise<void> {\n    try {\n        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;\n        // Request permission so labels are revealed\n        await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n    } catch (_) {\n        // Permission may be denied; device labels may be blank\n    }\n}\n\nexport async function refreshAudioDeviceList(): Promise<void> {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n        console.warn('MediaDevices API not available');\n        return;\n    }\n\n    await ensureDeviceAccess();\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const inputSel = document.getElementById('inputDeviceSelect') as HTMLSelectElement | null;\n    const outputSel = document.getElementById('outputDeviceSelect') as HTMLSelectElement | null;\n\n    if (!inputSel || !outputSel) return;\n\n    inputSel.innerHTML = '<option value=\"\">Default input</option>';\n    outputSel.innerHTML = '<option value=\"\">Default output</option>';\n\n    const inputId = localStorage.getItem(INPUT_KEY) || '';\n    const outputId = localStorage.getItem(OUTPUT_KEY) || '';\n\n    devices.forEach(d => {\n        if (d.kind === 'audioinput') {\n            const opt = document.createElement('option');\n            opt.value = d.deviceId;\n            opt.textContent = d.label || `Microphone (${d.deviceId.slice(0, 8)})`;\n            if (d.deviceId === inputId) opt.selected = true;\n            inputSel.appendChild(opt);\n        } else if (d.kind === 'audiooutput') {\n            const opt = document.createElement('option');\n            opt.value = d.deviceId;\n            opt.textContent = d.label || `Speaker (${d.deviceId.slice(0, 8)})`;\n            if (d.deviceId === outputId) opt.selected = true;\n            outputSel.appendChild(opt);\n        }\n    });\n\n    const note = document.getElementById('sinkSupportNote');\n    if (note) {\n        const sinkSupported = typeof HTMLMediaElement !== 'undefined' && 'setSinkId' in HTMLMediaElement.prototype;\n        note.textContent = sinkSupported\n            ? 'Output routing supported on this browser.'\n            : 'Output routing (setSinkId) not supported by this browser.';\n    }\n}\n\nasync function applyOutputDevice(deviceId: string): Promise<void> {\n    const router = document.getElementById('appOutputRouter') as HTMLAudioElement | null;\n    if (!router) return;\n\n    if ('setSinkId' in HTMLMediaElement.prototype) {\n        try {\n            await (router as any).setSinkId(deviceId || '');\n        } catch (e) {\n            console.warn('Failed to set sinkId:', e);\n        }\n    }\n}\n\nexport function saveDeviceSelections(): void {\n    const inputSel = document.getElementById('inputDeviceSelect') as HTMLSelectElement | null;\n    const outputSel = document.getElementById('outputDeviceSelect') as HTMLSelectElement | null;\n\n    if (!inputSel || !outputSel) return;\n\n    localStorage.setItem(INPUT_KEY, inputSel.value || '');\n    localStorage.setItem(OUTPUT_KEY, outputSel.value || '');\n\n    applyOutputDevice(outputSel.value || '');\n    closeDeviceSettings();\n}\n\nasync function initDeviceSettings(): Promise<void> {\n    await refreshAudioDeviceList();\n\n    // Persist immediately when changed\n    const inputSel = document.getElementById('inputDeviceSelect') as HTMLSelectElement | null;\n    const outputSel = document.getElementById('outputDeviceSelect') as HTMLSelectElement | null;\n\n    if (!inputSel || !outputSel) return;\n\n    inputSel.onchange = () => {\n        localStorage.setItem(INPUT_KEY, inputSel.value || '');\n    };\n    outputSel.onchange = () => {\n        localStorage.setItem(OUTPUT_KEY, outputSel.value || '');\n        applyOutputDevice(outputSel.value || '');\n    };\n}\n\n// Update list if devices change while modal is open\nif (navigator.mediaDevices && 'ondevicechange' in navigator.mediaDevices) {\n    navigator.mediaDevices.addEventListener('devicechange', () => {\n        const modal = document.getElementById('deviceSettingsModal');\n        if (modal && modal.style.display === 'flex') {\n            refreshAudioDeviceList();\n        }\n    });\n}\n\n// Apply preferred output on load (best-effort)\ndocument.addEventListener('DOMContentLoaded', () => {\n    const outId = localStorage.getItem(OUTPUT_KEY);\n    if (outId) applyOutputDevice(outId);\n});\n\n// Export functions to global scope for inline onclick handlers\n(window as any).openDeviceSettings = openDeviceSettings;\n(window as any).closeDeviceSettings = closeDeviceSettings;\n(window as any).refreshAudioDeviceList = refreshAudioDeviceList;\n(window as any).saveDeviceSelections = saveDeviceSelections;\n","import { computeFFT, computeFFTFromIR, db, FarinaImpulseResponse, rms, smoothFFT, twoChannelImpulseResponse } from \"./audio\";\nimport { nextPow2 } from \"./math\";\nimport { storage } from \"./storage\";\nimport \"./device-settings\";\n\nconsole.debug(\"App module loaded\");\n\nconst root = document.documentElement;\nconst uiColor = \"#0366d6\";\nroot.style.setProperty('--color', uiColor);\n\nlet tabCounter = 0;\nconst tabsContainer = document.getElementById('tabs') as HTMLElement;\nconst tabContents = document.getElementById('tab-contents') as HTMLElement;\nconst responseFileInput = document.getElementById('responseFile') as HTMLInputElement;\nconst referenceFileInput = document.getElementById('referenceFile') as HTMLInputElement;\nconst analyzeBtn = document.getElementById('analyzeBtn') as HTMLButtonElement;\n\ninterface Audio {\n    sampleRate: number;\n    data: Array<number>;\n    duration: number;\n    metadata?: {[Key: string]: string | number | null};\n}\n\n// Enable analyze button when response file is selected\nresponseFileInput.addEventListener('change', () => {\n    analyzeBtn.disabled = !responseFileInput.files?.length;\n});\n\n// Save state when the user attempts to close or reload the window\nwindow.addEventListener('beforeunload', (e: BeforeUnloadEvent) => {\n    try {\n        saveState();\n    } catch (err) {\n        console.error('Failed to save state on beforeunload:', err);\n    }\n    // If you want to prompt the user to confirm leaving (browser-dependent), uncomment:\n    // e.preventDefault();\n    // e.returnValue = '';\n});\n\n// Tab switching\ntabsContainer.addEventListener('click', (e: MouseEvent) => {\n    const target = e.target as HTMLElement;\n    \n    if (target.classList.contains('tab-close')) {\n        const tab = target.parentElement as HTMLElement;\n        const tabId = tab.dataset.tab;\n        if (tabId == 'upload') return;\n\n        console.debug('Closing tab', tabId);\n        tab.remove();\n        document.querySelector(`[data-content=\"${tabId}\"]`)?.remove();\n        storage.removeItem(`analysis-${tabId}`).catch(err => console.error('Failed to remove analysis from storage:', err));\n        \n        // Activate upload tab if current was closed\n        if (tab.classList.contains('active')) {\n            switchTab('upload');\n        }\n        saveState();\n        e.stopPropagation();\n    } else if (target.classList.contains('tab')) {\n        const tabId = target.dataset.tab;\n        if (tabId) {\n            switchTab(tabId);\n        }\n    }\n});\n\nfunction switchTab(tabId: string): void {\n    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));\n    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));\n    \n    document.querySelector(`[data-tab=\"${tabId}\"]`)?.classList.add('active');\n    document.querySelector(`[data-content=\"${tabId}\"]`)?.classList.add('active');\n}\n\nanalyzeBtn.addEventListener('click', async () => {\n    const responseFile = responseFileInput.files?.[0];\n    const referenceFile = referenceFileInput.files?.[0];\n\n    if (!responseFile) return;\n\n    analyzeBtn.disabled = true;\n    analyzeBtn.textContent = 'Analyzing...';\n\n    try {\n        const responseData = await loadAudioFile(responseFile);\n        const referenceData = referenceFile ? await loadAudioFile(referenceFile) : null;\n\n        createAnalysisTab(responseData, referenceData, responseFile.name, referenceFile?.name || null);\n    } catch (error) {\n        alert('Error analyzing files: ' + (error as Error).message);\n    } finally {\n        analyzeBtn.disabled = false;\n        analyzeBtn.textContent = 'Analyze Frequency Response';\n    }\n});\n\nasync function loadAudioFile(file: File): Promise<Audio> {\n    const headerBuffer = await file.slice(0, 256 * 1024).arrayBuffer();\n\n    function getExt(name: string) {\n        return (name.split('.').pop() || '').toLowerCase();\n    }\n\n    function parseWav(buf: ArrayBuffer) {\n        const dv = new DataView(buf);\n        function readStr(off: number, len: number) {\n            let s = '';\n            for (let i = 0; i < len; i++) s += String.fromCharCode(dv.getUint8(off + i));\n            return s;\n        }\n\n        if (readStr(0, 4) !== 'RIFF' || readStr(8, 4) !== 'WAVE') return null;\n\n        let offset = 12;\n        const info: any = {};\n        while (offset + 8 <= dv.byteLength) {\n            const id = readStr(offset, 4);\n            const size = dv.getUint32(offset + 4, true);\n            if (id === 'fmt ') {\n                info.audioFormat = dv.getUint16(offset + 8, true);\n                info.numChannels = dv.getUint16(offset + 10, true);\n                info.sampleRate = dv.getUint32(offset + 12, true);\n                info.byteRate = dv.getUint32(offset + 16, true);\n                info.blockAlign = dv.getUint16(offset + 20, true);\n                info.bitsPerSample = dv.getUint16(offset + 22, true);\n            } else if (id === 'data') {\n                info.dataChunkSize = size;\n            }\n            offset += 8 + size + (size % 2);\n        }\n        if (info.sampleRate && info.byteRate && info.dataChunkSize) {\n            info.duration = info.dataChunkSize / info.byteRate;\n        }\n        return info;\n    }\n\n    function parseMp3(buf: ArrayBuffer) {\n        const bytes = new Uint8Array(buf);\n        let offset = 0;\n        // Skip ID3v2 tag if present\n        if (bytes[0] === 0x49 && bytes[1] === 0x44 && bytes[2] === 0x33) {\n            const size = ((bytes[6] & 0x7f) << 21) | ((bytes[7] & 0x7f) << 14) | ((bytes[8] & 0x7f) << 7) | (bytes[9] & 0x7f);\n            offset = 10 + size;\n        }\n        // find first frame header\n        let headerIndex = -1;\n        for (let i = offset; i < bytes.length - 4; i++) {\n            if (bytes[i] === 0xFF && (bytes[i + 1] & 0xE0) === 0xE0) {\n                headerIndex = i;\n                break;\n            }\n        }\n        if (headerIndex < 0) return null;\n        const b1 = bytes[headerIndex + 1];\n        const b2 = bytes[headerIndex + 2];\n        const b3 = bytes[headerIndex + 3];\n\n        const versionBits = (b1 >> 3) & 0x03;\n        const layerBits = (b1 >> 1) & 0x03;\n        const bitrateBits = (b2 >> 4) & 0x0f;\n        const sampleRateBits = (b2 >> 2) & 0x03;\n        const channelMode = (b3 >> 6) & 0x03;\n\n        const versions: any = {\n            0: 'MPEG Version 2.5',\n            1: 'reserved',\n            2: 'MPEG Version 2 (ISO/IEC 13818-3)',\n            3: 'MPEG Version 1 (ISO/IEC 11172-3)'\n        };\n        const layers: any = {\n            0: 'reserved',\n            1: 'Layer III',\n            2: 'Layer II',\n            3: 'Layer I'\n        };\n\n        const sampleRates: any = {\n            3: [44100, 48000, 32000],\n            2: [22050, 24000, 16000],\n            0: [11025, 12000, 8000]\n        };\n        const versionKey = versionBits;\n        const layerKey = layerBits;\n\n        // bitrate tables (kbps)\n        const bitrateTable: any = {\n            // MPEG1 Layer III\n            '3_1': [0,32,40,48,56,64,80,96,112,128,160,192,224,256,320,0],\n            // MPEG2/2.5 Layer III\n            '0_1': [0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0],\n            '2_1': [0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0],\n            // fallback generic table for other layers/versions (best-effort)\n            '3_2': [0,32,48,56,64,80,96,112,128,160,192,224,256,320,384,0],\n            '3_3': [0,32,64,96,128,160,192,224,256,320,384,448,512,576,640,0]\n        };\n\n        const versionStr = versions[versionKey] || 'unknown';\n        const layerStr = layers[layerKey] || 'unknown';\n        let sampleRate = sampleRates[versionKey]?.[sampleRateBits] || null;\n\n        let bitrateKbps = 0;\n        const tbKey = `${versionKey}_${layerKey}`;\n        if (bitrateTable[tbKey]) {\n            bitrateKbps = bitrateTable[tbKey][bitrateBits] || 0;\n        } else if (bitrateTable['3_1'] && versionKey === 3 && layerKey === 1) {\n            bitrateKbps = bitrateTable['3_1'][bitrateBits] || 0;\n        }\n\n        const channels = channelMode === 3 ? 1 : 2;\n        let duration = null;\n        if (bitrateKbps > 0) {\n            duration = (bytes.length * 8) / (bitrateKbps * 1000);\n        }\n\n        return {\n            version: versionStr,\n            layer: layerStr,\n            bitrateKbps: bitrateKbps || null,\n            sampleRate,\n            channels,\n            duration\n        };\n    }\n\n    const ext = getExt(file.name);\n    const mime = file.type || 'unknown';\n    let metadata: {[Key: string]: string | number | null} = {};\n\n    const wavInfo = parseWav(headerBuffer);\n    if (wavInfo) {\n        metadata.format = 'wav';\n        metadata = Object.assign(metadata, wavInfo || {});\n    } else if (mime === 'audio/mpeg' || ext === 'mp3') {\n        const mp3Info = parseMp3(headerBuffer);\n        metadata.format = 'mp3';\n        metadata = Object.assign(metadata, mp3Info || {});\n    } else {\n        // best-effort: report file.type and extension and later rely on AudioContext decode\n        metadata.format = mime || ext || 'unknown';\n    }\n\n    console.log('Extracted file metadata:', metadata);\n    const arrayBuffer = await file.arrayBuffer();\n    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n    \n    console.log('Metadata:', metadata);\n    console.log('Loaded audio file with RMS of', db(rms(Array.from(audioBuffer.getChannelData(0)))));\n    return {\n        sampleRate: audioBuffer.sampleRate,\n        data: Array.from(audioBuffer.getChannelData(0)).map(x => x / 16384), // normalize 16-bit PCM\n        duration: audioBuffer.duration,\n        metadata\n    };\n}\n\n/**\n * Creates a new analysis tab in the UI and renders magnitude, phase and impulse-response plots for the provided audio.\n *\n * Description:\n * - Performs spectral and time-domain analysis: computes the FFT of the response, computes an impulse response (two-channel) and derives an FFT from that IR for reference comparison.\n * - Plots: Magnitude (dB) with raw and smoothed reference traces, Phase (degrees) with raw and smoothed traces, and the time-domain impulse response.\n * - Smoothing: applies smoothFFT to the reference frequency response using the smoothing parameters 1/6 and 1/48 (producing \"Magnitude (Smoothed)\" and \"Phase (Smoothed)\").\n *\n * Side effects:\n * - Mutates DOM by adding a closable tab button and corresponding tab content elements.\n * - Renders plots using Plotly into the created tab content.\n * - Persists analysis state to storage (IndexedDB/sessionStorage mirror).\n *\n * @param responseData - Audio buffer for the response file to analyze (Float32Array samples in Audio.data).\n * @param referenceData - Optional Audio buffer for the reference file; when provided, reference magnitude/phase and smoothed curves are computed and plotted.\n * @param filename - Display name for the response file (used in tab title and header).\n * @param referenceFilename - Optional display name for the reference file (appended to tab title when present).\n * @returns void\n */\nfunction createAnalysisTab(responseData: Audio, referenceData: Audio | null, filename: string, referenceFilename: string | null): void {\n    tabCounter++;\n    const tabId = `analysis-${tabCounter}`;\n    let shortName = filename.length > 20 ? filename.substring(0, 17) + '...' : filename;\n    if (referenceFilename != null) {\n        const shortReferenceName = referenceFilename?.length > 20 ? referenceFilename.substring(0, 17) + '...' : referenceFilename;\n        shortName += ' / ' + shortReferenceName;\n    }\n    // Create tab button\n    const tab = document.createElement('button');\n    tab.className = 'tab tab-closable';\n    tab.dataset.tab = tabId;\n    tab.innerHTML = `<span class=\"tab-icon-analysis\"></span>${shortName} <span class=\"tab-close\"></span>`;\n    tabsContainer.appendChild(tab);\n\n    // Create tab content\n    const content = document.createElement('div');\n    content.className = 'tab-content';\n    content.dataset.content = tabId;\n    content.innerHTML = `\n        <div class=\"loose-container\">\n            <div id=\"plot-${tabId}-magnitude\" class=\"plot-medium\"></div>\n            <div id=\"plot-${tabId}-phase\" class=\"plot-medium\"></div>\n            <div id=\"plot-${tabId}-ir\" class=\"plot-medium\"></div>\n            <div class=\"analysis-description\" style=\"margin-bottom:12px; font-size:0.95rem; color:#24292e;\">\n                <p><strong>Analysis:</strong> Magnitude, phase and impulseresponse computed from the uploaded response (and optional reference) via FFT and a twochannel impulse response.</p>\n                <p><strong>Smoothing:</strong> Fractionaloctave smoothing applied to the reference response (1/6 octave).</p>\n            </div>\n        </div>\n    `;\n    tabContents.appendChild(content);\n\n    // Switch to new tab\n    switchTab(tabId);\n\n\n    // Compute and plot FFTs\n    console.log('Analyzing response file:', filename);\n    const data = new Float32Array(responseData.data);\n    \n    const responseFFT = computeFFT(data);\n    const tracesMagnitude: any[] = [{\n        x: responseFFT.frequency,\n        y: db(responseFFT.magnitude),\n        type: 'scatter',\n        mode: 'lines',\n        name: 'Measurement signal',\n        line: { color: '#0366d6', width: 2 }\n    }];\n    const tracesPhase: any[] = [];\n    const tracesIR: any[] = [];\n\n    let irPeakAt = 0;\n\n    if (referenceData) {\n        const referenceFFT = computeFFT(referenceData.data);\n        tracesMagnitude.push({\n            x: referenceFFT.frequency,\n            y: db(referenceFFT.magnitude),\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Reference signal',\n            line: { color: '#0366d6', width: 2 }\n        });\n        const ir = twoChannelImpulseResponse(responseData.data, referenceData ? referenceData.data : new Float32Array(responseData.data.length));\n        const farina_ir = FarinaImpulseResponse(responseData.data, referenceData ? referenceData.data : new Float32Array(responseData.data.length));\n\n        console.log('Impulse response peak at', ir.peakAt);\n        irPeakAt = ir.peakAt;\n\n        tracesIR.push({\n            x: ir.t,\n            y: db(ir.ir.map(v => Math.abs(v))),        \n            type: 'scatter',\n            mode: 'lines',\n            name: 'Dual-FFT Impulse Response',\n            line: { color: '#d73a49', width: 2 }\n        });\n        tracesIR.push({\n            x: farina_ir.t,\n            y: db(farina_ir.ir.map(v => Math.abs(v))),        \n            type: 'scatter',\n            mode: 'lines',\n            name: 'Farina Impulse Response',\n            line: { color: '#d73a49', width: 2 }\n        });\n        const transferFunction = computeFFTFromIR(ir, 100);\n        const transferFunctionF = computeFFTFromIR(farina_ir, 100);\n        // const dreferenceFFT = twoChannelFFT(responseData.data, referenceData.data, nextPow2(referenceData.data.length), -5627);\n        const smoothedFreqResponse = smoothFFT(transferFunction, 1/6, 1/48);\n\n        tracesMagnitude.push({\n            x: transferFunction.frequency,\n            y: db(transferFunction.magnitude),\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Dual-FFT Transfer Function (Raw)',\n            line: { color: '#d73a4933', width: 1 }\n        });\n        tracesMagnitude.push({\n            x: transferFunctionF.frequency,\n            y: db(transferFunctionF.magnitude),\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Farina Transfer Function',\n            line: { color: '#2600ff', width: 1 }\n        });\n        tracesMagnitude.push({\n            x: smoothedFreqResponse.frequency,\n            y: smoothedFreqResponse.magnitude,\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Dual-FFT Transfer Function (Smoothed)',\n            line: { color: '#d73a49', width: 2 }\n        });\n\n        tracesPhase.push({\n            x: transferFunction.frequency,\n            y: transferFunction.phase,\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Dual-FFT Transfer Function (Raw)',\n            line: { color: '#d73a4933', width: 1 }\n        });\n        tracesPhase.push({\n            x: smoothedFreqResponse.frequency,\n            y: smoothedFreqResponse.phase,\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Dual-FFT Transfer Function (Smoothed)',\n            line: { color: '#d73a49', width: 2 }\n        });\n    }\n\n    const plotSettings: {[key: string]: any} = {\n        plotGlPixelRatio: 2, // For better clarity on high-DPI screens\n        legend: { x: 0.98, y: 0.02, xanchor: 'right', yanchor: 'bottom' },\n        plot_bgcolor: '#fafbfc',\n        paper_bgcolor: '#fff',\n        staticPlot: false, // Enable interactivity\n        dragmode: 'pan',\n        showAxisDragHandles: true,\n        showAxisRangeEntryBoxes: true,\n        axisDragOnHover: true,\n        tightenLats: true,\n        font: {\n            family: \"'Newsreader', Georgia, 'Times New Roman', Times, serif\",\n        },\n    };\n\n    const layoutMagnitude = {\n        title: 'Magnitude Analysis',    \n        xaxis: { \n            title: 'Frequency (Hz)', \n            type: 'log',\n            gridcolor: '#e1e4e8',\n            range: [Math.log10(20), Math.log10(20000)],\n            tickformat: '.0f',\n\n        },\n        yaxis: { \n            title: 'Magnitude (dB)',\n            gridcolor: '#e1e4e8',\n            rangemode: 'tozero',\n            range: [-90, 0],\n        },\n        ...plotSettings\n    };\n\n    (window as any).Plotly.newPlot(`plot-${tabId}-magnitude`, tracesMagnitude, layoutMagnitude, { responsive: true });\n\n    const layoutPhase = {\n        title: 'Phase Analysis',\n        xaxis: { \n            title: 'Frequency (Hz)', \n            type: 'log',\n            gridcolor: '#e1e4e8',\n            range: [Math.log10(20), Math.log10(20000)],\n            tickformat: '.0f',\n        },\n        yaxis: { \n            title: 'Phase (degrees)',\n            gridcolor: '#e1e4e8',\n            automargin: true,\n            range: [-720, 720],\n        },\n        ...plotSettings\n    };\n\n    (window as any).Plotly.newPlot(`plot-${tabId}-phase`, tracesPhase, layoutPhase, { responsive: true });\n\n    const layoutIR = {\n        title: 'Impulse response',\n        xaxis: { \n            title: 'Amplitude', \n            gridcolor: '#e1e4e8',\n            range: [-0.05 + irPeakAt / responseData.sampleRate, 0.05 + irPeakAt / responseData.sampleRate],\n        },\n        yaxis: { \n            title: 'Phase (degrees)',\n            gridcolor: '#e1e4e8',\n            automargin: true,\n        },\n        ...plotSettings\n    };\n\n    (window as any).Plotly.newPlot(`plot-${tabId}-ir`, tracesIR, layoutIR, { responsive: true });\n    saveState();\n\n    // Persist analysis using IndexedDB (mirrored to sessionStorage for compatibility)\n    storage.setItem(`${tabId}`, JSON.stringify({\n        filename,\n        referenceFilename,\n        responseData,\n        referenceData,\n    })).catch(err => console.error('Failed to persist analysis:', err));\n}\n\n// Save and load state from sessionStorage\nfunction saveState(): void {\n    const tabs = Array.from(document.querySelectorAll('.tab[data-tab]')).map(tab => ({\n        id: (tab as HTMLElement).dataset.tab,\n        name: (tab as HTMLElement).textContent?.replace('', '').trim()\n    }));\n    \n    storage.setItem('tabs', JSON.stringify(tabs));\n    console.log('Saved state with tabs:', tabs);\n}\n\nasync function loadState(): Promise<void> {\n    try {\n        const savedTabs = await storage.getItem('tabs');\n        if (!savedTabs) return;\n        const tabs = JSON.parse(savedTabs);\n        console.log('Loading saved tabs:', tabs);\n\n        for (const tab of tabs as { id: string; name: string }[]) {\n            // Call createAnalysisTab for each tab\n            const raw = await storage.getItem(`${tab.id}`);\n            const analysisData = raw ? JSON.parse(raw) : null;\n            if (analysisData) {\n                createAnalysisTab(analysisData.responseData, analysisData.referenceData, analysisData.filename, analysisData.referenceFilename);\n            }\n        }\n        // Tabs will be recreated when user analyzes files again\n    } catch (e) {\n        console.error('Failed to load saved state:', e);\n    }\n}\n\n// Load state on page load\nloadState();\n\nfunction max(arg0: Float32Array<ArrayBuffer>): any {\n    throw new Error(\"Function not implemented.\");\n}\n"]}