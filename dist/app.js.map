{"version":3,"sources":["/workspaces/dunkadunka.se/dist/app.js","../src/math.ts","../src/fft.ts","../src/fractional_octave_smoothing.ts","../src/audio.ts","../src/storage.ts","../src/app.ts"],"names":["console","debug","logspace","start","end","num","logStart","Math","log10","logEnd","logStep","Array","from","length","_","i","pow","linspace","step","closest","arr","curr","diff","abs","index","val","newDiff","average","array","reduce","a","b","re","im","sqrt","FFT","size","Error","_csize","table","angle","PI","cos","sin","power","t","_width","_bitrev","j","shift","revShift","_out","_data","_inv","fromComplexArray","complex","storage","res","createComplexArray","toComplexArray","input","completeSpectrum","spectrum","half","transform","out","data","_transform4","realTransform","_realTransform4","inverseTransform","width","len","outOff","bitrev","off","_singleTransform2","_singleTransform4","inv","quarterLen","limit","k","A","B","C","D","Ar","Ai","Br","Bi","Cr","Ci","Dr","Di","MAr","MAi","tableBr","tableBi","MBr","MBi","tableCr","tableCi","MCr","MCi","tableDr","tableDi","MDr","MDi","T0r","T0i","T1r","T1i","T2r","T2i","T3r","T3i","FAr","FAi","FCr","FCi","FBr","FBi","FDr","FDi","evenR","evenI","oddR","oddI","leftR","leftI","rightR","rightI","step2","step3","_singleRealTransform2","_singleRealTransform4","halfLen","hquarterLen","ST0r","ST0i","ST1r","ST1i","ST2r","ST2i","ST3r","ST3i","SFAr","SFAi","SFBr","SFBi","SA","SB","getFractionalOctaveFrequencies","fraction","f_low","f_high","fftSize","num_points","round","frequencies","frequency_resolution","Set","fractionalOctaveSmoothing","frequencyData","frequenciesAll","smoothedData","Float32Array","n","factor","p","sum","as","slice","min","window","db","value","isArray","map","v","smoothFFT","fftData","resolution","frequency","magnitude","phase","smoothedMagnitude","fractionalFrequencies","smoothed","computeFFT","ceil","log2","log","fft","frame","SQRT2","atan2","frequencyResolution","fftCorrelation","x","y","lenX","lenY","fullLen","nextPow2","xP","yP","set","ar","ai","br","bi","corr","Float64Array","sumX2","sumY2","denom","normalized","lags","Int32Array","peakIdx","peakVal","Infinity","estimatedLag","estimatedLagSamples","estimatedLagIndex","peakCorrelation","raw","nfft","twoChannelFFT","dataArray","reference","windowType","referencePadded","lag","offset","reference_","signal_","signalMags","referenceMags","h","i_50","phase_signal","phase_reference","sphase","unwrapPhase","correction","floor","phases","N","delta","openIDB","Promise","resolve","reject","req","indexedDB","open","onupgradeneeded","result","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","onerror","error","setItem","key","tx","store","e","transaction","objectStore","put","oncomplete","onabort","getItem","get","removeItem","delete","clearStorage","clear","sessionStorage","dumpStorage","openCursor","event","cursor","target","continue","root","document","documentElement","uiColor","style","setProperty","tabCounter","tabsContainer","getElementById","tabContents","responseFileInput","referenceFileInput","analyzeBtn","addEventListener","disabled","files","classList","tab","parentElement","tabId","dataset","remove","querySelector","catch","err","switchTab","stopPropagation","querySelectorAll","forEach","c","add","responseFile","referenceFile","responseData","referenceData","textContent","loadAudioFile","createAnalysisTab","name","alert","message","file","headerBuffer","ext","mime","metadata","wavInfo","mp3Info","arrayBuffer","audioContext","audioBuffer","getExt","split","pop","toLowerCase","parseWav","buf","dv","DataView","readStr","s","String","fromCharCode","getUint8","info","byteLength","id","getUint32","audioFormat","getUint16","numChannels","sampleRate","byteRate","blockAlign","bitsPerSample","dataChunkSize","duration","parseMp3","sampleRates","bytes","Uint8Array","headerIndex","b1","b2","b3","versionBits","layerBits","bitrateBits","sampleRateBits","channelMode","versions","layers","versionKey","layerKey","bitrateTable","versionStr","layerStr","bitrateKbps","tbKey","channels","version","layer","type","format","Object","assign","AudioContext","webkitAudioContext","decodeAudioData","getChannelData","filename","referenceFilename","shortName","substring","shortReferenceName","createElement","className","innerHTML","appendChild","content","responseFFT","traces","mode","line","color","trace1s","referenceFFT","smoothedFreqResponse","push","layout","title","plotGlPixelRatio","xaxis","gridcolor","range","yaxis","legend","plot_bgcolor","paper_bgcolor","font","family","Plotly","newPlot","responsive","layouta","staticPlot","dragmode","showAxisDragHandles","showAxisRangeEntryBoxes","axisDragOnHover","saveState","JSON","stringify","tabs","replace","trim","loadState","savedTabs","analysisData","parse"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// src/math.ts\nconsole.debug(\"Math module loaded\");\nfunction logspace(start, end, num) {\n  const logStart = Math.log10(start);\n  const logEnd = Math.log10(end);\n  const logStep = (logEnd - logStart) / (num - 1);\n  return Array.from({ length: num }, (_, i) => Math.pow(10, logStart + i * logStep));\n}\nfunction linspace(start, end, num) {\n  if (num === 1) return [start];\n  const step = (end - start) / (num - 1);\n  return Array.from({ length: num }, (_, i) => start + i * step);\n}\nfunction closest(num, arr) {\n  let curr = arr[0];\n  let diff = Math.abs(num - curr);\n  let index = 0;\n  for (let val = 0; val < arr.length; val++) {\n    const newDiff = Math.abs(num - arr[val]);\n    if (newDiff < diff) {\n      diff = newDiff;\n      curr = arr[val];\n      index = val;\n    }\n  }\n  return index;\n}\nvar average = (array) => array.reduce((a, b) => a + b) / array.length;\nvar abs = (re, im = 0) => Math.sqrt(re * re + im * im);\n\n// src/fft.ts\nconsole.debug(\"FFT module loaded\");\nvar FFT = class {\n  constructor(size) {\n    this.size = size | 0;\n    if (this.size <= 1 || (this.size & this.size - 1) !== 0)\n      throw new Error(\"FFT size must be a power of two and bigger than 1\");\n    this._csize = size << 1;\n    const table = new Array(this.size * 2);\n    for (let i = 0; i < table.length; i += 2) {\n      const angle = Math.PI * i / this.size;\n      table[i] = Math.cos(angle);\n      table[i + 1] = -Math.sin(angle);\n    }\n    this.table = table;\n    let power = 0;\n    for (let t = 1; this.size > t; t <<= 1)\n      power++;\n    this._width = power % 2 === 0 ? power - 1 : power;\n    this._bitrev = new Array(1 << this._width);\n    for (let j = 0; j < this._bitrev.length; j++) {\n      this._bitrev[j] = 0;\n      for (let shift = 0; shift < this._width; shift += 2) {\n        const revShift = this._width - shift - 2;\n        this._bitrev[j] |= (j >>> shift & 3) << revShift;\n      }\n    }\n    this._out = null;\n    this._data = null;\n    this._inv = 0;\n  }\n  fromComplexArray(complex, storage2) {\n    const res = storage2 || new Array(complex.length >>> 1);\n    for (let i = 0; i < complex.length; i += 2)\n      res[i >>> 1] = complex[i];\n    return res;\n  }\n  createComplexArray() {\n    const res = new Array(this._csize);\n    for (let i = 0; i < res.length; i++)\n      res[i] = 0;\n    return res;\n  }\n  toComplexArray(input, storage2) {\n    const res = storage2 || this.createComplexArray();\n    for (let i = 0; i < res.length; i += 2) {\n      res[i] = input[i >>> 1];\n      res[i + 1] = 0;\n    }\n    return res;\n  }\n  completeSpectrum(spectrum) {\n    const size = this._csize;\n    const half = size >>> 1;\n    for (let i = 2; i < half; i += 2) {\n      spectrum[size - i] = spectrum[i];\n      spectrum[size - i + 1] = -spectrum[i + 1];\n    }\n  }\n  transform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 0;\n    this._transform4();\n    this._out = null;\n    this._data = null;\n  }\n  realTransform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 0;\n    this._realTransform4();\n    this._out = null;\n    this._data = null;\n  }\n  inverseTransform(out, data) {\n    if (out === data)\n      throw new Error(\"Input and output buffers must be different\");\n    this._out = out;\n    this._data = data;\n    this._inv = 1;\n    this._transform4();\n    for (let i = 0; i < out.length; i++)\n      out[i] /= this.size;\n    this._out = null;\n    this._data = null;\n  }\n  // radix-4 implementation\n  //\n  // NOTE: Uses of `var` are intentional for older V8 version that do not\n  // support both `let compound assignments` and `const phi`\n  _transform4() {\n    const out = this._out;\n    const size = this._csize;\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    let outOff;\n    let t;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform2(outOff, off, step);\n      }\n    } else {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform4(outOff, off, step);\n      }\n    }\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      const quarterLen = len >>> 2;\n      for (outOff = 0; outOff < size; outOff += len) {\n        const limit = outOff + quarterLen;\n        for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n          const A = i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n          const MAr = Ar;\n          const MAi = Ai;\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n          const FCr = T0r - T2r;\n          const FCi = T0i - T2i;\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n          const FDr = T1r - T3i;\n          const FDi = T1i + T3r;\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          out[D] = FDr;\n          out[D + 1] = FDi;\n        }\n      }\n    }\n  }\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  _singleTransform2(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const evenR = data[off];\n    const evenI = data[off + 1];\n    const oddR = data[off + step];\n    const oddI = data[off + step + 1];\n    const leftR = evenR + oddR;\n    const leftI = evenI + oddI;\n    const rightR = evenR - oddR;\n    const rightI = evenI - oddI;\n    out[outOff] = leftR;\n    out[outOff + 1] = leftI;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = rightI;\n  }\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  _singleTransform4(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n    const Ar = data[off];\n    const Ai = data[off + 1];\n    const Br = data[off + step];\n    const Bi = data[off + step + 1];\n    const Cr = data[off + step2];\n    const Ci = data[off + step2 + 1];\n    const Dr = data[off + step3];\n    const Di = data[off + step3 + 1];\n    const T0r = Ar + Cr;\n    const T0i = Ai + Ci;\n    const T1r = Ar - Cr;\n    const T1i = Ai - Ci;\n    const T2r = Br + Dr;\n    const T2i = Bi + Di;\n    const T3r = inv * (Br - Dr);\n    const T3i = inv * (Bi - Di);\n    const FAr = T0r + T2r;\n    const FAi = T0i + T2i;\n    const FBr = T1r + T3i;\n    const FBi = T1i - T3r;\n    const FCr = T0r - T2r;\n    const FCi = T0i - T2i;\n    const FDr = T1r - T3i;\n    const FDi = T1i + T3r;\n    out[outOff] = FAr;\n    out[outOff + 1] = FAi;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = FCi;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n  // Real input radix-4 implementation\n  _realTransform4() {\n    const out = this._out;\n    const size = this._csize;\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    let outOff;\n    let t;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n      }\n    } else {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n      }\n    }\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      const halfLen = len >>> 1;\n      const quarterLen = halfLen >>> 1;\n      const hquarterLen = quarterLen >>> 1;\n      for (outOff = 0; outOff < size; outOff += len) {\n        for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n          const A = outOff + i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n          const MAr = Ar;\n          const MAi = Ai;\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          if (i === 0) {\n            const FCr = T0r - T2r;\n            const FCi = T0i - T2i;\n            out[C] = FCr;\n            out[C + 1] = FCi;\n            continue;\n          }\n          if (i === hquarterLen)\n            continue;\n          const ST0r = T1r;\n          const ST0i = -T1i;\n          const ST1r = T0r;\n          const ST1i = -T0i;\n          const ST2r = -inv * T3i;\n          const ST2i = -inv * T3r;\n          const ST3r = -inv * T2i;\n          const ST3i = -inv * T2r;\n          const SFAr = ST0r + ST2r;\n          const SFAi = ST0i + ST2i;\n          const SFBr = ST1r + ST3i;\n          const SFBi = ST1i - ST3r;\n          const SA = outOff + quarterLen - i;\n          const SB = outOff + halfLen - i;\n          out[SA] = SFAr;\n          out[SA + 1] = SFAi;\n          out[SB] = SFBr;\n          out[SB + 1] = SFBi;\n        }\n      }\n    }\n  }\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  _singleRealTransform2(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const evenR = data[off];\n    const oddR = data[off + step];\n    const leftR = evenR + oddR;\n    const rightR = evenR - oddR;\n    out[outOff] = leftR;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = 0;\n  }\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  _singleRealTransform4(outOff, off, step) {\n    const out = this._out;\n    const data = this._data;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n    const Ar = data[off];\n    const Br = data[off + step];\n    const Cr = data[off + step2];\n    const Dr = data[off + step3];\n    const T0r = Ar + Cr;\n    const T1r = Ar - Cr;\n    const T2r = Br + Dr;\n    const T3r = inv * (Br - Dr);\n    const FAr = T0r + T2r;\n    const FBr = T1r;\n    const FBi = -T3r;\n    const FCr = T0r - T2r;\n    const FDr = T1r;\n    const FDi = T3r;\n    out[outOff] = FAr;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = 0;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n};\n\n// src/fractional_octave_smoothing.ts\nconsole.debug(\"Fractional Octave Smoothing module loaded\");\nfunction getFractionalOctaveFrequencies(fraction, f_low = 20, f_high = 24e3, fftSize) {\n  if (fraction <= 0) {\n    throw new Error(\"Fraction must be greater than 0\");\n  }\n  if (f_low <= 0 || f_high <= 0) {\n    throw new Error(\"Frequencies must be greater than 0\");\n  }\n  if (f_low >= f_high) {\n    throw new Error(\"f_low must be less than f_high\");\n  }\n  const num_points = Math.round((Math.log10(f_high) - Math.log10(f_low)) / fraction) + 1;\n  let frequencies = logspace(f_low, f_high, num_points);\n  const frequency_resolution = 48e3 / fftSize;\n  for (let i = 0; i < frequencies.length; i++) {\n    frequencies[i] = Math.round(frequencies[i] / frequency_resolution) * frequency_resolution;\n  }\n  frequencies = Array.from(new Set(frequencies));\n  return frequencies;\n}\nfunction fractionalOctaveSmoothing(frequencyData, fraction, frequencies) {\n  const frequenciesAll = linspace(0, 48e3 / 2, frequencyData.length);\n  const frequency_resolution = 48e3 / frequencyData.length;\n  const smoothedData = new Float32Array(frequencies.length);\n  const n = frequencyData.length;\n  const factor = Math.pow(2, 0.5 * fraction) - Math.pow(0.5, 0.5 * fraction);\n  for (let p = 0; p < frequencies.length; p++) {\n    const i = closest(frequencies[p], frequenciesAll);\n    let sum = 0;\n    const width = Math.round(0.5 * factor * (n * 0.5 - Math.abs(n * 0.5 - i)));\n    if (width === 0) {\n      sum = frequencyData[i];\n    } else {\n      const as = frequencyData.slice(Math.round(i - width + 1), Math.min(Math.round(i + width), n - 1));\n      sum = average(as);\n    }\n    smoothedData[p] = sum;\n  }\n  return smoothedData;\n}\n\n// src/audio.ts\nconsole.debug(\"Audio module loaded\");\nwindow.FFT = FFT;\nfunction db(value) {\n  if (Array.isArray(value)) {\n    return value.map((v) => 20 * Math.log10(v + 1e-12));\n  } else {\n    return 20 * Math.log10(value + 1e-12);\n  }\n}\nfunction smoothFFT(fftData, fraction, resolution) {\n  const { frequency, magnitude, phase, fftSize } = fftData;\n  const smoothedMagnitude = new Float32Array(magnitude.length);\n  const fractionalFrequencies = getFractionalOctaveFrequencies(resolution, 20, 24e3, fftSize);\n  const smoothed = fractionalOctaveSmoothing(magnitude, fraction, fractionalFrequencies);\n  return {\n    frequency: fractionalFrequencies,\n    magnitude: Array.from(smoothed),\n    phase,\n    // phase remains unchanged\n    fftSize\n  };\n}\nfunction computeFFT(data, fftSize = null) {\n  fftSize ?? (fftSize = 2 ** Math.ceil(Math.log2(data.length)));\n  console.log(`Computing FFT with ${fftSize} bins for data length ${data.length}`);\n  const fft = new FFT(fftSize);\n  const out = fft.createComplexArray();\n  const frame = new Float32Array(fftSize);\n  for (let i = 0; i < fftSize; i++) {\n    frame[i] = (data[i] || 0) * 1;\n  }\n  fft.realTransform(out, frame);\n  const frequency = [];\n  const magnitude = [];\n  const phase = [];\n  for (let i = 0; i < fftSize / 2; i++) {\n    const re = out[2 * i];\n    const im = out[2 * i + 1];\n    magnitude[i] = abs(re, im) * Math.SQRT2;\n    phase[i] = Math.atan2(im, re);\n  }\n  const frequencyResolution = 48e3 / fftSize;\n  for (let i = 0; i < fftSize / 2; i++) {\n    frequency[i] = i * frequencyResolution;\n  }\n  return {\n    frequency,\n    magnitude,\n    phase,\n    fftSize\n  };\n}\nfunction fftCorrelation(x, y) {\n  const lenX = x.length;\n  const lenY = y.length;\n  const fullLen = lenX + lenY - 1;\n  const nextPow2 = (v) => {\n    let p = 1;\n    while (p < v) p <<= 1;\n    return p;\n  };\n  const n = nextPow2(fullLen);\n  const xP = new Float32Array(n);\n  const yP = new Float32Array(n);\n  xP.set(x, 0);\n  yP.set(y, 0);\n  const fft = new FFT(n);\n  const A = fft.createComplexArray();\n  const B = fft.createComplexArray();\n  fft.realTransform(A, xP);\n  fft.realTransform(B, yP);\n  if (typeof fft.completeSpectrum === \"function\") {\n    fft.completeSpectrum(A);\n    fft.completeSpectrum(B);\n  }\n  const C = fft.createComplexArray();\n  for (let k = 0; k < n; k++) {\n    const ar = A[2 * k], ai = A[2 * k + 1];\n    const br = B[2 * k], bi = B[2 * k + 1];\n    C[2 * k] = ar * br + ai * bi;\n    C[2 * k + 1] = ai * br - ar * bi;\n  }\n  const out = fft.createComplexArray();\n  fft.inverseTransform(out, C);\n  const corr = new Float64Array(fullLen);\n  for (let i = 0; i < fullLen; i++) {\n    corr[i] = out[2 * i] / n;\n  }\n  let sumX2 = 0, sumY2 = 0;\n  for (let i = 0; i < lenX; i++) sumX2 += x[i] * x[i];\n  for (let i = 0; i < lenY; i++) sumY2 += y[i] * y[i];\n  const denom = Math.sqrt(sumX2 * sumY2);\n  const normalized = new Float64Array(fullLen);\n  if (denom > 0) {\n    for (let i = 0; i < fullLen; i++) normalized[i] = corr[i] / denom;\n  } else {\n    for (let i = 0; i < fullLen; i++) normalized[i] = 0;\n  }\n  const lags = new Int32Array(fullLen);\n  for (let i = 0; i < fullLen; i++) lags[i] = i - (lenY - 1);\n  let peakIdx = 0;\n  let peakVal = -Infinity;\n  for (let i = 0; i < fullLen; i++) {\n    if (normalized[i] > peakVal) {\n      peakVal = normalized[i];\n      peakIdx = i;\n    }\n  }\n  const estimatedLag = lags[peakIdx];\n  return {\n    corr: normalized,\n    lags,\n    estimatedLagSamples: estimatedLag,\n    estimatedLagIndex: peakIdx,\n    peakCorrelation: peakVal,\n    raw: corr,\n    nfft: n\n  };\n}\nfunction twoChannelFFT(dataArray, reference, fftSize, windowType) {\n  const referencePadded = new Float32Array(fftSize);\n  const lag = fftCorrelation(dataArray, reference);\n  console.log(\"Estimated lag (samples):\", lag.estimatedLagSamples, \"Peak correlation:\", lag.peakCorrelation);\n  console.log(\"Lag index:\", lag.estimatedLagIndex);\n  console.log(\"Lags array:\", referencePadded.length, lag.lags);\n  const offset = reference.length + lag.estimatedLagSamples - 1;\n  console.log(\"Applying offset of\", offset, \"samples for alignment\");\n  referencePadded.set(reference.slice(0, Math.min(reference.length, fftSize) - offset), offset);\n  const reference_ = computeFFT(referencePadded);\n  const signal_ = computeFFT(dataArray);\n  const signalMags = signal_.magnitude.map((v) => 20 * Math.log10(v === 0 ? 1e-20 : v));\n  const referenceMags = reference_.magnitude.map((v) => 20 * Math.log10(v === 0 ? 1e-20 : v));\n  const h = referenceMags.map((v, i) => signalMags[i] - v);\n  const frequency = linspace(0, 48e3 / 2, h.length);\n  const i_50 = closest(50, frequency);\n  const phase_signal = signal_.phase;\n  const phase_reference = reference_.phase;\n  const sphase = unwrapPhase(phase_signal.map((v, i) => v - phase_reference[i]));\n  const correction = Math.floor(sphase[i_50] / (2 * Math.PI) + 0.5) * (2 * Math.PI);\n  const phase = sphase.map((v) => v - correction);\n  function unwrapPhase(phases) {\n    const N = phases.length;\n    const out = Array.from(new Float32Array(N));\n    if (N === 0) return out;\n    out[0] = phases[0];\n    let offset2 = 0;\n    for (let i = 1; i < N; i++) {\n      let delta = phases[i] - phases[i - 1];\n      if (delta > Math.PI) {\n        offset2 -= 2 * Math.PI;\n      } else if (delta < -Math.PI) {\n        offset2 += 2 * Math.PI;\n      }\n      out[i] = phases[i] + offset2;\n    }\n    return out;\n  }\n  return {\n    frequency,\n    magnitude: h,\n    phase,\n    fftSize\n  };\n}\n\n// src/storage.ts\nfunction openIDB() {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.open(\"dunkadunka-storage\", 1);\n    req.onupgradeneeded = () => {\n      const db2 = req.result;\n      if (!db2.objectStoreNames.contains(\"kv\")) {\n        db2.createObjectStore(\"kv\", { keyPath: \"key\" });\n      }\n    };\n    req.onsuccess = () => resolve(req.result);\n    req.onerror = () => reject(req.error);\n  });\n}\nasync function setItem(key, value) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.put({ key, value });\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n    try {\n      setItem(key, value);\n    } catch {\n    }\n  } catch (e) {\n    console.error(\"setItem(idb) failed\", e);\n  }\n}\nasync function getItem(key) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readonly\");\n    const store = tx.objectStore(\"kv\");\n    const req = store.get(key);\n    const res = await new Promise((resolve, reject) => {\n      req.onsuccess = () => resolve(req.result);\n      req.onerror = () => reject(req.error);\n    });\n    return res?.value ?? null;\n  } catch (e) {\n    console.error(\"getItem(idb) failed\", e);\n    return null;\n  }\n}\nasync function removeItem(key) {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.delete(key);\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n  } catch (e) {\n    console.error(\"removeItem(idb) failed\", e);\n  }\n}\nasync function clearStorage() {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readwrite\");\n    const store = tx.objectStore(\"kv\");\n    store.clear();\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n      tx.onabort = () => reject(tx.error);\n    });\n    try {\n      sessionStorage.clear();\n    } catch {\n    }\n  } catch (e) {\n    console.error(\"clearStorage(idb) failed\", e);\n  }\n}\nasync function dumpStorage() {\n  try {\n    const db2 = await openIDB();\n    const tx = db2.transaction(\"kv\", \"readonly\");\n    const store = tx.objectStore(\"kv\");\n    const req = store.openCursor();\n    req.onsuccess = (event) => {\n      const cursor = event.target.result;\n      if (cursor) {\n        console.log(`Key: ${cursor.key}, Value: ${cursor.value.value}`);\n        cursor.continue();\n      }\n    };\n    req.onerror = () => {\n      console.error(\"dumpStorage(idb) failed\", req.error);\n    };\n  } catch (e) {\n    console.error(\"dumpStorage(idb) failed\", e);\n  }\n}\nvar storage = {\n  setItem,\n  getItem,\n  removeItem,\n  clearStorage,\n  dumpStorage\n};\n\n// src/app.ts\nconsole.debug(\"App module loaded\");\nvar root = document.documentElement;\nvar uiColor = \"#0366d6\";\nroot.style.setProperty(\"--color\", uiColor);\nvar tabCounter = 0;\nvar tabsContainer = document.getElementById(\"tabs\");\nvar tabContents = document.getElementById(\"tab-contents\");\nvar responseFileInput = document.getElementById(\"responseFile\");\nvar referenceFileInput = document.getElementById(\"referenceFile\");\nvar analyzeBtn = document.getElementById(\"analyzeBtn\");\nresponseFileInput.addEventListener(\"change\", () => {\n  analyzeBtn.disabled = !responseFileInput.files?.length;\n});\nstorage.dumpStorage();\ntabsContainer.addEventListener(\"click\", (e) => {\n  const target = e.target;\n  if (target.classList.contains(\"tab-close\")) {\n    const tab = target.parentElement;\n    const tabId = tab.dataset.tab;\n    if (tabId == \"upload\") return;\n    console.debug(\"Closing tab\", tabId);\n    tab.remove();\n    document.querySelector(`[data-content=\"${tabId}\"]`)?.remove();\n    storage.removeItem(`analysis-${tabId}`).catch((err) => console.error(\"Failed to remove analysis from storage:\", err));\n    if (tab.classList.contains(\"active\")) {\n      switchTab(\"upload\");\n    }\n    e.stopPropagation();\n  } else if (target.classList.contains(\"tab\")) {\n    const tabId = target.dataset.tab;\n    if (tabId) {\n      switchTab(tabId);\n    }\n  }\n});\nfunction switchTab(tabId) {\n  document.querySelectorAll(\".tab\").forEach((t) => t.classList.remove(\"active\"));\n  document.querySelectorAll(\".tab-content\").forEach((c) => c.classList.remove(\"active\"));\n  document.querySelector(`[data-tab=\"${tabId}\"]`)?.classList.add(\"active\");\n  document.querySelector(`[data-content=\"${tabId}\"]`)?.classList.add(\"active\");\n}\nanalyzeBtn.addEventListener(\"click\", async () => {\n  const responseFile = responseFileInput.files?.[0];\n  const referenceFile = referenceFileInput.files?.[0];\n  if (!responseFile) return;\n  analyzeBtn.disabled = true;\n  analyzeBtn.textContent = \"Analyzing...\";\n  try {\n    const responseData = await loadAudioFile(responseFile);\n    const referenceData = referenceFile ? await loadAudioFile(referenceFile) : null;\n    createAnalysisTab(responseData, referenceData, responseFile.name, referenceFile?.name || null);\n  } catch (error) {\n    alert(\"Error analyzing files: \" + error.message);\n  } finally {\n    analyzeBtn.disabled = false;\n    analyzeBtn.textContent = \"Analyze Frequency Response\";\n  }\n});\nasync function loadAudioFile(file) {\n  const headerBuffer = await file.slice(0, 256 * 1024).arrayBuffer();\n  function getExt(name) {\n    return (name.split(\".\").pop() || \"\").toLowerCase();\n  }\n  function parseWav(buf) {\n    const dv = new DataView(buf);\n    function readStr(off, len) {\n      let s = \"\";\n      for (let i = 0; i < len; i++) s += String.fromCharCode(dv.getUint8(off + i));\n      return s;\n    }\n    if (readStr(0, 4) !== \"RIFF\" || readStr(8, 4) !== \"WAVE\") return null;\n    let offset = 12;\n    const info = {};\n    while (offset + 8 <= dv.byteLength) {\n      const id = readStr(offset, 4);\n      const size = dv.getUint32(offset + 4, true);\n      if (id === \"fmt \") {\n        info.audioFormat = dv.getUint16(offset + 8, true);\n        info.numChannels = dv.getUint16(offset + 10, true);\n        info.sampleRate = dv.getUint32(offset + 12, true);\n        info.byteRate = dv.getUint32(offset + 16, true);\n        info.blockAlign = dv.getUint16(offset + 20, true);\n        info.bitsPerSample = dv.getUint16(offset + 22, true);\n      } else if (id === \"data\") {\n        info.dataChunkSize = size;\n      }\n      offset += 8 + size + size % 2;\n    }\n    if (info.sampleRate && info.byteRate && info.dataChunkSize) {\n      info.duration = info.dataChunkSize / info.byteRate;\n    }\n    return info;\n  }\n  function parseMp3(buf) {\n    const bytes = new Uint8Array(buf);\n    let offset = 0;\n    if (bytes[0] === 73 && bytes[1] === 68 && bytes[2] === 51) {\n      const size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n      offset = 10 + size;\n    }\n    let headerIndex = -1;\n    for (let i = offset; i < bytes.length - 4; i++) {\n      if (bytes[i] === 255 && (bytes[i + 1] & 224) === 224) {\n        headerIndex = i;\n        break;\n      }\n    }\n    if (headerIndex < 0) return null;\n    const b1 = bytes[headerIndex + 1];\n    const b2 = bytes[headerIndex + 2];\n    const b3 = bytes[headerIndex + 3];\n    const versionBits = b1 >> 3 & 3;\n    const layerBits = b1 >> 1 & 3;\n    const bitrateBits = b2 >> 4 & 15;\n    const sampleRateBits = b2 >> 2 & 3;\n    const channelMode = b3 >> 6 & 3;\n    const versions = {\n      0: \"MPEG Version 2.5\",\n      1: \"reserved\",\n      2: \"MPEG Version 2 (ISO/IEC 13818-3)\",\n      3: \"MPEG Version 1 (ISO/IEC 11172-3)\"\n    };\n    const layers = {\n      0: \"reserved\",\n      1: \"Layer III\",\n      2: \"Layer II\",\n      3: \"Layer I\"\n    };\n    const sampleRates = {\n      3: [44100, 48e3, 32e3],\n      2: [22050, 24e3, 16e3],\n      0: [11025, 12e3, 8e3]\n    };\n    const versionKey = versionBits;\n    const layerKey = layerBits;\n    const bitrateTable = {\n      // MPEG1 Layer III\n      \"3_1\": [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 0],\n      // MPEG2/2.5 Layer III\n      \"0_1\": [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0],\n      \"2_1\": [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0],\n      // fallback generic table for other layers/versions (best-effort)\n      \"3_2\": [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 0],\n      \"3_3\": [0, 32, 64, 96, 128, 160, 192, 224, 256, 320, 384, 448, 512, 576, 640, 0]\n    };\n    const versionStr = versions[versionKey] || \"unknown\";\n    const layerStr = layers[layerKey] || \"unknown\";\n    let sampleRate = sampleRates[versionKey]?.[sampleRateBits] || null;\n    let bitrateKbps = 0;\n    const tbKey = `${versionKey}_${layerKey}`;\n    if (bitrateTable[tbKey]) {\n      bitrateKbps = bitrateTable[tbKey][bitrateBits] || 0;\n    } else if (bitrateTable[\"3_1\"] && versionKey === 3 && layerKey === 1) {\n      bitrateKbps = bitrateTable[\"3_1\"][bitrateBits] || 0;\n    }\n    const channels = channelMode === 3 ? 1 : 2;\n    let duration = null;\n    if (bitrateKbps > 0) {\n      duration = bytes.length * 8 / (bitrateKbps * 1e3);\n    }\n    return {\n      version: versionStr,\n      layer: layerStr,\n      bitrateKbps: bitrateKbps || null,\n      sampleRate,\n      channels,\n      duration\n    };\n  }\n  const ext = getExt(file.name);\n  const mime = file.type || \"unknown\";\n  let metadata = {};\n  const wavInfo = parseWav(headerBuffer);\n  if (wavInfo) {\n    metadata.format = \"wav\";\n    metadata = Object.assign(metadata, wavInfo || {});\n  } else if (mime === \"audio/mpeg\" || ext === \"mp3\") {\n    const mp3Info = parseMp3(headerBuffer);\n    metadata.format = \"mp3\";\n    metadata = Object.assign(metadata, mp3Info || {});\n  } else {\n    metadata.format = mime || ext || \"unknown\";\n  }\n  console.log(\"Extracted file metadata:\", metadata);\n  const arrayBuffer = await file.arrayBuffer();\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n  console.log(\"Metadata:\", metadata);\n  return {\n    sampleRate: audioBuffer.sampleRate,\n    data: Array.from(audioBuffer.getChannelData(0)),\n    duration: audioBuffer.duration,\n    metadata\n  };\n}\nfunction createAnalysisTab(responseData, referenceData, filename, referenceFilename) {\n  tabCounter++;\n  const tabId = `analysis-${tabCounter}`;\n  let shortName = filename.length > 20 ? filename.substring(0, 17) + \"...\" : filename;\n  if (referenceFilename != null) {\n    const shortReferenceName = referenceFilename?.length > 20 ? referenceFilename.substring(0, 17) + \"...\" : referenceFilename;\n    shortName += \" / \" + shortReferenceName;\n  }\n  const tab = document.createElement(\"button\");\n  tab.className = \"tab tab-closable\";\n  tab.dataset.tab = tabId;\n  tab.innerHTML = `<span class=\"tab-icon-analysis\"></span>${shortName} <span class=\"tab-close\">\\u2715</span>`;\n  tabsContainer.appendChild(tab);\n  const content = document.createElement(\"div\");\n  content.className = \"tab-content\";\n  content.dataset.content = tabId;\n  content.innerHTML = `\n        <h2>${filename}</h2>\n        <div class=\"loose-container\">\n            <div id=\"plot-${tabId}\"></div>\n            <div id=\"plot-${tabId}1\"></div>\n        </div>\n    `;\n  tabContents.appendChild(content);\n  switchTab(tabId);\n  console.log(\"Analyzing response file:\", filename);\n  console.log(responseData, \"response samples\");\n  const data = new Float32Array(responseData.data);\n  console.log(\"Response data loaded\", data, \"samples\");\n  const responseFFT = computeFFT(data);\n  console.log(\"Response FFT computed\", responseFFT);\n  const traces = [{\n    x: responseFFT.frequency,\n    y: db(responseFFT.magnitude),\n    type: \"scatter\",\n    mode: \"lines\",\n    name: \"Response\",\n    line: { color: \"#0366d6\", width: 2 }\n  }];\n  const trace1s = [];\n  if (referenceData) {\n    const referenceFFT = twoChannelFFT(responseData.data, referenceData.data, responseFFT.fftSize, null);\n    const smoothedFreqResponse = smoothFFT(referenceFFT, 1 / 6, 1 / 48);\n    traces.push({\n      x: referenceFFT.frequency,\n      y: referenceFFT.magnitude,\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Frequency Response (Raw)\",\n      line: { color: \"#d73a4933\", width: 1 }\n    });\n    traces.push({\n      x: smoothedFreqResponse.frequency,\n      y: smoothedFreqResponse.magnitude,\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Frequency Response (Smoothed)\",\n      line: { color: \"#d73a49\", width: 2 }\n    });\n    trace1s.push({\n      x: referenceFFT.frequency,\n      y: referenceFFT.phase,\n      type: \"scatter\",\n      mode: \"lines\",\n      name: \"Reference Phase\",\n      line: { color: \"#d73a49\", width: 2 }\n    });\n  }\n  const layout = {\n    title: \"Frequency Analysis\",\n    plotGlPixelRatio: 2,\n    // For better clarity on high-DPI screens\n    xaxis: {\n      title: \"Frequency (Hz)\",\n      type: \"log\",\n      gridcolor: \"#e1e4e8\",\n      range: [Math.log10(20), Math.log10(24e3)]\n    },\n    yaxis: {\n      title: \"Magnitude (dB)\",\n      gridcolor: \"#e1e4e8\"\n    },\n    legend: { x: 0.02, y: 0.98 },\n    plot_bgcolor: \"#fafbfc\",\n    paper_bgcolor: \"#fff\",\n    font: {\n      family: \"'Newsreader', Georgia, 'Times New Roman', Times, serif\"\n    }\n  };\n  window.Plotly.newPlot(`plot-${tabId}`, traces, layout, { responsive: true });\n  const layouta = {\n    title: \"Phase Analysis\",\n    xaxis: {\n      title: \"Frequency (Hz)\",\n      type: \"log\",\n      gridcolor: \"#e1e4e8\",\n      range: [Math.log10(20), Math.log10(24e3)]\n    },\n    yaxis: {\n      title: \"Phase (degrees)\",\n      gridcolor: \"#e1e4e8\"\n    },\n    legend: { x: 0.02, y: 0.98 },\n    plot_bgcolor: \"#fafbfc\",\n    paper_bgcolor: \"#fff\",\n    staticPlot: false,\n    // Enable interactivity\n    plotGlPixelRatio: 2,\n    // For better clarity on high-DPI screens\n    dragmode: \"pan\",\n    showAxisDragHandles: true,\n    showAxisRangeEntryBoxes: true,\n    axisDragOnHover: true,\n    font: {\n      family: \"'Newsreader', Georgia, 'Times New Roman', Times, serif\"\n    }\n  };\n  window.Plotly.newPlot(`plot-${tabId}1`, trace1s, layouta, { responsive: true });\n  saveState();\n  storage.setItem(`${tabId}`, JSON.stringify({\n    filename,\n    referenceFilename,\n    responseData,\n    referenceData\n  })).catch((err) => console.error(\"Failed to persist analysis:\", err));\n}\nfunction saveState() {\n  const tabs = Array.from(document.querySelectorAll(\".tab[data-tab]\")).map((tab) => ({\n    id: tab.dataset.tab,\n    name: tab.textContent?.replace(\"\\xD7\", \"\").trim()\n  }));\n  storage.setItem(\"tabs\", JSON.stringify(tabs));\n}\nasync function loadState() {\n  try {\n    const savedTabs = await storage.getItem(\"tabs\");\n    if (!savedTabs) return;\n    const tabs = JSON.parse(savedTabs);\n    console.log(\"Loading saved tabs:\", tabs);\n    for (const tab of tabs) {\n      const raw = await storage.getItem(`${tab.id}`);\n      const analysisData = raw ? JSON.parse(raw) : null;\n      if (analysisData) {\n        console.log(\"Restoring analysis tab:\", analysisData);\n        createAnalysisTab(analysisData.responseData, analysisData.referenceData, analysisData.filename, analysisData.referenceFilename);\n      }\n    }\n  } catch (e) {\n    console.error(\"Failed to load saved state:\", e);\n  }\n}\nloadState();\n","console.debug(\"Math module loaded\");\n\nexport function logspace(start: number, end: number, num: number): number[] {\n    const logStart = Math.log10(start);\n    const logEnd = Math.log10(end);\n    const logStep = (logEnd - logStart) / (num - 1);\n    return Array.from({ length: num }, (_, i) => Math.pow(10, logStart + i * logStep));\n}\n\nexport function linspace(start: number, end: number, num: number): number[] {\n    if (num === 1) return [start];\n    const step = (end - start) / (num - 1);\n    return Array.from({ length: num }, (_, i) => start + i * step);\n}\n\nexport function closest(num: number, arr: number[]): number {\n    let curr = arr[0];\n    let diff = Math.abs(num - curr);\n    let index = 0;\n    for (let val = 0; val < arr.length; val++) {\n        const newDiff = Math.abs(num - arr[val]);\n        if (newDiff < diff) {\n            diff = newDiff;\n            curr = arr[val];\n            index = val;\n        }\n    }\n    return index;\n}\n\nexport function clamp(v: number, lower: number, upper: number): number {\n    return Math.max(lower, Math.min(upper, v));\n}\n\nexport const average = (array: number[]): number => array.reduce((a, b) => a + b) / array.length;\n\nexport const abs = (re: number, im: number = 0): number => Math.sqrt(re * re + im * im);","/* This software is licensed under the MIT License.\n\nCopyright Fedor Indutny, 2017.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\nconsole.debug(\"FFT module loaded\");\n\nexport class FFT {\n  size: number;\n  private _csize: number;\n  table: number[];\n  private _width: number;\n  private _bitrev: number[];\n  private _out: number[] | null;\n  private _data: number[] | null;\n  private _inv: number;\n\n  constructor(size: number) {\n    this.size = size | 0;\n    if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n      throw new Error('FFT size must be a power of two and bigger than 1');\n\n    this._csize = size << 1;\n\n    // NOTE: Use of `var` is intentional for old V8 versions\n    const table = new Array<number>(this.size * 2);\n    for (let i = 0; i < table.length; i += 2) {\n      const angle = Math.PI * i / this.size;\n      table[i] = Math.cos(angle);\n      table[i + 1] = -Math.sin(angle);\n    }\n    this.table = table;\n\n    // Find size's power of two\n    let power = 0;\n    for (let t = 1; this.size > t; t <<= 1)\n      power++;\n\n    // Calculate initial step's width:\n    //   * If we are full radix-4 - it is 2x smaller to give inital len=8\n    //   * Otherwise it is the same as `power` to give len=4\n    this._width = power % 2 === 0 ? power - 1 : power;\n\n    // Pre-compute bit-reversal patterns\n    this._bitrev = new Array<number>(1 << this._width);\n    for (let j = 0; j < this._bitrev.length; j++) {\n      this._bitrev[j] = 0;\n      for (let shift = 0; shift < this._width; shift += 2) {\n        const revShift = this._width - shift - 2;\n        this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n      }\n    }\n\n    this._out = null;\n    this._data = null;\n    this._inv = 0;\n  }\n\n  fromComplexArray(complex: number[] | Float32Array, storage?: number[] | Float32Array): number[] | Float32Array {\n    const res = storage || new Array<number>(complex.length >>> 1);\n    for (let i = 0; i < complex.length; i += 2)\n      res[i >>> 1] = complex[i];\n    return res;\n  }\n\n  createComplexArray(): number[] {\n    const res = new Array<number>(this._csize);\n    for (let i = 0; i < res.length; i++)\n      res[i] = 0;\n    return res;\n  }\n\n  toComplexArray(input: number[] | Float32Array, storage?: number[] | Float32Array): number[] | Float32Array {\n    const res = storage || this.createComplexArray();\n    for (let i = 0; i < res.length; i += 2) {\n      res[i] = input[i >>> 1];\n      res[i + 1] = 0;\n    }\n    return res;\n  }\n\n  completeSpectrum(spectrum: number[] | Float32Array): void {\n    const size = this._csize;\n    const half = size >>> 1;\n    for (let i = 2; i < half; i += 2) {\n      spectrum[size - i] = spectrum[i];\n      spectrum[size - i + 1] = -spectrum[i + 1];\n    }\n  }\n\n  transform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 0;\n    this._transform4();\n    this._out = null;\n    this._data = null;\n  }\n\n  realTransform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 0;\n    this._realTransform4();\n    this._out = null;\n    this._data = null;\n  }\n\n  inverseTransform(out: number[] | Float32Array, data: number[] | Float32Array): void {\n    if (out === data)\n      throw new Error('Input and output buffers must be different');\n\n    this._out = out as number[];\n    this._data = data as number[];\n    this._inv = 1;\n    this._transform4();\n    for (let i = 0; i < out.length; i++)\n      out[i] /= this.size;\n    this._out = null;\n    this._data = null;\n  }\n\n  // radix-4 implementation\n  //\n  // NOTE: Uses of `var` are intentional for older V8 version that do not\n  // support both `let compound assignments` and `const phi`\n  private _transform4(): void {\n    const out = this._out!;\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = (size / step) << 1;\n\n    let outOff: number;\n    let t: number;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform2(outOff, off, step);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleTransform4(outOff, off, step);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = (size / step) << 1;\n      const quarterLen = len >>> 2;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        // Full case\n        const limit = outOff + quarterLen;\n        for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n          const A = i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n\n          // Middle values\n          const MAr = Ar;\n          const MAi = Ai;\n\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n\n          const FCr = T0r - T2r;\n          const FCi = T0i - T2i;\n\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n\n          const FDr = T1r - T3i;\n          const FDi = T1i + T3r;\n\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          out[D] = FDr;\n          out[D + 1] = FDi;\n        }\n      }\n    }\n  }\n\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  private _singleTransform2(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n\n    const evenR = data[off];\n    const evenI = data[off + 1];\n    const oddR = data[off + step];\n    const oddI = data[off + step + 1];\n\n    const leftR = evenR + oddR;\n    const leftI = evenI + oddI;\n    const rightR = evenR - oddR;\n    const rightI = evenI - oddI;\n\n    out[outOff] = leftR;\n    out[outOff + 1] = leftI;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = rightI;\n  }\n\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  private _singleTransform4(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Ai = data[off + 1];\n    const Br = data[off + step];\n    const Bi = data[off + step + 1];\n    const Cr = data[off + step2];\n    const Ci = data[off + step2 + 1];\n    const Dr = data[off + step3];\n    const Di = data[off + step3 + 1];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T0i = Ai + Ci;\n    const T1r = Ar - Cr;\n    const T1i = Ai - Ci;\n    const T2r = Br + Dr;\n    const T2i = Bi + Di;\n    const T3r = inv * (Br - Dr);\n    const T3i = inv * (Bi - Di);\n\n    // Final values\n    const FAr = T0r + T2r;\n    const FAi = T0i + T2i;\n\n    const FBr = T1r + T3i;\n    const FBi = T1i - T3r;\n\n    const FCr = T0r - T2r;\n    const FCi = T0i - T2i;\n\n    const FDr = T1r - T3i;\n    const FDi = T1i + T3r;\n\n    out[outOff] = FAr;\n    out[outOff + 1] = FAi;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = FCi;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n\n  // Real input radix-4 implementation\n  private _realTransform4(): void {\n    const out = this._out!;\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = (size / step) << 1;\n\n    let outOff: number;\n    let t: number;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n        const off = bitrev[t];\n        this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    const inv = this._inv ? -1 : 1;\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = (size / step) << 1;\n      const halfLen = len >>> 1;\n      const quarterLen = halfLen >>> 1;\n      const hquarterLen = quarterLen >>> 1;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n          const A = outOff + i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n\n          // Middle values\n          const MAr = Ar;\n          const MAi = Ai;\n\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          const FAr = T0r + T2r;\n          const FAi = T0i + T2i;\n\n          const FBr = T1r + T3i;\n          const FBi = T1i - T3r;\n\n          out[A] = FAr;\n          out[A + 1] = FAi;\n          out[B] = FBr;\n          out[B + 1] = FBi;\n\n          // Output final middle point\n          if (i === 0) {\n            const FCr = T0r - T2r;\n            const FCi = T0i - T2i;\n            out[C] = FCr;\n            out[C + 1] = FCi;\n            continue;\n          }\n\n          // Do not overwrite ourselves\n          if (i === hquarterLen)\n            continue;\n\n          // In the flipped case:\n          // MAi = -MAi\n          // MBr=-MBi, MBi=-MBr\n          // MCr=-MCr\n          // MDr=MDi, MDi=MDr\n          const ST0r = T1r;\n          const ST0i = -T1i;\n          const ST1r = T0r;\n          const ST1i = -T0i;\n          const ST2r = -inv * T3i;\n          const ST2i = -inv * T3r;\n          const ST3r = -inv * T2i;\n          const ST3i = -inv * T2r;\n\n          const SFAr = ST0r + ST2r;\n          const SFAi = ST0i + ST2i;\n\n          const SFBr = ST1r + ST3i;\n          const SFBi = ST1i - ST3r;\n\n          const SA = outOff + quarterLen - i;\n          const SB = outOff + halfLen - i;\n\n          out[SA] = SFAr;\n          out[SA + 1] = SFAi;\n          out[SB] = SFBr;\n          out[SB + 1] = SFBi;\n        }\n      }\n    }\n  }\n\n  // radix-2 implementation\n  //\n  // NOTE: Only called for len=4\n  private _singleRealTransform2(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n\n    const evenR = data[off];\n    const oddR = data[off + step];\n\n    const leftR = evenR + oddR;\n    const rightR = evenR - oddR;\n\n    out[outOff] = leftR;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = rightR;\n    out[outOff + 3] = 0;\n  }\n\n  // radix-4\n  //\n  // NOTE: Only called for len=8\n  private _singleRealTransform4(outOff: number, off: number, step: number): void {\n    const out = this._out!;\n    const data = this._data!;\n    const inv = this._inv ? -1 : 1;\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Br = data[off + step];\n    const Cr = data[off + step2];\n    const Dr = data[off + step3];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T1r = Ar - Cr;\n    const T2r = Br + Dr;\n    const T3r = inv * (Br - Dr);\n\n    // Final values\n    const FAr = T0r + T2r;\n\n    const FBr = T1r;\n    const FBi = -T3r;\n\n    const FCr = T0r - T2r;\n\n    const FDr = T1r;\n    const FDi = T3r;\n\n    out[outOff] = FAr;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = FBr;\n    out[outOff + 3] = FBi;\n    out[outOff + 4] = FCr;\n    out[outOff + 5] = 0;\n    out[outOff + 6] = FDr;\n    out[outOff + 7] = FDi;\n  }\n}\n","import { average, closest, logspace, linspace } from './math';\n\nconsole.debug(\"Fractional Octave Smoothing module loaded\");\n\nexport function getFractionalOctaveFrequencies(fraction: number, f_low: number = 20, f_high: number = 24000, fftSize: number): number[] {\n    if (fraction <= 0) {\n        throw new Error(\"Fraction must be greater than 0\");\n    }\n    if (f_low <= 0 || f_high <= 0) {\n        throw new Error(\"Frequencies must be greater than 0\");\n    }\n    if (f_low >= f_high) {\n        throw new Error(\"f_low must be less than f_high\");\n    }\n    const num_points = Math.round((Math.log10(f_high) - Math.log10(f_low)) / fraction) + 1;\n\n    let frequencies = logspace(f_low, f_high, num_points);\n\n    const frequency_resolution = 48000 / fftSize; // Assuming a sample rate of 48000 Hz\n\n    for (let i = 0; i < frequencies.length; i++) {\n        frequencies[i] = Math.round(frequencies[i] / frequency_resolution) * frequency_resolution;\n    }\n    frequencies = Array.from(new Set(frequencies)); // Remove duplicates\n\n    return frequencies;\n}\n\nexport function fractionalOctaveSmoothing(frequencyData: number[], fraction: number, frequencies: number[]): Float32Array {\n    const frequenciesAll = linspace(0, 48000 / 2, frequencyData.length);\n    const frequency_resolution = 48000 / frequencyData.length;\n    const smoothedData = new Float32Array(frequencies.length);\n    const n = frequencyData.length;\n    const factor = Math.pow(2, (0.5 * fraction)) - Math.pow(0.5, (0.5 * fraction));\n    for (let p = 0; p < frequencies.length; p++) {\n        const i = closest(frequencies[p], frequenciesAll);\n        // If the distance between this and previous frequency is less than frequency_resolution, pass direct value\n\n        let sum = 0;\n        const width = Math.round(0.5 * factor * (n * 0.5 - Math.abs(n * 0.5 - i)));\n        if (width === 0) {\n            sum = frequencyData[i];\n        } else {\n            const as = frequencyData.slice(Math.round(i - width + 1), Math.min(Math.round(i + width), n - 1));\n            sum = average(as);\n        }\n        smoothedData[p] = sum;\n    }\n    return smoothedData;\n}","import { abs, closest, linspace } from './math';\nimport { FFT } from './fft';\nimport { fractionalOctaveSmoothing, getFractionalOctaveFrequencies } from './fractional_octave_smoothing';\n\nconsole.debug(\"Audio module loaded\");\n\n(window as any).FFT = FFT; // Make FFT globally available\n\nexport function rms(buffer: number[] | Float32Array): number {\n    let sum = 0;\n    for (let i = 0; i < buffer.length; i++) {\n        sum += buffer[i] * buffer[i];\n    }\n    return Math.sqrt(sum / buffer.length);\n}\n\nexport function normalize(input: number[] | Float32Array, peak: boolean = false): Float32Array {\n    const signal = Float32Array.from(input);\n\n    const rms_value = rms(input);\n    if (rms_value === 0) return Float32Array.from(input); // avoid division by zero, return original (silence)\n\n    const factor = (1 / rms_value) * (peak ? 1 : Math.SQRT2);\n\n    return signal.map(v => v * factor);\n}\n\nexport function exponentialMovingAverage(old: number, value: number, alpha: number): number {\n    return alpha * value + (1 - alpha) * old;\n}\n\nexport function db(value: Array<number>): Array<number>;\nexport function db(value: number): number;\nexport function db(value: Array<number> | number): Array<number> | number {\n    if (Array.isArray(value)) {\n        return value.map(v => 20 * Math.log10(v + 1e-12));\n    } else {\n        return 20 * Math.log10(value + 1e-12);\n    }\n}\n\nexport const smoothingFactor = (timeConstant: number, sampleRate: number): number => {\n    return 1 - Math.exp(-1 / (sampleRate * timeConstant));\n}\n\nexport function dbToLinear(db: number): number {\n    return Math.pow(10, db / 20);\n}\n\nexport function getExponentialSmoothingFactor(timeConstant: number, sampleRate: number): number {\n    return 1 - Math.exp(-1 / (timeConstant * sampleRate));\n}\n\nexport function linearToDb(linear: number): number {\n    return linear > 0 ? 20 * Math.log10(linear) : -Infinity;\n}\n\n/**\n * Generate a logarithmic chirp (sweep) similar to the provided Python version.\n * @param f_start - start frequency (Hz)\n * @param f_stop - stop frequency (Hz)\n * @param duration - total duration in seconds (if null, computed from rate)\n * @param rate - seconds per decade (if null, computed from duration)\n * @param fade - fade fraction (used to compute fade-in/out lengths)\n * @param fs - sample rate in Hz\n * @returns [sweepWindowed, timeVector, envelope]\n */\nexport function chirp(f_start: number, f_stop: number, duration: number | null = null, rate: number | null = null, fade: number = 0.01, fs: number = 48000): [Float32Array, Float32Array, Float32Array] {\n    const c = Math.log(f_stop / f_start);\n\n    let L: number;\n    let samples_count: number;\n\n    if (duration == null && rate == null) {\n        // Default to one decade per second if nothing provided\n        rate = 1.0;\n    }\n\n    if (duration == null) {\n        // rate is seconds per decade -> L = rate / ln(10)\n        L = (rate as number) / Math.log(10);\n        samples_count = Math.round(L * c * fs);\n        duration = samples_count / fs;\n    } else {\n        L = duration / c;\n        rate = Math.log(10) * L;\n        samples_count = Math.round(L * c * fs);\n    }\n\n    samples_count = Math.max(1, samples_count);\n\n    const fade_in = Math.max(0, Math.floor(fade * fs));\n    const fade_out = Math.max(0, Math.floor((fade / 10) * fs));\n\n    // instantaneous phase\n    // phi = (L * f_start) * (exp(t/L) - 1)\n    // compact phi: pre-fade (fade_in samples), main sweep, post-fade (fade_out samples)\n    const pre = Math.max(0, fade_in);\n    const post = Math.max(0, fade_out);\n    const phi = new Float32Array(pre + samples_count + post);\n\n    // offset matches original phi_fade_in last value: f_start * ((fade_in+1)/fs)\n    const offset = f_start * ((fade_in + 1) / fs);\n\n    // pre-fade linear ramp\n    for (let i = 0; i < pre; i++) phi[i] = f_start * (i / fs);\n\n    // main sweep (adds offset)\n    const baseIdx = pre;\n    for (let i = 0; i < samples_count; i++) {\n        let t = i / fs;\n        phi[baseIdx + i] = L * f_start * (Math.exp(t / L) - 1) + offset;\n    }\n\n    // post-fade linear ramp starting from last sweep value\n    const last = phi[baseIdx + samples_count - 1] || 0;\n    for (let i = 0; i < post; i++) {\n        phi[baseIdx + samples_count + i] = last + f_stop * ((i + 1) / fs);\n    }\n\n    // sweep = sin(2 * PI * phi)\n    const sweep = new Float32Array(phi.length);\n    for (let i = 0; i < phi.length; i++) sweep[i] = Math.sin(2 * Math.PI * phi[i]);\n\n    // compute time vector t for sweep length\n    const t = new Float32Array(sweep.length);\n    for (let i = 0; i < sweep.length; i++) t[i] = i / fs;\n\n    // envelope main: (exp(-t/L) / L) * f_stop * duration^2\n    const envMain = new Float32Array(t.length);\n    const factor = f_stop * (duration as number) * (duration as number);\n    for (let i = 0; i < t.length; i++) envMain[i] = (Math.exp(-t[i] / L) / L) * factor;\n\n    // prepend and append small zero pads (approx. 10ms and 1ms at given fs)\n    const startZeros = Math.floor(0.01 * fs); // ~480 samples at 48k\n    const endZeros = Math.floor(0.001 * fs);  // ~48 samples at 48k\n    const envelope = new Float32Array(startZeros + envMain.length + endZeros);\n    // zeros already, copy envMain into middle\n    envelope.set(envMain, startZeros);\n\n    // window: simple linear fade in/out over fade_in / fade_out samples\n    const window = new Float32Array(sweep.length);\n    for (let i = 0; i < sweep.length; i++) {\n        let w = 1.0;\n        if (fade_in > 0 && i < fade_in) {\n            w = i / Math.max(1, fade_in);\n        }\n        if (fade_out > 0 && i >= sweep.length - fade_out) {\n            const k = i - (sweep.length - fade_out);\n            w *= 1 - (k / Math.max(1, fade_out));\n        }\n        window[i] = w;\n    }\n\n    // apply window to sweep\n    const sweepWindowed = new Float32Array(sweep.length);\n    for (let i = 0; i < sweep.length; i++) sweepWindowed[i] = sweep[i] * window[i];\n\n    return [sweepWindowed, t, envelope];\n}\n\nexport interface FFTResult {\n    frequency: number[];\n    magnitude: number[];\n    phase: number[];\n    fftSize: number;\n}\n\nexport function smoothFFT(fftData: FFTResult, fraction: number, resolution: number): FFTResult {\n    const { frequency, magnitude, phase, fftSize } = fftData;\n    const smoothedMagnitude = new Float32Array(magnitude.length);\n\n    // Get fractional octave frequencies\n    const fractionalFrequencies = getFractionalOctaveFrequencies(resolution, 20, 24000, fftSize);\n\n    // Apply fractional octave smoothing\n    const smoothed = fractionalOctaveSmoothing(magnitude, fraction, fractionalFrequencies);\n\n    return {\n        frequency: fractionalFrequencies,\n        magnitude: Array.from(smoothed),\n        phase, // phase remains unchanged\n        fftSize\n    };\n}\n\nexport function computeFFT(data: Array<number> | Float32Array, fftSize: number | null = null): FFTResult {\n    fftSize ??= 2 ** Math.ceil(Math.log2(data.length));\n    console.log(`Computing FFT with ${fftSize} bins for data length ${data.length}`);\n    const fft = new FFT(fftSize);\n    const out = fft.createComplexArray();\n\n    // Fix data length by zero-padding or truncating.\n    const frame = new Float32Array(fftSize);\n    for (let i = 0; i < fftSize; i++) {\n        frame[i] = (data[i] || 0) * 1;\n    }\n    fft.realTransform(out, frame);\n    \n    const frequency: number[] = [];\n    const magnitude: number[] = [];\n    const phase: number[] = [];\n\n    for (let i = 0; i < fftSize / 2; i++) {\n            const re = out[2 * i];\n            const im = out[2 * i + 1];\n            magnitude[i] = abs(re, im) * Math.SQRT2; // Scale by sqrt(2) for single-sided spectrum.\n            phase[i] = Math.atan2(im, re); // phase in radians, range [-PI, PI].\n    }\n    const frequencyResolution = 48000 / fftSize; // Assuming sample rate of 48000 Hz\n    for (let i = 0; i < fftSize / 2; i++) {\n        frequency[i] = i * frequencyResolution;\n    }\n\n    return {\n        frequency,\n        magnitude,\n        phase,\n        fftSize,\n    };\n}\n\nexport interface CorrelationResult {\n    corr: Float64Array;\n    lags: Int32Array;\n    estimatedLagSamples: number;\n    estimatedLagIndex: number;\n    peakCorrelation: number;\n    raw: Float64Array;\n    nfft: number;\n}\n\nexport function fftCorrelation(x: number[] | Float32Array, y: number[] | Float32Array): CorrelationResult {\n    // cross-correlate x with y using FFT (fft.js). Returns normalized cross-correlation,\n    // lags (samples), estimated lag (samples) and peak correlation value.\n    const lenX = x.length;\n    const lenY = y.length;\n    const fullLen = lenX + lenY - 1;\n\n    // next pow2 >= fullLen\n    const nextPow2 = (v: number): number => {\n        let p = 1;\n        while (p < v) p <<= 1;\n        return p;\n    };\n    const n = nextPow2(fullLen);\n\n    // zero-pad inputs to length n\n    const xP = new Float32Array(n);\n    const yP = new Float32Array(n);\n    xP.set(x, 0);\n    yP.set(y, 0);\n\n    const fft = new FFT(n);\n    const A = fft.createComplexArray();\n    const B = fft.createComplexArray();\n\n    // forward real FFTs\n    fft.realTransform(A, xP);\n    fft.realTransform(B, yP);\n    // complete the spectrum to full complex arrays (negative freqs)\n    if (typeof fft.completeSpectrum === 'function') {\n        fft.completeSpectrum(A);\n        fft.completeSpectrum(B);\n    }\n\n    // multiply A * conj(B) -> cross-spectrum\n    const C = fft.createComplexArray();\n    for (let k = 0; k < n; k++) {\n        const ar = A[2 * k], ai = A[2 * k + 1];\n        const br = B[2 * k], bi = B[2 * k + 1];\n        // A * conj(B) = (ar + i ai)*(br - i bi)\n        C[2 * k] = ar * br + ai * bi;\n        C[2 * k + 1] = ai * br - ar * bi;\n    }\n\n    // inverse FFT of cross-spectrum\n    const out = fft.createComplexArray();\n    fft.inverseTransform(out, C);\n\n    // real part / n gives linear cross-correlation (no circular wrap because padded)\n    const corr = new Float64Array(fullLen);\n    for (let i = 0; i < fullLen; i++) {\n        corr[i] = out[2 * i] / n;\n    }\n\n    // compute normalization factor (energy)\n    let sumX2 = 0, sumY2 = 0;\n    for (let i = 0; i < lenX; i++) sumX2 += x[i] * x[i];\n    for (let i = 0; i < lenY; i++) sumY2 += y[i] * y[i];\n    const denom = Math.sqrt(sumX2 * sumY2);\n\n    const normalized = new Float64Array(fullLen);\n    if (denom > 0) {\n        for (let i = 0; i < fullLen; i++) normalized[i] = corr[i] / denom;\n    } else {\n        // silence case -> zeros\n        for (let i = 0; i < fullLen; i++) normalized[i] = 0;\n    }\n\n    // lags: index i corresponds to lag = i - (lenY - 1)\n    const lags = new Int32Array(fullLen);\n    for (let i = 0; i < fullLen; i++) lags[i] = i - (lenY - 1);\n\n    // find peak\n    let peakIdx = 0;\n    let peakVal = -Infinity;\n    for (let i = 0; i < fullLen; i++) {\n        if (normalized[i] > peakVal) {\n            peakVal = normalized[i];\n            peakIdx = i;\n        }\n    }\n    const estimatedLag = lags[peakIdx];\n\n    return {\n        corr: normalized,\n        lags,\n        estimatedLagSamples: estimatedLag,\n        estimatedLagIndex: peakIdx,\n        peakCorrelation: peakVal,\n        raw: corr,\n        nfft: n\n    };\n}\n\nexport function twoChannelFFT(dataArray: number[] | Float32Array, reference: number[] | Float32Array, fftSize: number, windowType: any): FFTResult {\n    const referencePadded = new Float32Array(fftSize);\n\n    const lag = fftCorrelation(dataArray, reference);\n    console.log('Estimated lag (samples):', lag.estimatedLagSamples, 'Peak correlation:', lag.peakCorrelation);\n    console.log('Lag index:', lag.estimatedLagIndex);\n    console.log('Lags array:', referencePadded.length, lag.lags);\n    const offset = reference.length + lag.estimatedLagSamples - 1;\n    console.log('Applying offset of', offset, 'samples for alignment');\n    referencePadded.set(reference.slice(0, Math.min(reference.length, fftSize) - offset), offset);\n\n    //const rmss = rms(referencePadded);\n    const reference_ = computeFFT(referencePadded);  // Avoid log(0)\n    const signal_ = computeFFT(dataArray);\n    const signalMags = signal_.magnitude.map(v => 20 * Math.log10(v === 0 ? 1e-20 : v));\n    const referenceMags = reference_.magnitude.map(v => 20 * Math.log10(v === 0 ? 1e-20 : v));\n    const h = referenceMags.map((v, i) => signalMags[i] - v); // dB difference\n    const frequency = linspace(0, 48000 / 2, h.length);\n\n    // For phase, align the reference and signal using a fixed offset (26718 samples for 1m @ 340m/s and 48kHz)\n    // This is a hack to get a reasonable phase response for the measurement setup\n    // In a real application, use cross-correlation to find the delay between signals\n\n    const i_50 = closest(50, frequency); // Example usage of closest function\n    const phase_signal = signal_.phase;\n    const phase_reference = reference_.phase;\n    // phase difference (unwrap phases first)\n    const sphase = unwrapPhase(phase_signal.map((v, i) => v - phase_reference[i])); // phase difference in radians\n    const correction = (Math.floor(sphase[i_50] / (2 * Math.PI) + 0.5)) * (2 * Math.PI);\n    const phase = sphase.map(v => (v - correction)); // relative to 50 Hz\n\n    // simple phase unwrapping (returns Float32Array)\n    function unwrapPhase(phases: number[]): Array<number> {\n        const N = phases.length;\n        const out = Array.from(new Float32Array(N));\n        if (N === 0) return out;\n        out[0] = phases[0];\n        let offset = 0;\n        for (let i = 1; i < N; i++) {\n            let delta = phases[i] - phases[i - 1];\n            if (delta > Math.PI) {\n                offset -= 2 * Math.PI;\n            } else if (delta < -Math.PI) {\n                offset += 2 * Math.PI;\n            }\n            out[i] = phases[i] + offset;\n        }\n        return out;\n    }\n\n    return {\n        frequency,\n        magnitude: h,\n        phase,\n        fftSize\n    };\n}\n\nexport const A_WEIGHTING_COEFFICIENTS: [number[], number[]] = [\n    [0.234301792299513, -0.468603584599026, -0.234301792299513, 0.937207169198054, -0.234301792299515, -0.468603584599025, 0.234301792299513],\n    [1.000000000000000, -4.113043408775871, 6.553121752655047, -4.990849294163381, 1.785737302937573, -0.246190595319487, 0.011224250033231],\n];\n// Coefficients for K-weighting filter (pre-emphasis and high-frequency shelving)\n// From ITU-R BS.1770-4, Table 1\n// https://www.itu.int/dms_pubrec/itu-r/rec/bs/r-rec-bs.1770-2-201103-s!!pdf-e.pdf\nexport const K_WEIGHTING_COEFFICIENTS_PRE: [number[], number[]] = [\n    [1.53512485958697, -2.69169618940638, 1.19839281085285],\n    [1, -1.69065929318241, 0.73248077421585]\n];\n\nexport const K_WEIGHTING_COEFFICIENTS_RLB: [number[], number[]] = [\n    [1.0, -2.0, 1.0],\n    [1, -1.99004745483398, 0.99007225036621]\n];\n\nexport function applyAWeightingToBuffer(buffer: Float32Array, zi: number[]): Float32Array {\n    const b = A_WEIGHTING_COEFFICIENTS[0];\n    const a = A_WEIGHTING_COEFFICIENTS[1];\n    const output = new Float32Array(buffer.length);\n    for (let n = 0; n < buffer.length; n++) {\n        output[n] = b[0] * buffer[n] + zi[0];\n        for (let i = 1; i < b.length; i++) {\n            zi[i - 1] = b[i] * buffer[n] + zi[i] - a[i] * output[n];\n        }\n    }\n    return output;\n}\n\nexport function gateBuffer(buffer: Float32Array, sampleRate: number, thresholdDb: number = -70, blockMs: number = 400, overlap: number = 0.75): Float32Array {\n    const blockSize = Math.floor((blockMs / 1000) * sampleRate);\n    const hopSize = Math.floor(blockSize * (1 - overlap));\n    const threshold = dbToLinear(thresholdDb);\n\n    const gated = new Float32Array(buffer.length);\n    let i = 0;\n\n    while (i < buffer.length) {\n        const start = i;\n        const end = Math.min(i + blockSize, buffer.length);\n        const block = buffer.subarray(start, end);\n        const blockRms = rms(block);\n\n        if (blockRms >= threshold) {\n            gated.set(block, start);\n        }\n        // else: leave zeros (gate closed)\n\n        i += hopSize;\n    }\n\n    return gated;\n}\n\n/**\n * Calculate ITU-R BS.1770-4 loudness (LKFS/LUFS) for a mono or stereo buffer.\n * https://www.itu.int/dms_pubrec/itu-r/rec/bs/R-REC-BS.1770-5-202311-I!!PDF-E.pdf\n * @param input - Mono buffer or array of channel buffers.\n * @param sampleRate - Sample rate in Hz.\n * @returns Integrated loudness in LUFS.\n */\nexport function bs1770Loudness(input: Float32Array | Float32Array[], sampleRate: number): number {\n    // K-weighting filter coefficients (biquad, 2nd order)\n    // From ITU-R BS.1770-4, Table 1\n    const b = [1.53512485958697, -2.69169618940638, 1.19839281085285];\n    const a = [1, -1.69065929318241, 0.73248077421585];\n\n    // Helper: apply biquad filter to a buffer\n    function biquadFilter(buffer: Float32Array, b: number[], a: number[]): Float32Array {\n        const out = new Float32Array(buffer.length);\n        let x1 = 0, x2 = 0, y1 = 0, y2 = 0;\n        for (let n = 0; n < buffer.length; n++) {\n            const x0 = buffer[n];\n            const y0 = b[0] * x0 + b[1] * x1 + b[2] * x2 - a[1] * y1 - a[2] * y2;\n            out[n] = y0;\n            x2 = x1; x1 = x0;\n            y2 = y1; y1 = y0;\n        }\n        return out;\n    }\n\n    // Accept mono or stereo\n    let channels: Float32Array[];\n    if (Array.isArray(input)) {\n        channels = input;\n    } else {\n        channels = [input];\n    }\n\n    // Apply K-weighting filter to each channel\n    const filtered = channels.map(ch => biquadFilter(ch, b, a));\n\n    // Gating parameters\n    const windowMs = 400;\n    const windowSize = Math.floor(windowMs * sampleRate / 1000);\n    const overlapRatio = 0.75;\n    const hopSize = Math.floor(windowSize * (1 - overlapRatio));\n    const absoluteGate = dbToLinear(-70);\n    const relativeGateOffset = -10; // dB\n\n    // Calculate channel weights (ITU: [1, 1] for stereo)\n    const weights = channels.length === 2 ? [1, 1] : [1];\n\n    // Calculate block energies\n    let energies: number[] = [];\n    for (let i = 0; i + windowSize <= filtered[0].length; i += hopSize) {\n        let sum = 0;\n        for (let ch = 0; ch < filtered.length; ch++) {\n            const block = filtered[ch].subarray(i, i + windowSize);\n            const blockSum = block.reduce((acc, v) => acc + v * v, 0);\n            sum += weights[ch] * blockSum;\n        }\n        const energy = sum / (windowSize * weights.reduce((a, b) => a + b, 0));\n        energies.push(energy);\n    }\n\n    // Absolute gating\n    const gatedEnergies = energies.filter(e => e >= absoluteGate);\n\n    if (gatedEnergies.length === 0) return -Infinity;\n\n    // Relative gating\n    const meanEnergy = gatedEnergies.reduce((a, b) => a + b, 0) / gatedEnergies.length;\n    const relativeGate = meanEnergy * dbToLinear(relativeGateOffset);\n    const finalEnergies = gatedEnergies.filter(e => e >= relativeGate);\n\n    if (finalEnergies.length === 0) return -Infinity;\n\n    // Integrated loudness (LUFS)\n    const integrated = finalEnergies.reduce((a, b) => a + b, 0) / finalEnergies.length;\n    return linearToDb(Math.sqrt(integrated));\n}","// IndexedDB-backed storage helpers\nfunction openIDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n        const req = indexedDB.open('dunkadunka-storage', 1);\n        req.onupgradeneeded = () => {\n            const db = req.result;\n            if (!db.objectStoreNames.contains('kv')) {\n                db.createObjectStore('kv', { keyPath: 'key' });\n            }\n        };\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n    });\n}\n\nasync function setItem(key: string, value: string): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.put({ key, value });\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n        // mirror to sessionStorage for synchronous reads elsewhere\n        try { setItem(key, value); } catch { /* ignore */ }\n    } catch (e) {\n        console.error('setItem(idb) failed', e);\n    }\n}\n\nasync function getItem(key: string): Promise<string | null> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readonly');\n        const store = tx.objectStore('kv');\n        const req = store.get(key);\n        const res = await new Promise<any>((resolve, reject) => {\n            req.onsuccess = () => resolve(req.result);\n            req.onerror = () => reject(req.error);\n        });\n        return res?.value ?? null;\n    } catch (e) {\n        console.error('getItem(idb) failed', e);\n        return null;\n    }\n}\n\nasync function removeItem(key: string): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.delete(key);\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n    } catch (e) {\n        console.error('removeItem(idb) failed', e);\n    }\n}\n\nasync function clearStorage(): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readwrite');\n        const store = tx.objectStore('kv');\n        store.clear();\n        await new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(tx.error);\n        });\n        // also clear sessionStorage\n        try { sessionStorage.clear(); } catch { /* ignore */ }\n    } catch (e) {\n        console.error('clearStorage(idb) failed', e);\n    }\n}\n\nasync function dumpStorage(): Promise<void> {\n    try {\n        const db = await openIDB();\n        const tx = db.transaction('kv', 'readonly');\n        const store = tx.objectStore('kv');\n        const req = store.openCursor();\n        req.onsuccess = (event) => {\n            const cursor = (event.target as IDBRequest).result;\n            if (cursor) {\n                console.log(`Key: ${cursor.key}, Value: ${cursor.value.value}`);\n                cursor.continue();\n            }\n        };\n        req.onerror = () => {\n            console.error('dumpStorage(idb) failed', req.error);\n        };\n    } catch (e) {\n        console.error('dumpStorage(idb) failed', e);\n    }\n}\n\nexport const storage = {\n    setItem,\n    getItem,\n    removeItem,\n    clearStorage,\n    dumpStorage\n};","import { FFT } from \"./fft\";\nimport { getFractionalOctaveFrequencies, fractionalOctaveSmoothing } from \"./fractional_octave_smoothing\";\nimport { abs } from \"./math\";\nimport { computeFFT, db, smoothFFT, twoChannelFFT } from \"./audio\";\nimport { storage } from \"./storage\";\n\nconsole.debug(\"App module loaded\");\n\nconst root = document.documentElement;\nconst uiColor = \"#0366d6\";\nroot.style.setProperty('--color', uiColor);\n\nlet tabCounter = 0;\nconst tabsContainer = document.getElementById('tabs') as HTMLElement;\nconst tabContents = document.getElementById('tab-contents') as HTMLElement;\nconst responseFileInput = document.getElementById('responseFile') as HTMLInputElement;\nconst referenceFileInput = document.getElementById('referenceFile') as HTMLInputElement;\nconst analyzeBtn = document.getElementById('analyzeBtn') as HTMLButtonElement;\n\ninterface Audio {\n    sampleRate: number;\n    data: Array<number>;\n    duration: number;\n    metadata?: {[Key: string]: string | number | null};\n}\n\n// Enable analyze button when response file is selected\nresponseFileInput.addEventListener('change', () => {\n    analyzeBtn.disabled = !responseFileInput.files?.length;\n});\n\nstorage.dumpStorage();\n\n// Tab switching\ntabsContainer.addEventListener('click', (e: MouseEvent) => {\n    const target = e.target as HTMLElement;\n    \n    if (target.classList.contains('tab-close')) {\n        const tab = target.parentElement as HTMLElement;\n        const tabId = tab.dataset.tab;\n        if (tabId == 'upload') return;\n\n        console.debug('Closing tab', tabId);\n        tab.remove();\n        document.querySelector(`[data-content=\"${tabId}\"]`)?.remove();\n        storage.removeItem(`analysis-${tabId}`).catch(err => console.error('Failed to remove analysis from storage:', err));\n        \n        // Activate upload tab if current was closed\n        if (tab.classList.contains('active')) {\n            switchTab('upload');\n        }\n        e.stopPropagation();\n    } else if (target.classList.contains('tab')) {\n        const tabId = target.dataset.tab;\n        if (tabId) {\n            switchTab(tabId);\n        }\n    }\n});\n\nfunction switchTab(tabId: string): void {\n    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));\n    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));\n    \n    document.querySelector(`[data-tab=\"${tabId}\"]`)?.classList.add('active');\n    document.querySelector(`[data-content=\"${tabId}\"]`)?.classList.add('active');\n}\n\nanalyzeBtn.addEventListener('click', async () => {\n    const responseFile = responseFileInput.files?.[0];\n    const referenceFile = referenceFileInput.files?.[0];\n\n    if (!responseFile) return;\n\n    analyzeBtn.disabled = true;\n    analyzeBtn.textContent = 'Analyzing...';\n\n    try {\n        const responseData = await loadAudioFile(responseFile);\n        const referenceData = referenceFile ? await loadAudioFile(referenceFile) : null;\n\n        createAnalysisTab(responseData, referenceData, responseFile.name, referenceFile?.name || null);\n    } catch (error) {\n        alert('Error analyzing files: ' + (error as Error).message);\n    } finally {\n        analyzeBtn.disabled = false;\n        analyzeBtn.textContent = 'Analyze Frequency Response';\n    }\n});\n\nasync function loadAudioFile(file: File): Promise<Audio> {\n    const headerBuffer = await file.slice(0, 256 * 1024).arrayBuffer();\n\n    function getExt(name: string) {\n        return (name.split('.').pop() || '').toLowerCase();\n    }\n\n    function parseWav(buf: ArrayBuffer) {\n        const dv = new DataView(buf);\n        function readStr(off: number, len: number) {\n            let s = '';\n            for (let i = 0; i < len; i++) s += String.fromCharCode(dv.getUint8(off + i));\n            return s;\n        }\n\n        if (readStr(0, 4) !== 'RIFF' || readStr(8, 4) !== 'WAVE') return null;\n\n        let offset = 12;\n        const info: any = {};\n        while (offset + 8 <= dv.byteLength) {\n            const id = readStr(offset, 4);\n            const size = dv.getUint32(offset + 4, true);\n            if (id === 'fmt ') {\n                info.audioFormat = dv.getUint16(offset + 8, true);\n                info.numChannels = dv.getUint16(offset + 10, true);\n                info.sampleRate = dv.getUint32(offset + 12, true);\n                info.byteRate = dv.getUint32(offset + 16, true);\n                info.blockAlign = dv.getUint16(offset + 20, true);\n                info.bitsPerSample = dv.getUint16(offset + 22, true);\n            } else if (id === 'data') {\n                info.dataChunkSize = size;\n            }\n            offset += 8 + size + (size % 2);\n        }\n        if (info.sampleRate && info.byteRate && info.dataChunkSize) {\n            info.duration = info.dataChunkSize / info.byteRate;\n        }\n        return info;\n    }\n\n    function parseMp3(buf: ArrayBuffer) {\n        const bytes = new Uint8Array(buf);\n        let offset = 0;\n        // Skip ID3v2 tag if present\n        if (bytes[0] === 0x49 && bytes[1] === 0x44 && bytes[2] === 0x33) {\n            const size = ((bytes[6] & 0x7f) << 21) | ((bytes[7] & 0x7f) << 14) | ((bytes[8] & 0x7f) << 7) | (bytes[9] & 0x7f);\n            offset = 10 + size;\n        }\n        // find first frame header\n        let headerIndex = -1;\n        for (let i = offset; i < bytes.length - 4; i++) {\n            if (bytes[i] === 0xFF && (bytes[i + 1] & 0xE0) === 0xE0) {\n                headerIndex = i;\n                break;\n            }\n        }\n        if (headerIndex < 0) return null;\n        const b1 = bytes[headerIndex + 1];\n        const b2 = bytes[headerIndex + 2];\n        const b3 = bytes[headerIndex + 3];\n\n        const versionBits = (b1 >> 3) & 0x03;\n        const layerBits = (b1 >> 1) & 0x03;\n        const bitrateBits = (b2 >> 4) & 0x0f;\n        const sampleRateBits = (b2 >> 2) & 0x03;\n        const channelMode = (b3 >> 6) & 0x03;\n\n        const versions: any = {\n            0: 'MPEG Version 2.5',\n            1: 'reserved',\n            2: 'MPEG Version 2 (ISO/IEC 13818-3)',\n            3: 'MPEG Version 1 (ISO/IEC 11172-3)'\n        };\n        const layers: any = {\n            0: 'reserved',\n            1: 'Layer III',\n            2: 'Layer II',\n            3: 'Layer I'\n        };\n\n        const sampleRates: any = {\n            3: [44100, 48000, 32000],\n            2: [22050, 24000, 16000],\n            0: [11025, 12000, 8000]\n        };\n        const versionKey = versionBits;\n        const layerKey = layerBits;\n\n        // bitrate tables (kbps)\n        const bitrateTable: any = {\n            // MPEG1 Layer III\n            '3_1': [0,32,40,48,56,64,80,96,112,128,160,192,224,256,320,0],\n            // MPEG2/2.5 Layer III\n            '0_1': [0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0],\n            '2_1': [0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0],\n            // fallback generic table for other layers/versions (best-effort)\n            '3_2': [0,32,48,56,64,80,96,112,128,160,192,224,256,320,384,0],\n            '3_3': [0,32,64,96,128,160,192,224,256,320,384,448,512,576,640,0]\n        };\n\n        const versionStr = versions[versionKey] || 'unknown';\n        const layerStr = layers[layerKey] || 'unknown';\n        let sampleRate = sampleRates[versionKey]?.[sampleRateBits] || null;\n\n        let bitrateKbps = 0;\n        const tbKey = `${versionKey}_${layerKey}`;\n        if (bitrateTable[tbKey]) {\n            bitrateKbps = bitrateTable[tbKey][bitrateBits] || 0;\n        } else if (bitrateTable['3_1'] && versionKey === 3 && layerKey === 1) {\n            bitrateKbps = bitrateTable['3_1'][bitrateBits] || 0;\n        }\n\n        const channels = channelMode === 3 ? 1 : 2;\n        let duration = null;\n        if (bitrateKbps > 0) {\n            duration = (bytes.length * 8) / (bitrateKbps * 1000);\n        }\n\n        return {\n            version: versionStr,\n            layer: layerStr,\n            bitrateKbps: bitrateKbps || null,\n            sampleRate,\n            channels,\n            duration\n        };\n    }\n\n    const ext = getExt(file.name);\n    const mime = file.type || 'unknown';\n    let metadata: {[Key: string]: string | number | null} = {};\n\n    const wavInfo = parseWav(headerBuffer);\n    if (wavInfo) {\n        metadata.format = 'wav';\n        metadata = Object.assign(metadata, wavInfo || {});\n    } else if (mime === 'audio/mpeg' || ext === 'mp3') {\n        const mp3Info = parseMp3(headerBuffer);\n        metadata.format = 'mp3';\n        metadata = Object.assign(metadata, mp3Info || {});\n    } else {\n        // best-effort: report file.type and extension and later rely on AudioContext decode\n        metadata.format = mime || ext || 'unknown';\n    }\n\n    console.log('Extracted file metadata:', metadata);\n    const arrayBuffer = await file.arrayBuffer();\n    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n    \n    console.log('Metadata:', metadata);\n    return {\n        sampleRate: audioBuffer.sampleRate,\n        data: Array.from(audioBuffer.getChannelData(0)),\n        duration: audioBuffer.duration,\n        metadata\n    };\n}\n\nfunction createAnalysisTab(responseData: Audio, referenceData: Audio | null, filename: string, referenceFilename: string | null): void {\n    tabCounter++;\n    const tabId = `analysis-${tabCounter}`;\n    let shortName = filename.length > 20 ? filename.substring(0, 17) + '...' : filename;\n    if (referenceFilename != null) {\n        const shortReferenceName = referenceFilename?.length > 20 ? referenceFilename.substring(0, 17) + '...' : referenceFilename;\n        shortName += ' / ' + shortReferenceName;\n    }\n    // Create tab button\n    const tab = document.createElement('button');\n    tab.className = 'tab tab-closable';\n    tab.dataset.tab = tabId;\n    tab.innerHTML = `<span class=\"tab-icon-analysis\"></span>${shortName} <span class=\"tab-close\"></span>`;\n    tabsContainer.appendChild(tab);\n\n    // Create tab content\n    const content = document.createElement('div');\n    content.className = 'tab-content';\n    content.dataset.content = tabId;\n    content.innerHTML = `\n        <h2>${filename}</h2>\n        <div class=\"loose-container\">\n            <div id=\"plot-${tabId}\"></div>\n            <div id=\"plot-${tabId}1\"></div>\n        </div>\n    `;\n    tabContents.appendChild(content);\n\n    // Switch to new tab\n    switchTab(tabId);\n\n    // Compute and plot FFTs\n    console.log('Analyzing response file:', filename);\n    console.log(responseData, 'response samples');\n    const data = new Float32Array(responseData.data);\n    console.log('Response data loaded', data, 'samples');\n    \n    const responseFFT = computeFFT(data);\n    console.log('Response FFT computed', responseFFT);\n    \n    const traces: any[] = [{\n        x: responseFFT.frequency,\n        y: db(responseFFT.magnitude),\n        type: 'scatter',\n        mode: 'lines',\n        name: 'Response',\n        line: { color: '#0366d6', width: 2 }\n    }];\n    const trace1s: any[] = [];\n\n    if (referenceData) {\n        const referenceFFT = twoChannelFFT(responseData.data, referenceData.data, responseFFT.fftSize, null);\n        \n        /*traces.push({\n            x: referenceFFT.frequency,\n            y: db(referenceFFT.magnitude),\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Reference',\n            line: { color: '#28a745', width: 2 }\n        });\n\n        // Frequency response (difference)\n        const freqResponse = responseFFT.magnitude.map((val, i) => \n            db(val) - db((referenceFFT.magnitude[i]))\n        );\n        \n        traces.push({\n            x: responseFFT.frequency,\n            y: freqResponse,\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Frequency Response',\n            line: { color: '#d73a4933', width: 1 }\n        });\n        \n        const smoothedFreqResponse = smoothFFT({\n            frequency: responseFFT.frequency,\n            magnitude: freqResponse,\n            phase: responseFFT.phase,\n            fftSize: responseFFT.fftSize\n        }, 1/3, 1/48);\n\n        traces.push({\n            x: smoothedFreqResponse.frequency,\n            y: smoothedFreqResponse.magnitude,\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Frequency Response',\n            line: { color: '#d73a49', width: 2 }\n        });\n        */\n        const smoothedFreqResponse = smoothFFT(referenceFFT, 1/6, 1/48);\n        traces.push({\n            x: referenceFFT.frequency,\n            y: referenceFFT.magnitude,\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Frequency Response (Raw)',\n            line: { color: '#d73a4933', width: 1 }\n        });\n        traces.push({\n            x: smoothedFreqResponse.frequency,\n            y: smoothedFreqResponse.magnitude,\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Frequency Response (Smoothed)',\n            line: { color: '#d73a49', width: 2 }\n        });\n\n        trace1s.push({\n            x: referenceFFT.frequency,\n            y: referenceFFT.phase,\n            type: 'scatter',\n            mode: 'lines',\n            name: 'Reference Phase',\n            line: { color: '#d73a49', width: 2 }\n        });\n    }\n\n    const layout = {\n        title: 'Frequency Analysis',\n        plotGlPixelRatio: 2, // For better clarity on high-DPI screens\n        xaxis: { \n            title: 'Frequency (Hz)', \n            type: 'log',\n            gridcolor: '#e1e4e8',\n            range: [Math.log10(20), Math.log10(24000)],\n        },\n        yaxis: { \n            title: 'Magnitude (dB)',\n            gridcolor: '#e1e4e8'\n        },\n        legend: { x: 0.02, y: 0.98 },\n        plot_bgcolor: '#fafbfc',\n        paper_bgcolor: '#fff',\n        font: {\n            family: \"'Newsreader', Georgia, 'Times New Roman', Times, serif\",\n        },\n    };\n\n    (window as any).Plotly.newPlot(`plot-${tabId}`, traces, layout, { responsive: true });\n\n    const layouta = {\n        title: 'Phase Analysis',\n        xaxis: { \n            title: 'Frequency (Hz)', \n            type: 'log',\n            gridcolor: '#e1e4e8',\n            range: [Math.log10(20), Math.log10(24000)],\n        },\n        yaxis: { \n            title: 'Phase (degrees)',\n            gridcolor: '#e1e4e8'\n        },\n        legend: { x: 0.02, y: 0.98 },\n        plot_bgcolor: '#fafbfc',\n        paper_bgcolor: '#fff',\n        staticPlot: false, // Enable interactivity\n        plotGlPixelRatio: 2, // For better clarity on high-DPI screens\n        dragmode: 'pan',\n        showAxisDragHandles: true,\n        showAxisRangeEntryBoxes: true,\n        axisDragOnHover: true,\n        font: {\n            family: \"'Newsreader', Georgia, 'Times New Roman', Times, serif\",\n        },\n    };\n\n    (window as any).Plotly.newPlot(`plot-${tabId}1`, trace1s, layouta, { responsive: true });\n\n    saveState();\n\n    // Persist analysis using IndexedDB (mirrored to sessionStorage for compatibility)\n    storage.setItem(`${tabId}`, JSON.stringify({\n        filename,\n        referenceFilename,\n        responseData,\n        referenceData,\n    })).catch(err => console.error('Failed to persist analysis:', err));\n}\n\n// Save and load state from sessionStorage\nfunction saveState(): void {\n    const tabs = Array.from(document.querySelectorAll('.tab[data-tab]')).map(tab => ({\n        id: (tab as HTMLElement).dataset.tab,\n        name: (tab as HTMLElement).textContent?.replace('', '').trim()\n    }));\n    \n    storage.setItem('tabs', JSON.stringify(tabs));\n}\n\nasync function loadState(): Promise<void> {\n    try {\n        const savedTabs = await storage.getItem('tabs');\n        if (!savedTabs) return;\n        const tabs = JSON.parse(savedTabs);\n        console.log('Loading saved tabs:', tabs);\n\n        for (const tab of tabs as { id: string; name: string }[]) {\n            // Call createAnalysisTab for each tab\n            const raw = await storage.getItem(`${tab.id}`);\n            const analysisData = raw ? JSON.parse(raw) : null;\n            if (analysisData) {\n                console.log('Restoring analysis tab:', analysisData);\n                createAnalysisTab(analysisData.responseData, analysisData.referenceData, analysisData.filename, analysisData.referenceFilename);\n            }\n        }\n        // Tabs will be recreated when user analyzes files again\n    } catch (e) {\n        console.error('Failed to load saved state:', e);\n    }\n}\n\n// Load state on page load\nloadState();"]}